% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/v.R
\name{vli}
\alias{vli}
\alias{v_degree}
\alias{v_eccentricity}
\alias{v_betweenness}
\alias{v_stress}
\alias{v_eigenvector}
\alias{v_closeness}
\alias{v_harmonic}
\alias{v_pagerank}
\alias{v_geokpath}
\alias{v_shapley}
\title{Vertex level indices}
\usage{
v_degree(
  x,
  vids = NULL,
  mode = c("all", "out", "in"),
  loops = FALSE,
  rescaled = FALSE
)

v_eccentricity(x, vids = NULL, mode = c("all", "out", "in"), rescaled = FALSE)

v_betweenness(x, vids = NULL, directed = TRUE, rescaled = FALSE)

v_stress(x, vids = NULL, directed = TRUE, rescaled = FALSE)

v_eigenvector(x, directed = TRUE, rescaled = FALSE)

v_closeness(x, vids = NULL, mode = c("all", "out", "in"), rescaled = FALSE)

v_harmonic(x, vids = NULL, mode = c("all", "out", "in"), rescaled = FALSE)

v_pagerank(x, vids = NULL, damping = 0.85, directed = TRUE, rescaled = FALSE)

v_geokpath(
  x,
  vids = NULL,
  mode = c("all", "out", "in"),
  k = 3,
  rescaled = FALSE
)

v_shapley(x, add.vertex.names = FALSE, vids = NULL, rescaled = FALSE)
}
\arguments{
\item{x}{graph object}

\item{vids}{The vertices for the measure is to be calculated. By default, all 
vertices are included.}

\item{mode}{Character constant, gives whether the shortest paths to or from 
the given vertices should be calculated for directed graphs. 
If \code{out} then the shortest paths from the vertex, if \code{in} then to 
it will be considered. If \code{all}, the default, then the corresponding 
undirected graph will be used, edge directions will be ignored. 
This argument is ignored for undirected graphs.}

\item{loops}{Logical; whether the loop edges are also counted. 
This rarely makes sense. Default is \code{FALSE}.}

\item{rescaled}{if \code{TRUE}, the scores are rescaled so they sum to 1.}

\item{directed}{Logical, whether the graph should be considered directed (if 
it is directed to begin with)}

\item{damping}{The damping factor (‘d’ in the original paper).}

\item{k}{The k parameter. The default is 3.}

\item{add.vertex.names}{logical, should the output contain vertex names. 
This requires a vertex attribute \code{name} to be present in the graph. 
It is ignored if the attributed is missing.}
}
\description{
Vertex level indices
}
\details{
Calculate several vertex level indices.
}
\section{Functions}{
\itemize{
\item \code{v_degree()}: Degree of a vertex. Weights are discarded. 

Degree of a vertex is defined as the number of edges adjacent to it.

\item \code{v_eccentricity()}: Eccentricity of a vertex. Weights are discarded. 
The heavy lifting is done using \code{\link[igraph]{eccentricity}}.

The eccentricity of a vertex is its shortest path distance from the farthest 
other node in the graph. It is calculated by measuring the shortest distance 
from (or to) the vertex, to (or from) all vertices in the graph, and taking 
the maximum.

This implementation ignores vertex pairs that are in different components. 
Isolate vertices have eccentricity zero.

\item \code{v_betweenness()}: Betweenness of a vertex. Weights are discarded. The 
corresponding dedicated functions inside the \code{igraph} and \code{sna} 
have some additional functions (including diverging ways of taking weight 
into account). The settings of \code{v_betweenness} are what you want in 
most cases and works similarly for both \code{igraph} and \code{network} 
graph objects.

The betweenness of vertex \eqn{v} considers the number of shortest paths 
between all pairs of vertices (except paths to or from \eqn{v}. For each 
vertex pair, we calculate the proportion of shortest paths between vertices 
\eqn{i} and \eqn{j} that pass through \eqn{v}. The sum of these proportions 
is then equal to \eqn{v}'s betweenness. Mathematically, the betweenness of 
vertex \eqn{v} is given by 
\deqn{C_B(v) = \sum_{i,j : i \neq j, i \neq v, j \neq v} \frac{g_{ivj}}{g_{ij}}}
 where \eqn{g_{ijk}}{g_ijk} is the number of geodesics from \eqn{i} to \eqn{k} through \eqn{j}. 
 
In simple words, the betweenness of vertex \eqn{v} is the answer to: for each 
dyad that does not include \eqn{v}, add up the proportions of shortest paths 
that run through \eqn{v}.
 
Conceptually, high-betweenness vertices lie on a large proportion of shortest 
paths between other vertices; they can thus be thought of as ``bridges'' or 
``boundary spanners'' and have been argued to be in an informationally-favorable 
position having disproportionately fast access to information and rumors, 
under the assumption that these will be more likely to flow through the 
shortest paths in the graph (or flow randomly).

It is important to consider whether it is assumed that flow through the network 
occurs along the directions of the edges (\code{directed == TRUE}) or whether 
edge direction does not matter (\code{directed == FALSE})--the latter is 
always the case when the graph is undirected itself.

\item \code{v_stress()}: Stress centrality of a vertex. Weights are discarded. 

The stress centrality of vertex \eqn{v} is the number of shortest paths 
between all pairs of vertices (except paths to or from \eqn{v} that pass 
through \eqn{v}. Mathematically, the stress centrality of 
vertex \eqn{v} is given by 
\deqn{C_S(v) = \sum_{i,j : i \neq j, i \neq v, j \neq v} g_{ivj}}
 where \eqn{g_{ivk}} is the number of geodesics from \eqn{i} to \eqn{k} 
 through \eqn{v}. 
 
Conceptually, high-stress vertices lie on a large number of shortest 
paths between other vertices; they can thus be thought of as ``bridges'' or 
``boundary spanners'' and may experience high cognitive stress (in case of 
information networks) or physical stress (in case of physical flow networks).

It is important to consider whether it is assumed that flow through the network 
occurs along the directions of the edges (\code{directed == TRUE}) or whether 
edge direction does not matter (\code{directed == FALSE})--the latter is 
always the case when the graph is undirected itself.

\item \code{v_eigenvector()}: Eigenvector centrality of a vertex. Weights are discarded. 

Eigenvector centrality scores correspond to the values of the first eigenvector 
of the graph adjacency matrix; these scores may, in turn, be interpreted as 
arising from a reciprocal process in which the centrality of each actor is 
proportional to the sum of the centralities of those actors to whom he or she i
s connected. In general, vertices with high eigenvector centralities are 
those which are connected to many other vertices which are, in turn, connected 
to many others (and so on).

Eigenvector centrality is generalized by the Bonacich power centrality measure; 
see \code{\link[igraph]{power_centrality}} and \code{\link[igraph]{bonpow}}
for more details on this generalization.

\item \code{v_closeness()}: Closeness of a vertex. Weights are discarded. 

The closeness centrality of a vertex \eqn{v} is calculated as the inverse of 
the sum of distances to all the other vertices in the graph. In other words, 
for a vertex \eqn{v}, determine the lengths of the shortest paths from {v} 
to all other vertices (in caae of "out"), add those. This measures the 
"farness" of \eqn{v}. The closeness of \eqn{v} is the inverse of this sum.
The higher the number, the shorter the number of steps to reach all other 
vertices.

Closeness centrality is meaningful only for connected graphs. In disconnected 
graphs, consider using the harmonic centrality with v_harmonic.

This function's work is performed by \code{\link[igraph]{closeness}}. An 
alternative implementation is \code{\link[sna]{closeness}}. The latter yields 
values that are g-1 times larger (where g is the number of vertices) and takes 
some alternative decisions in special cases (e.g., for unconnected vertices).

\item \code{v_harmonic()}: Harmonic centrality of a vertex. Weights are discarded. 

The harmonic centrality of a vertex is the mean inverse distance to all other 
vertices. The inverse distance to an unreachable vertex is considered to be zero.

The measure is closely related to \code{closeness}. While closeness 
centrality is meaningful only for connected graphs, harmonic centrality can 
be calculated also for disconnected graphs and provides a useful alternative 
in those cases.

\item \code{v_pagerank()}: Google Pagerank centrality of a vertex. Weights are discarded. 

For the explanation of the PageRank algorithm, see the following webpage: 
\href{http://infolab.stanford.edu/~backrub/google.html}{The Anatomy of a Large-Scale Hypertextual Web Search Engine}, 
or the following reference: 

Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual Web 
Search Engine. Proceedings of the 7th World-Wide Web Conference, 
Brisbane, Australia, April 1998.

The PageRank of a given vertex depends on the PageRank of all other vertices, 
so even if you want to calculate the PageRank for only some of the vertices, 
all of them must be calculated first. Requesting the PageRank for only some 
of the vertices therefore does not result in any performance increase.

For all vertices together, page rank always adds up to 1, so \code{rescaled} 
does not have an effect. The \code{rescaled} argument is potentially useful 
if \code{vids} is specified to consider only the values of a selected set 
of vertices (whose pagerank then usually does not add up to 1).

\item \code{v_geokpath()}: Geodesic k-path centrality. Weights are discarded. 

Geodesic K-path centrality for vertex \eqn{v} counts the number of vertices 
that can be reached by vertex \eqn{v} through a geodesic path of length less than "k". 

If weights are potentially required, use our alternative implementation 
at \code{\link{v_geokpath_w}}.

When \code{vids} is specified, the measure is calculated on the induced 
subgraph consisting of only these vertices (and their corresponding) edges.

\item \code{v_shapley()}: Shapley Centrality

This function computes the centrality of vertices in a graph
based on their Shapley value, following the approach from the 
Michalak et al. (2013) paper.

}}
\examples{
g <- igraph::make_star(10, mode = "undirected")
v_eccentricity(g)
v_eccentricity(g, vids = c(1,3,5))
g_n <- snafun::to_network(g)
v_eccentricity(g_n)

i_bus <- florentine$flobusiness
v_eccentricity(i_bus, vids = c(1, 5, 9))
v_eccentricity(i_bus, vids = c("Medici", "Peruzzi"))
n_bus <- to_network(i_bus)
v_eccentricity(n_bus, vids = c(1, 5, 9))
v_eccentricity(n_bus, vids = c("Medici", "Peruzzi"))
# 
# v_degree
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
g2_i <- snafun::add_edge_attributes(g_i, attr_name = "weight", value = 1:12)
v_degree(g_i)
v_degree(g_i, rescaled = TRUE)
v_degree(g_i, mode = "in")
v_degree(g_i, mode = "in", rescaled = TRUE)
v_degree(g_i, mode = "out")
v_degree(g_i, mode = "out", rescaled = TRUE)
v_degree(g2_i)   # weight is ignored

g_n <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                   directed = TRUE, graph = "network")
g2_n <- snafun::add_edge_attributes(g_n, attr_name = "weight", value = 1:12)
v_degree(g_n)
v_degree(g_n, rescaled = TRUE)
v_degree(g_n, mode = "in")
v_degree(g_n, mode = "in", rescaled = TRUE)
v_degree(g_n, mode = "out")
v_degree(g_n, mode = "out", rescaled = TRUE)
v_degree(g2_n)   # weight is ignored
# 
# v_betweenness
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
g2_i <- snafun::add_edge_attributes(g_i, attr_name = "weight", value = 1:12)
v_betweenness(g_i)
v_betweenness(g_i, rescaled = TRUE)
v_betweenness(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)
v_betweenness(g2_i)   # attribute "weight" is not used

g_n <- snafun::to_network(g_i)
v_betweenness(g_n)
v_betweenness(g_n, rescaled = TRUE)
v_betweenness(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)

# star network
g <- igraph::make_star(10, "in")
plot(g)
v_betweenness(g) # there are no shortest paths with length >= 3
v_betweenness(g, directed = FALSE) # all 36 shortest paths that do not include "1" go through "1"
# 
# v_stress
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
v_stress(g_i)
v_stress(g_i, rescaled = TRUE)
v_stress(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)

g_n <- snafun::to_network(g_i)
v_stress(g_n)
v_stress(g_n, rescaled = TRUE)
v_stress(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)

# star network
g <- igraph::make_star(10, "in")
plot(g)
v_stress(g) # there are no shortest paths with length >= 3
v_stress(g, directed = FALSE) # all 36 shortest paths that do not include "1" go through "1"
# 
# v_eigenvector
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
v_eigenvector(g_i)
v_eigenvector(g_i, rescaled = TRUE)
v_eigenvector(g_i, directed = FALSE)

g_n <- snafun::to_network(g_i)
v_eigenvector(g_n)
v_eigenvector(g_n, rescaled = TRUE)
v_eigenvector(g_n, directed = FALSE)

# star network
g <- igraph::make_star(10, "in")
\dontrun{
v_eigenvector(g) # all 0 + a warning is issued
}
v_eigenvector(g, directed = FALSE) 
# 
# v_closeness
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
g2_i <- snafun::add_edge_attributes(g_i, attr_name = "weight", value = 1:12)
v_closeness(g_i)
1/rowSums(igraph::distances(g_i))  # same thing
v_closeness(g_i, rescaled = TRUE)
v_closeness(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)
v_closeness(g2_i)   # attribute "weight" is not used

g_n <- snafun::to_network(g_i)
v_closeness(g_n)
v_closeness(g_n, rescaled = TRUE)
v_closeness(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)

# star network
g <- igraph::make_star(10, "in")
v_closeness(g)  # "1" has the highest closeness, the rest has the same value
v_closeness(g, mode= "in")  # only "1"
v_closeness(g, mode= "out") # all except "1"
# 
# v_harmonic
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
v_harmonic(g_i)
v_closeness(g_i)   # harmonic works for disconnected graphs, closeness does not
cor(v_harmonic(g_i), v_closeness(g_i), use = "complete.obs") # usually very high
v_harmonic(g_i, rescaled = TRUE)
v_harmonic(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)

g_n <- snafun::to_network(g_i)
v_harmonic(g_n)
v_harmonic(g_n, rescaled = TRUE)
v_harmonic(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)

# star network
g <- igraph::make_star(10, "in")
v_harmonic(g)  # "1" has the highest harmonic, the rest has the same value
v_harmonic(g, mode= "in")  # only "1"
v_harmonic(g, mode= "out") # all except "1"
# 
# v_pagerank
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
v_pagerank(g_i)
v_pagerank(g_i, rescaled = TRUE)
v_pagerank(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)
v_pagerank(g_i, damping = 0)
v_pagerank(g_i, damping = .99)  # using 1 exactly may not be entirely stable



g_n <- snafun::to_network(g_i)
v_pagerank(g_n)
v_pagerank(g_n, rescaled = TRUE)
v_pagerank(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)

# star network
g <- igraph::make_star(10, "in")
v_pagerank(g)  # "1" has the highest pagerank, the rest has the same value
# 
# v_geokpath
g_i <- snafun::create_random_graph(10, strategy = "gnm", m = 12, 
                                  directed = TRUE, graph = "igraph")
g2_i <- snafun::add_edge_attributes(g_i, attr_name = "weight", value = 1:12)
v_geokpath(g_i)
v_geokpath(g_i, rescaled = TRUE)
v_geokpath(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE)
v_geokpath(g_i, k = 2)
v_geokpath(g_i, k = 1)
v_degree(g_i) # same

g_n <- snafun::to_network(g_i)
v_geokpath(g_n)
v_geokpath(g_n, rescaled = TRUE)
v_geokpath(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE)
#
# Shapley centrality
# Figure 1 network from Michalak et al.
g1 <- igraph::graph(c(4,1,5,1,1,6,1,7,1,8,8,11,11,12,11,13,6,2,7,2,8,2,
2,9,2,10,9,3,10,3), directed = FALSE)
igraph::V(g1)$name <- LETTERS[1:13]
v_shapley(g1)
v_shapley(g1, add.vertex.names = TRUE)
}
\references{
Michalak, T.P., Aadithya, K.V., Szczepanski, P.L., Ravindran, B. and 
Jennings, N.R., 2013. Efficient computation of the Shapley value for 
game-theoretic network centrality. Journal of Artificial Intelligence 
Research, 46, pp.607-650.

The code for the Shapley centrality is adapted from \code{CINNA::group_centrality} 
and gives the same result (but our version is slightly more robust).
}
\seealso{
For \code{igraph} objects: \code{\link[igraph]{eccentricity}}, 
\code{\link[igraph]{degree}}, \code{\link[igraph]{betweenness}}, 
\code{\link[igraph]{eigen_centrality}}.

For \code{network} objects: \code{\link[sna]{degree}}, .
\code{\link[sna]{betweenness}}, \code{\link[sna]{stresscent}}, 
\code{\link[sna]{evcent}}.
}
