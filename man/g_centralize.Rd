% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/g_centralize.R
\name{g_centralize}
\alias{g_centralize}
\title{Centralization}
\usage{
g_centralize(
  x,
  measure = "betweenness",
  directed = TRUE,
  mode = c("all", "out", "in"),
  k = 3,
  damping = 0.85,
  normalized = TRUE,
  method = c("freeman", "sd")
)
}
\arguments{
\item{x}{graph}

\item{measure}{character, name of which centrality index needs to be used}

\item{directed}{logical, should the graph be considered to be directed (if it 
is undirected, this is ignored)}

\item{mode}{parameter for several centrality indices}

\item{k}{parameter for \link{v_geokpath}}

\item{damping}{parameter for \link{v_pagerank}}

\item{normalized}{Logical scalar. Whether to normalize the graph level centrality 
score by dividing by the theoretical maximum. Only used when \code{method == "freeman"}.}

\item{method}{character, either "freeman" (the default) or "sd"}
}
\value{
for \code{method == "freeman"} a list, for \code{method == "sd"} a numeric. 
See Details for further info.
}
\description{
Centralization around several vertex measures
}
\details{
Centralization is a method for creating a graph level centralization
measure from the centrality scores of the vertices.

Centralization is a general method for calculating a graph-level
centrality score based on vertex-level centrality measure. 

There are many ways of aggregating vertex-level centrality scores to
graph-level centralization. A very common method is the Freeman method. 

The formula for this is
\deqn{C(G)=\sum_v (\max_w c_w - c_v)}
where \eqn{c_v} is the centrality of vertex \eqn{v}.

This is the summed absolute deviation from the maximum of C on G. 
Generally, this value is normalized by the theoretical maximum centralization 
score, conditional on the graph and the values of the arguments (such as 
the choice for \code{mode} and \code{directed}).

The Freeman method is implemented in \code{method == "freeman"}. This is 
the default. When this 
method is chosen, the function returns a list with the following components:
\describe{
  \item{centralization}{The graph level centrality index.}
  \item{theoretical_max}{The maximum theoretical graph level
    centralization score for a graph with the given number of vertices,
    using the same parameters. If the \code{normalized} argument was
    \code{TRUE}, then the result was divided by this number.}
}

For calculating Freeman centralization with the native packages, see 
\code{\link[igraph]{centralize}} (for \code{igraph} objects) or 
\code{\link[sna]{centralization}} (for \code{network} objects).

The "freeman" "method is implemented for "betweenness", "closeness", "degree", 
and "eigenvector".#' 

An alternative way of calculating centralization is by taking the standard 
deviation of the vertex-level scores. This method is implemented in 
\code{method == "sd"}.

When this method is chosen, the function returns the value of the standard 
deviation.

The "sd" method has been implemented for the centrality indices 
"betweenness", "closeness", "degree", "eccentricity", 
"eigenvector", "geokpath", "harmonic", "pagerank", 
"shapley", and "stress".
}
\examples{
# A BA graph is quite centralized
g <- igraph::sample_pa(1000, m = 4)
g_centralize(g, "degree", method = "freeman")
g_centralize(snafun::to_network(g), "degree", method = "freeman")
g_centralize(g, "betweenness", method = "freeman")
g_centralize(g, "betweenness", method = "freeman", directed = FALSE)
g_centralize(g, "betweenness", method = "freeman")
g_centralize(g, "closeness", method = "freeman")
g_centralize(g, "closeness", method = "freeman", mode = "out") # can be NaN
# eigenvector does not work for this directed graph, so make it undirected
g_centralize(g, "eigenvector", method = "freeman", directed = FALSE) 

# The most centralized graph according to eigenvector centrality
g0 <- igraph::make_graph(c(2,1), n = 10, dir = FALSE)
g1 <- igraph::make_star(10, mode = "undirected")
g_centralize(g0, "eigenvector", method = "freeman")$centralization
g_centralize(g1, "eigenvector", method = "freeman")$centralization

# method sd
g_centralize(g, "degree", method = "sd")
g_centralize(g, "degree", method = "sd", mode = "out")
g_centralize(g, "betweenness", method = "sd")
g_centralize(g, "betweenness", method = "sd", directed = FALSE)
g_centralize(g, "betweenness", method = "sd")
g_centralize(g, "closeness", method = "sd")
g_centralize(g, "closeness", method = "sd", mode = "out") 
g_centralize(g, "eccentricity", method = "sd")
g_centralize(g, "eigenvector", directed = FALSE, method = "sd")
g_centralize(g, "geokpath", method = "sd", k = 4)
g_centralize(g, "geokpath", method = "sd", k = 2)
g_centralize(g, "harmonic", method = "sd")
g_centralize(g, "pagerank", method = "sd", damping = .9)
g_centralize(g, "pagerank", method = "sd", damping = .5)
g_centralize(g, "shapley", method = "sd")
g_centralize(g, "stress", method = "sd")
}
