% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat_nam.R
\name{stat_nam}
\alias{stat_nam}
\title{Network autocorrelation model}
\usage{
stat_nam(
  formula,
  data = list(),
  W,
  W2 = NULL,
  model = c("lag", "error", "combined"),
  na.action,
  Durbin = FALSE,
  quiet = TRUE,
  zero.policy = TRUE,
  check_vars = TRUE
)
}
\arguments{
\item{formula}{a symbolic description of the model to be fit.}

\item{data}{an optional data frame containing the variables in the model. 
By default the variables are taken from the environment which the function is called.}

\item{W}{Spatial weight matrix for the lagged model or the error model. 
This can be a matrix or a graph of class \code{network} or \code{igraph}.}

\item{W2}{Spatial weight matrix for the error, in case of a combined model 
(otherwise, it is discarded). This can be a matrix or a graph of 
class \code{network} or \code{igraph}}

\item{model}{character, either \code{lag}, \code{error}, or \code{combined}}

\item{na.action}{a function (default \code{options("na.action")}), 
can also be \code{na.omit} or \code{na.exclude} with consequences for residuals 
and fitted values - in these cases the weights list will be subsetted to remove 
\code{NAs} in the data. It may be necessary to set \code{zero.policy} to 
\code{TRUE} because this subsetting may create no-neighbour observations.}

\item{Durbin}{default \code{FALSE} (spatial lag model); 
if \code{TRUE}, full spatial Durbin model; if a formula object, 
the subset of explanatory variables to lag}

\item{quiet}{default \code{NULL}, use !verbose global option value; 
if \code{FALSE}, reports function values during optimization.}

\item{zero.policy}{if {TRUE}, the default, assign zero to the lagged value of 
vertices without neighbours, if \code{FALSE} assign \code{NA} - causing 
\code{spatialreg::lagsarlm()} to terminate with an error}

\item{check_vars}{if \code{TRUE}, the default, a check is performed as to 
whether all variables on the right hand side of the formula are non-constant.
Note that the function will add an intercept by default, so constants are 
not wanted or needed on the rhs of the formula.}
}
\value{
an object of class \code{Sarlm}
}
\description{
Run the network autocorrelation model
}
\details{
This function can run the lagged network autocorrelation model, the 
error/disturbances model, and the combined model.


In particular, \code{model = "lag"} provides Maximum likelihood estimation 
of spatial simultaneous autoregressive lag models of the form:

\deqn{y = \rho W y + X \beta + \varepsilon}{y = rho W y + X beta + e}

where \eqn{\rho}{rho} is found by \code{optimize()} first, and \eqn{\beta}{beta} 
and other parameters by generalized least squares subsequently 
(one-dimensional search using optim performs badly on some platforms). 
With one of the sparse matrix methods, larger numbers of observations can be 
handled.

When \code{model = "error"}, the Maximum likelihood estimation is performed 
of spatial simultaneous autoregressive error models of the form:

\deqn{y = X \beta + u, u = \lambda W u + \varepsilon}{y = X beta + u, u = lambda W u + e}

where \eqn{\lambda}{lambda} is found by \code{optimize()} first, and 
\eqn{\beta}{beta} and other parameters by generalized least squares subsequently. 
With one of the sparse matrix methods, larger numbers of observations can be 
handled.

When \code{model = "combined"}, Maximum likelihood estimation is performed of 
spatial simultaneous autoregressive \dQuote{SAC/SARAR} models of the form:

\deqn{y = \rho W1 y + X \beta + u, u = \lambda W2 u + \varepsilon}{y = rho W1 y + X beta + u, u = lambda W2 u + e}

where \eqn{\rho}{rho} and \eqn{\lambda}{lambda} are found by \code{nlminb} 
or \code{optim()} first, and \eqn{\beta}{beta} and other parameters by generalized 
least squares subsequently.

The actual fitting of the model is performed through the \code{\link[spatialreg]{lagsarlm}}, 
\code{\link[spatialreg]{errorsarlm}}, \code{\link[spatialreg]{sacsarlm}} functions and the 
handling of the weight matrix through the \code{\link[spdep]{mat2listw}} function.
This function wraps these functions and sets some defaults that may be 
useful to network analysis, but not necessarily always ideal for spatial 
analysis. Also, the functions in the \pkg{spatialreg} package are more 
flexible than was it exposed through this wrapper. So, for fitting a full 
model, refer to these functions directly. 
Do note, though, that those functions handle the weight matrix in a way that 
is uncommon to the network analyst, and this wrapper function makes accessing 
these models a lot more straightforward.
Also note that the original functions do not allow graphs of class 
\code{network} or \code{igraph} to be utilized as weight matrices, which is 
another benefit is our function which does make this possible.

A useful \code{summary} function is implemented within the \pkg{spatialreg} package.
}
\examples{
# Simulate data for the lagged model
aantal_vars <- 10
nobs <- 50
rho = .3
coefs <- rnorm(aantal_vars)
x <- rnorm(nobs*aantal_vars, sd = 8)
x <- matrix(x, ncol = aantal_vars)
colnames(x) <- LETTERS[1:ncol(x)]
w <- sample(c(0, 1), nobs*nobs, replace = TRUE, prob = c(.8, .2))
w <- matrix(w, ncol = nobs)
diag(w) <- 0
w <- w/rowSums(w)    # redundant
eps <- rnorm(nobs, sd = 5)
ie <- matrix(0, ncol = nobs, nrow = nobs)
diag(ie) <- 1
y <- solve(ie - rho*w) \%*\% (x \%*\% coefs + eps)
ix <- data.frame(y, x)
mod <- stat_nam(y ~ ., data = ix, W = w)
stat_nam_summary(mod)
stat_nam_summary(mod, correlation = TRUE)
plot_nam(mod)

#### Now a full combined model
#Draw the AR matrix
w1 <- snafun::create_random_graph(100, strategy = "gnp", p = .2)
#Draw the MA matrix
w2 <- snafun::create_random_graph(100, strategy = "gnp", p = .2)
x <- matrix(rnorm(100*5),100,5) #Draw some covariates
r1 <- 0.2                       #Set the model parameters
r2 <- 0.1
sigma <- 0.1
beta <- rnorm(6)
#Assemble y from its components:
nu <- rnorm(100, 0, sigma)          #Draw the disturbances
# only for the simulation, row-standardized weights are needed
ww1 <- snafun::to_matrix(w1)
ww1 <- ww1/rowSums(ww1)
ww2 <- snafun::to_matrix(w2)
ww2 <- ww2/rowSums(ww2)
xx <- cbind(1, x)
e <- qr.solve(diag(100) - r2 * ww2, nu) #Draw the effective errors
y <- qr.solve(diag(100) - r1 * ww1, xx \%*\% beta + e)  #Compute y
ix <- data.frame(y, x)
mod <- stat_nam(y ~ ., data = ix, W = w1, W2 = w2, model = "combined")
stat_nam_summary(mod)
stat_nam_summary(mod, correlation = TRUE)
plot_nam(mod)

# fit the disturbances model
mod <- stat_nam(y ~ ., data = ix, W = w2, model = "error")
stat_nam_summary(mod)
stat_nam_summary(mod, correlation = TRUE)
plot_nam(mod)

\dontrun{
# Model from Doreian (1980)
data(huk, package = "SNA4DSData")
x <- as.matrix(cbind(Intcpt = 1, hukYX[, -1]))
lnam1 <- sna::lnam(y = hukYX$y, x = x, W1 = hukW)
lnam2 <- sna::lnam(y = hukYX$y, x = x, W2 = hukW)
lnam3 <- sna::lnam(y = hukYX$y, x = x, W = hukW, W2 = hukW)

# For comparison, the models with a row standardized W 
lnam1 <- sna::lnam(y = hukYX$y, x = x, W1 = hukWstd)
lnam2 <- sna::lnam(y = hukYX$y, x = x, W2 = hukWstd)
lnam3 <- sna::lnam(y = hukYX$y, x = x, W = hukWstd, W2 = hukWstd)

# Same model with our function
nam1 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, model = "lag")
nam2 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, model = "error")
nam3 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, W2 = hukWstd, model = "combined")
}
}
