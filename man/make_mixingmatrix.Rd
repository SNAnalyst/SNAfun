% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_mixingmatrix.R
\name{make_mixingmatrix}
\alias{make_mixingmatrix}
\title{Construct a mixing matrix}
\usage{
make_mixingmatrix(x, attrname, by_edge = FALSE, loops = has_loops(x))
}
\arguments{
\item{x}{graph of class \code{network} or \code{igraph}}

\item{attrname}{character, name of the attribute name}

\item{by_edge}{logical, if \code{TRUE} a full mixing matrix is calculated}

\item{loops}{logical, are loops allowed? By default, this is \code{TRUE} if 
the graph itself already has at least one loop.}
}
\value{
a table (if \code{by_edge} is \code{FALSE}) or a list with two 
tables (if \code{by_edge} is \code{TRUE})
}
\description{
Construct a mixing matrix for a graph, based on a specific vertex attribute
}
\details{
A network mixing matrix is, traditionally, a two-dimensional cross-classification 
of edges by the values of a specific vertex attribute. This is an important 
tool for assessing network homophily or seggregation and often very useful 
for the subsequent construction of explanatory statistical models of the network. 

Each cell (*i*, *j*) in the mixing matrix reports the number of edges in the 
graph where the sender has value *i* on the vertex attribute and the receiver 
has value *j* on that vertex attribute. In case of an undirected graph, 
each edge counts twice, when *j* != *j*, since an undirected edge from MALE to 
FEMALE means that there is also an undirected edge from FEMALE to MALE.

If the argument \code{by_edge} is set to \code{TRUE}, a list of two mixing 
matrices is returned: the first contains the traditional mixing matrix and the 
second contains the mixing matrix of edges that do *no* occur in the graph.
The two matrices are appropriately called "edge_present" and "no_edge_present".

The mixing matrix includes row and column margins. Note that this can be somewhat 
misleading when a mixing matrix is constructed for an undirected graph, as 
the off-diagonal entries of the mixing matrix will occur twice. Therefore, the 
overall sum of edges corrects for this and will hence not equal the grand 
total one would expect by somply adding up the row margins or the column 
margins. In fact, in case of an undirected graph,. the correct grand total 
should be equal to the sum of the elements in the upper (or lower) triangle + 
the summed diagonal.

The argument \code{loops} can be set to \code{TRUE} if edges from a vertex 
to itself should be included. The default is to only include loops if the 
graph already includes loops itself. Otherwise, it generally makes little sense. 

The \code{network} package has a \code{\link[network]{mixingmatrix}} 
function that works only on \code{network} 
objects, but has specific functionality for bipartite networks.
}
\examples{
data(emon, package = "network")
is_directed(emon$LakePomona)   # TRUE
network::mixingmatrix(emon$LakePomona, "Sponsorship")
g <- emon$LakePomona
make_mixingmatrix(g, attrname = "Sponsorship")
make_mixingmatrix(g, attrname = "Sponsorship", by_edge = TRUE)
g <- snafun::to_igraph(emon$LakePomona)
make_mixingmatrix(g, attrname = "Sponsorship")
make_mixingmatrix(g, attrname = "Sponsorship", by_edge = TRUE)

data("judge_net", package = "snafun")
is_directed(judge_net)   # FALSE
make_mixingmatrix(judge_net, attrname = "color")
make_mixingmatrix(judge_net, attrname = "JudgeSex")
g <- suppressWarnings(snafun::to_network(judge_net))
make_mixingmatrix(g, attrname = "color")
make_mixingmatrix(g, attrname = "JudgeSex")
make_mixingmatrix(judge_net, attrname = "color", by_edge = TRUE)
make_mixingmatrix(judge_net, attrname = "JudgeSex", by_edge = TRUE)
}
