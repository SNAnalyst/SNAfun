% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/v_bottleneck.R
\name{v_bottleneck}
\alias{v_bottleneck}
\title{Find the Bottleneck centrality score}
\usage{
v_bottleneck(
  graph,
  mode = c("all", "out", "in"),
  vids = igraph::V(graph),
  n = 4
)
}
\arguments{
\item{graph}{The input graph as igraph object, a network object, or a, 
adjacency matrix}

\item{mode}{Character constant, gives whether the shortest paths to or from 
the given vertices should be calculated for directed graphs. 
If \code{out} then the shortest paths from the vertex, if \code{in} then to 
it will be considered. If \code{all}, the default, then the corresponding 
undirected graph will be used. This argument is ignored for undirected graphs.}

\item{vids}{Numeric vertex sequence, the vertices that should be considered.
Default is all vertices. Otherwise, the operation is performed on the 
subgraph only containing vertices \code{vids}.}

\item{n}{scalar, defaults to 4.}
}
\value{
A data.frame with vertex names (if they exist) and bottleneck 
centrality scores. 
Otherwise, a numeric vector contaning the centrality scores for the 
selected vertices.
}
\description{
How often is a vertex a bottleneck for other vertices in the graph?
}
\details{
Consider the geodesics from \eqn{i} to all other vertices. 
If node \eqn{v} is part of at least 1/n-th of these geodesics, \eqn{v} is said 
to be a bottleneck for \eqn{i}.
By default, \code{n == 4}, so \eqn{v} is a bottleneck for \eqn{i}
if \eqn{v} is part of least one quarter of all of the geodesics from \eqn{i}.

The bottleneck centrality of \eqn{v} is the number of vertices that \eqn{v}
is a bottleneck for. 

The score runs from 0 (ie. the vertex is a bottleneck for no other vertex)
to \eqn{g - 1}, with \code{g} being the number of vertices in \code{graph.}

The calculation does not use edge weights, even if the graph is weighted 
(but the implementation could easily be altered to include weight as well).

Especially when densely connected subgroups exist, 
multiple shortest paths are possible between two vertices. 
If a vertex appear on at least one of them, that path counts as part of the 
calculation. 
This implies that being a _bottleneck_ does not take into account 
whether there are alternative geodesics between the two vertices; 
in other words, it does not matter whether the geodesic that \eqn{v} is 
part of is redundant or not and alternative geodesics exist between the 
pair of vertices that \eqn{v} is not part of and have the same length as 
the geodesic(s) that \eqn{v} is on. 
Hence, removal of the bottleneck node from the graph may not affect the 
efficiency of the graph in these cases.

Note that geodesics that end at \eqn{v} also count in the calculation. 
So, when there are multiple geodesics from \eqn{i} to \eqn{v}, 
it is likely that \eqn{v} will count as a bottleneck for \eqn{i}, 
although this may not be realistic. 
An alteration of this measure to discard geodesics to \eqn{v} might be advisable.

Also note that the implementation of this measure in the \code{centiserve} package 
is incorrect, so use our function and not theirs.

Also note that geodesics that end at \eqn{v} also count in the calculation. 
So, when there are multiple geodesics from \eqn{i} to \eqn{v}, 
it is likely that \eqn{v} will count as a bottleneck for \eqn{i}, 
although this may not be realistic. 
An alteration of this measure to discard geodesics to \eqn{v} might be advisable.
}
\examples{
g <- igraph::graph(c(1,2,2,3,3,4,4,2))
v_bottleneck(g)
v_bottleneck(g, vids = c(1, 2, 4))
v_bottleneck(g, mode = "out")
v_bottleneck(g, mode = "in")

g <- igraph::make_star(10, mode = "undirected")
v_bottleneck(g) 
g <- igraph::make_ring(10)
v_bottleneck(g) # all 0
v_bottleneck(g, n = Inf) # all 9
}
\references{
Przulj, N., Dennis A. Wigle, and Igor Jurisica. 
"Functional topology in a network of protein interactions." 
Bioinformatics 20.3 (2004): 340-348.
}
