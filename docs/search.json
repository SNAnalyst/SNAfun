[{"path":"https://snanalyst.github.io/SNAfun/articles/Converting-between-graph-classes.html","id":"converting-between-graph-classes","dir":"Articles","previous_headings":"","what":"Converting between graph classes","title":"Converting between graph classes","text":"mentioned , common network analysis workflow includes conversion graph objects various formats. igraph statnet packages provide basic functions , specific types objects used packages : Conversion various formats lot easier help snafun package. need know easy function names convert common graph classes. overview function use conversion: Check arguments various options.","code":"igraph::as_adjacency_matrix(g, sparse = FALSE) network::as.sociomatrix(g) network::as.matrix.network(g) igraph::as_adj_list(g) igraph::as_edgelist(g) igraph::as_data_frame(g) network::as.data.frame.network(g) network::as.edgelist(g)  # if you want to include edge weights sna::as.edgelist.sna(g) igraph::as.directed(g) # from an adjacency matrix as input snafun::to_symmetric_matrix(g,   rule = c(\"weak\", \"mutual\", \"out\", \"in\", \"average\", \"max\", \"min\"),   na.rm = TRUE) igraph::as.undirected(g)  # for example igraph::as.undirected(g, mode = 'collapse', edge.attrib.comb = list(weight = 'sum')) # from an adjacency matrix as input sna::symmetrize(g)  # for example sna::symmetrize(g, rule = \"strong\") igraph::bipartite_projection(g) igraph::make_line_graph(g)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Creating-a-graph-object.html","id":"generate","dir":"Articles","previous_headings":"","what":"Creating a graph object","title":"Creating a graph object","text":"create graph objects class igraph network.","code":"snafun::create_empty_graph(n_vertices, directed = TRUE, graph = c(\"igraph\", \"network\")) igraph::make_empty_graph() network::network::initialize() snafun::create_manual_graph(A -+ B -+ C, simplify = TRUE, graph = 'igraph') igraph::graph_from_literal(A -+ B -+ C, simplify = TRUE) igraph::make_ring() igraph::make_star() snafun::create_random_graph(     n_vertices = 10,     strategy = \"gnm\",   # to fix the number of edges     m = 27,             # number of edges required, resulting density = .3     directed = TRUE,    # or FALSE     graph = c(\"igraph\", \"network\"))   # pick one  snafun::create_random_graph(     n_vertices = 10,     strategy = \"gnp\",   # to fix the probability edges     p = .3,             # probability for each edge, yields approx. density of .3     directed = TRUE,    # or FALSE     graph = c(\"igraph\", \"network\")) igraph::sample_gnm() igraph::sample_gnp()  igraph::make_directed_graph(n = 10, edges = 27) igraph::make_undirected_graph(n = 10, edges = 27) # 10 vertices, density on average .3 sna::rgraph(n = 10, m = 1, tprob = 0.30, mode = 'digraph')  # 10 vertices, 27 edges (ie. density = .3) sna::rgnm(1, 10, m = 27) create_census_graph(n_vertices = 10, mut = 8, asym = 25, null = 12,                                     method = 'exact',                                    graph = 'igraph') # 5 networks, each with 10 vertices, and 8 M, 25 A, and 12 N dyads sna::rguman(n = 5, nv = 10, mut = 8, asym = 25, null = 12,    method = \"exact\") snafun::create_community_graph(   communitySizes = c(10, 20, 30),   p_intra = c(0.3, 0.2, 0.3),   p_inter = 0.2,   p_del = 0,   graph = 'igraph') create_components_graph(   n_vertices,   directed = FALSE,   membership = NULL,   graph = 'igraph') snafun::create_bipartite(   n_type1,                        # number of vertices of type 1   n_type2,                        # number of vertices of type 2   strategy = c(\"gnp\", \"gnm\"),   p,                              # probability of each cross-type edge   m,                              # number of cross-type edges   directed = FALSE,   mode = c(\"out\", \"in\", \"all\"),   graph = c(\"igraph\", \"network\") ) igraph::sample_bipartite() network::network.bipartite() #  `x` can be:  #   - an edgelist (in data.frame format) #   - an incidence matrix (in matrix format)--for a bipartite graph #   - an adjacency matrix (in matrix format) #   - `vertices`  can be a data.frame containing vertex attributes  snafun::to_igraph(x, bipartite = FALSE, vertices = NULL)  snafun::to_network(x, bipartite = FALSE, vertices = NULL) # from an adjacency matrix igraph::graph_from_adjacency_matrix(adjmatrix,    mode = c(\"directed\", \"undirected\", \"max\", \"min\", \"upper\", \"lower\", \"plus\"),   weighted = NULL, diag = TRUE, add.colnames = NULL, add.rownames = NA)  igraph::make_graph(edges, ..., n = max(edges), isolates = NULL, directed = TRUE,    dir = directed, simplify = TRUE)  # from an adjacency list igraph::graph_from_adj_list(adjlist, mode = c(\"out\", \"in\", \"all\", \"total\"),    duplicate = TRUE)  # from an edgelist igraph::graph_from_edgelist(el, directed = TRUE)  # from a data.frame igraph::graph_from_data_frame(d, directed = TRUE, vertices = NULL)  # from an incidence matrix (in matrix format) igraph::graph_from_incidence_matrix(incidence, directed = FALSE,    mode = c(\"all\", \"out\", \"in\", \"total\"), multiple = FALSE,   weighted = NULL, add.names = NULL) # x can be an adjacency matrix (as a matrix), an incidence matrix (as a matrix),  # or an edgelist (as a data.frame) network::network(x, vertex.attr = NULL, vertex.attrnames = NULL, directed = TRUE,   hyper = FALSE, loops = FALSE, multiple = FALSE, bipartite = FALSE, ...)  # if x is a data.frame network::as.network(x, directed = TRUE, vertices = NULL, hyper = FALSE,    loops = FALSE, multiple = FALSE, bipartite = FALSE,    bipartite_col = \"is_actor\", ...)  # if x is a matrix network::as.network(x, matrix.type = NULL, directed = TRUE, hyper = FALSE,    loops = FALSE, multiple = FALSE, bipartite = FALSE, ignore.eval = TRUE,   names.eval = NULL, na.rm = FALSE, edge.check = FALSE, ...)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Creating-a-graph-object.html","id":"additional-graph-creation-functions","dir":"Articles","previous_headings":"Creating a graph object","what":"Additional graph creation functions","title":"Creating a graph object","text":"snafun package offers functions assist manipulation graph data R. snafun::make_edgelist(names = NULL, attribute = NULL) input data.frame (names) edge information. attribute vector contains node attribute vertices. function returns vector data.frame can read igraph network. snafun::make_nodelist(names = NULL, attribute = NULL) input data.frame (names) edge information. attribute another data.frame contains values edges. function returns edgelist can read igraph network.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Dyad-level-indices.html","id":"dyad-level-indices","dir":"Articles","previous_headings":"","what":"Dyad-level indices","title":"Dyad-level indices","text":"functions several dyad-level indices want use course.","code":"igraph::all_shortest_paths(g, from = IDofVertex, to = igraph::V(g), mode = 'out') snafun::d_distance(x, mode = c(\"all\", \"out\", \"in\")) igraph::distances(g, mode = 'out') sna::geodist(g, count.paths = TRUE)$counts snafun::d_structural_equivalence(x, weights = NA, digits = 3, suppressWarnings = TRUE) sna::sedist(g, method = \"correlation\", mode =\"digraph\", diag=FALSE) igraph::edge.betweenness(g, directed = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGM-for-temporal-networks.html","id":"ergm-for-temporal-networks","dir":"Articles","previous_headings":"","what":"ERGM for temporal networks","title":"ERGM for temporal networks","text":"TERGM (=Temporal ERGM) can used model sequence binary networks. model similar ERGM, dependent variable now list networks: first element network time 1, second element network time 2, et cetera.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGM-for-temporal-networks.html","id":"how-to-store-the-data-for-a-tergm","dir":"Articles","previous_headings":"ERGM for temporal networks","what":"How to store the data for a TERGM","title":"ERGM for temporal networks","text":"store data needed fitting TERGM follows.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGM-for-temporal-networks.html","id":"how-to-fit-a-tergm","dir":"Articles","previous_headings":"ERGM for temporal networks","what":"How to fit a TERGM","title":"ERGM for temporal networks","text":"fit TERGM btergm package (installed CRAN). fits model MPLE, using bootstrapping derive standard errors. btergm package compatible ergm package can use terms package inside btergm. three groups temporal measures can specify: memory, delayed reciprocity, time covariates.  Visually:  timecov specified without including value transform, specification defaults linear trend time. example: timecov() (= effect time per se) timecov(militaryDisputes) (= linearly increasing decreasing effect militaryDisputes time).","code":"btergm::memory(type = \"autoregression\", lag = 1) btergm::memory(type = \"stability\", lag = 1) btergm::memory(type = \"innovation\", lag = 1) btergm::memory(type = \"loss\", lag = 1) btergm::delrecip(mutuality = FALSE, lag = 1) btergm::delrecip(mutuality = TRUE, lag = 1) btergm::timecov(transform = function(t) t) btergm::timecov(x, transform = function(t) t)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGM-for-temporal-networks.html","id":"parallel-processing","dir":"Articles","previous_headings":"ERGM for temporal networks","what":"Parallel processing","title":"ERGM for temporal networks","text":"btergm package uses MPLE lends well parallel processing. specificy want use parallel processing using argument parallel. Windows users can use parallel = \"snow\". systems can use either parallel = \"snow\" parallel = \"multicore\". latter probably often better choice non-Windows machines. options require parallel package installed. use parallel option, also specify appropriate number cores want use. Either set ncpus = 4 (four cores) use ncpus = parallel::detectCores() R recognize number cores automatically (usually works well, always). ncpus argument ignored specify parallel argument. default parallel processing.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGM-for-temporal-networks.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"ERGM for temporal networks","what":"Goodness-of-fit","title":"ERGM for temporal networks","text":"Goodness fit determined gof_m <- btergm:::gof.btergm(m, statistics = btergm_statistics), m fitted btergm model btergm_statistics vector statistics included GoF. default c(btergm::dsp,btergm::esp,btergm::deg,btergm::ideg,btergm::geodesic,btergm::rocpr,btergm::walktrap.modularity). course, statistics include (complex statistics), time take GoF calculations finish. Use ?btergm:::`gof,btergm-method` options. GoF object can plotted using btergm:::plot.gof(gof_m) , often usefully, snafun::stat_plot_gof(gof_m). convenient use helper function snafun package. : gof_m <- snafun::stat_plot_gof_as_btergm(m) default, includes statistics c(btergm::esp, btergm::geodesic, btergm::deg, btergm::rocpr) goodness--fit, can specify statistics prefer. function returns goodness--fit (case, gof_m object) plots well. prevents use triple colon ::: btergm:::gof.btergm generally convenient. need full flexibility btergm:::gof.btergm function, use directly. results two functions identical. include btergm::rocpr “statistic” GoF, red line Receiver Operating Characteristic (ROC) curve blue line Precision-Recall curve. see value ROC PR, can find arreas curves using gof_m$`Tie prediction`$auc.roc gof_m$`Tie prediction`$auc.pr. Note Precision-Recall appropriate sparse networks, ROC works better connected networks. Either way, plots network statistics generally much informative compared ROC PR (ROC PR don’t take dependency structure data account). plots, grey boxplots represent distribution values observed networks, thick black line median simulations dashed line mean simulations. can manipulate shown using: snafun::stat_plot_gof(gof_m, median_include = FALSE, mean_col = \"red\") Note: can also feed fitted ERGM model snafun::snafun::stat_plot_gof_as_btergm(m) determine goodness--fit fitted ERGM way.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"terms-classification-for-every-exponential-random-graph-model-ergm","dir":"Articles","previous_headings":"","what":"Terms classification for every Exponential Random Graph Model (ERGM)","title":"Exponential Random Graph Models","text":"Terms can classified six main ways. Dyadic independent dyadic dependent terms: encounter first one probability edge formation related nodes properties attributes; encounter second probability edge formation depends existing edges. Structural nodal attributes terms: first kind provides tools understand structure network per se; second kind provides tools explain nodal attributes might influenced formation edges. Terms directed networks terms undirected networks Exogenous Endogenous terms: first one refers terms using covariates, second structural terms. Markovian non-Markovian: Markovian term measures structure network neighborhood Curved (geometrically weighted ) non-curved: terms tweaked improve model stability","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"binary-exponential-random-graph-model-ergm","dir":"Articles","previous_headings":"","what":"Binary Exponential Random Graph Model (ERGM)","title":"Exponential Random Graph Models","text":"ERGM model performed ergm::ergm function. basic function call follows: formula requires specification network dependent variable, list terms.","code":"fit <- ergm::ergm(formula)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-structuralendogenous---dyadic-independent-terms","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Most popular structural/endogenous - dyadic independent terms","title":"Exponential Random Graph Models","text":"edges Extent number edges network characterizes overall structure (random number edges, meaningful outcome certain phenomenon?). Introduces one statistic model. Directed Undirected networks. density Extent network density characterizes overall structure (random density, meaningful outcome certain phenomenon?). Introduces one statistic model. Directed Undirected networks. sender Extent specific node, compared baseline one, sending non-random edges (different node’s behavior random distribution). Introduces model many statistics number nodes minus one. Directed Networks . receiver Extent specific node, compared baseline one, receiving non-random edges (different node’s behavior random distribution). Introduces model many statistics number nodes minus one. Directed Networks .","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-structuralendogenousmarkovian---dyadic-dependent-terms","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Most popular structural/endogenous/Markovian - dyadic dependent terms","title":"Exponential Random Graph Models","text":"mutual Extent ties likely reciprocated random network (controlling effects). Introduces one statistic model. Directed networks . asymmetric Extent observed non reciprocated ties non-random. Introduces one statistic model. Directed networks . triangles Extent observed triangles non-random. Introduces one statistic model. Directed Undirected networks. case directed network measures “transitive triple” “cyclic triple”, triangle equals ttriple plus ctriple. triadcensus Extent sixteen categories categorization Davis Leinhardt (1972) observed network generated random. Introduces 16 statistics model. Directed networks . balance Extent type 102 300 categorization Davis Leinhardt (1972) -balanced triads- observed network non-random. Introduces one statistic model. Directed networks . transitive Extent type 120D, 030T, 120U, 300 categorization Davis Leinhardt (1972) -transitive triads- observed network non-random. Introduces one statistic model. Directed networks . intransitive Extent type 111D, 201, 111U, 021C, 030C categorization Davis Leinhardt (1972) -intransitive triads- observed network non-random. Introduces one statistic model. Directed networks . degree(n), idegree(n), odegree(n) Extent nodes specified degree non random. Introduces one statistic model. Directed Undirected networks, possibility specifications Directed networks. kstar(n), istar(n), ostar(n) Extent stars connecting specified number nodes non random. Introduces one statistic model. Directed Undirected networks, possibility specifications Directed networks. cycle(n) Extent cycles specified number nodes non-random. Introduces one statistic model. Directed Undirected networks.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-structuralendogenouscurved---dyadic-dependent-terms","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Most popular structural/endogenous/curved - dyadic dependent terms","title":"Exponential Random Graph Models","text":"gwesp(decay=0.25, fixed=FALSE) Geometrically weighted edgewise shared partner distribution. can used place triangles improve convergence. decay parameter non-negative. value supplied parameter may fixed (fixed=TRUE), may used instead starting value estimation decay curved exponential family model (fixed=FALSE, default) (see Hunter Handcock, 2006). term can used directed undirected networks. directed networks, outgoing two-path (“OTP”) shared partners counted. dgwesp(decay=0.25, fixed=FALSE, type= 'RTP') Geometrically weighted edgewise shared partner distribution. also counts types shared partners covered gwesp: Outgoing Two-path (“OTP”), Incoming Two-path (“ITP”), Reciprocated Two-path (“RTP”), Outgoing Shared Partner (“OSP”), Incoming Shared Partner (“ISP”). gwdegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL), gwidegree(.5,fixed=T), gwodegree(.5,fixed=T) Geometrically weighted degree distribution. can used place degree(n) improve convergence. Introduces one statistic model equal weighted degree distribution decay controlled decay parameter. Directed Undirected networks, possibility specifications Directed networks.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-nodal-covariate-terms","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Most popular nodal covariate terms","title":"Exponential Random Graph Models","text":"nodecov, nodeicov, nodeocov Numeric Integer attributes. Extent attribute values influence edge formation (logit model) non-random condition. Introduces one statistic model. Directed Undirected networks, possibility specifications Directed networks. Dyadic independent. nodefactor, nodeifactor, nodeofactor Categorical attributes. Extent nodes characterized specific category form ties, tie formation non-random condition. Introduces model number statistics equal number categories minus one. Directed Undirected networks, possibility specifications Directed networks. Dyadic independent. absdiff Numeric Integer attributes. Extent common features measured terms distance similarity influence edge formation, edge formation non-random condition. Introduces one statistic model. Directed Undirected networks. Dyadic independent. nodematch Categorical attributes. Extent nodes characterized specific category belonging certain attribute form ties node characterized category, tie formation condition non-random. Introduces model many statistics number categories. Directed Undirected networks. Dyadic independent. —Differential homophily edgecov Matrix attribute. Extent ties formed another context influence tie formation context current model, tie formation circumstances non-random. Introduces one statistic model. Directed Undirected networks. Dyadic dependent. nodemix Categorical attributes. Extent nodes denoted different categories attribute form ties, tie formation circumstances non-random. Introduces many statistics number combinations every two categories. Directed Undirected networks. Dyadic independent.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"terms-specifications","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Terms specifications","title":"Exponential Random Graph Models","text":"Use argument levels within term specification selecting baseline reference category. Example: set female reference category.","code":"fit <- ergm::ergm(Net ~ edges + nodefactor('sex', levels = -(2)))"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"searching-for-terms","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Searching for terms","title":"Exponential Random Graph Models","text":"can look additional terms four arguments help finding terms: keyword optional character keyword search text term descriptions. matching terms returned. Matching case insensitive. net network object term applied , used template determine directedness, bipartite, etc categories optional character vector category tags use restrict results (.e. ‘curved’, ‘triad-related’) –see categorization terms manual name optional character name specific term return","code":"search.ergmTerms(keyword, net, categories, name)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"checking-your-data-before-the-analysis","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Checking your data before the analysis","title":"Exponential Random Graph Models","text":"run exponential random graph model must know data heart. using descriptive network statistics, also checking model specifications, hitting run button. Manually check attribute(s) (numeric, integer, categorical, ordinal) check mixing categorical attributes check model statistics. last one provides number observed cases assumptions term.","code":"table(snafun::extract_vertex_attribute(Net, 'sex')) snafun::make_mixingmatrix(Net, \"sex\") summary(Net ~ edges + nodefactor('sex'))"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"reading-results","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Reading results","title":"Exponential Random Graph Models","text":"interpret ERGM results logit models results. Two options: Compute odd ratios coefficient Compute probability coefficient Compute odd ratios using SNA4DS function Compute probability using snafun function","code":"OR <- exp(coef) P <- exp(coef) / (1 + exp(coef)) OR <- snafun::stat_ef_int(m) P <- snafun::stat_ef_int(m, type = \"probs\")"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"simulating-networks","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Simulating networks","title":"Exponential Random Graph Models","text":"sometimes helpful simulate networks features one observed real life. Simulating network model simulate network fixing coefficient results","code":"fit <- ergm::ergm(Net ~ edges) simfit <- simulate(fit, burnin = 1e+6, verbose = TRUE, seed = 9) RandomNet <- network::network(16,density=0.1,directed=FALSE)  sim <- simulate(~ edges + kstar(2), nsim = 2, coef = c(-1.8, 0.03),                   basis = RandomNet,                   control = ergm::control.simulate(                     MCMC.burnin=1000,                     MCMC.interval=100)) sim[[1]]"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"mcmc-diagostics","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"MCMC Diagostics","title":"Exponential Random Graph Models","text":"can check Monte Carlo Markov Chains diagnostic dyadic dependent model using function:","code":"ergm::mcmc.diagnostics(fit)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"Binary Exponential Random Graph Model (ERGM)","what":"Goodness of Fit","title":"Exponential Random Graph Models","text":"can check goodness fit model using function can also plot gof output , making use new best friend (snafun package):","code":"ergm::gof(fit) plot(ergm::gof(fit)) snafun::stat_plot_gof(fit) stat_plot_gof_as_btergm(fit)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"bipartite-ergms","dir":"Articles","previous_headings":"","what":"Bipartite ERGMs","title":"Exponential Random Graph Models","text":"bipartite ERGM works exactly way binary one. However, order make handle data differentiating two partitions, necessary use specially defined terms. Moreover, need specify model advanced settings since computationally demanding.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"importing-bipartite-ergms","dir":"Articles","previous_headings":"Bipartite ERGMs","what":"Importing Bipartite ERGMs","title":"Exponential Random Graph Models","text":"Since using function binary ERGM (ergm::ergm) run model, necessary make sure software knows needs handle bipartite structure.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"step-one-specify-the-incidence-matrix","dir":"Articles","previous_headings":"Bipartite ERGMs > Importing Bipartite ERGMs","what":"Step one: Specify the incidence matrix","title":"Exponential Random Graph Models","text":"data contains bipartite network information needs specified partition 1 X partition 2 data frame matrix. 10 people attend 4 events, incidence matrix dimensions 10 X 4.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"step-two-import-the-network-as-a-bipartite","dir":"Articles","previous_headings":"Bipartite ERGMs > Importing Bipartite ERGMs","what":"Step two: Import the network as a bipartite","title":"Exponential Random Graph Models","text":"can import network bipartite using specifications.","code":"BipNet <- network::network(BipData, directed = FALSE, bipartite = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"step-three-import-the-attributes","dir":"Articles","previous_headings":"Bipartite ERGMs > Importing Bipartite ERGMs","what":"Step three: Import the attributes","title":"Exponential Random Graph Models","text":"can import attributes using code. attribute vector needs contain many elements Partition 1 + Partition 2. However, unlikely attribute makes sense partitions time. Make sure insert information concerns partition 1 afterward information concerns partition 2. Make sure code NA entry partition information. instance, one attribute partition one network 10 nodes partition 1 4 partition 2, first ten digits storing information nodes partition 1 4 NAs partition 2.","code":"# vertex.names <- vector of names attrib1 <- as.character(c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, NA, NA, NA, NA))  snafun::add_vertex_attributes(BipNet, \"vertex.names\",  vertex.names) snafun::add_vertex_attributes(BipNet, \"attrib1\",  attrib1)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"step-four-bipartite-extra-info","dir":"Articles","previous_headings":"Bipartite ERGMs > Importing Bipartite ERGMs","what":"Step four: Bipartite extra info","title":"Exponential Random Graph Models","text":"order make sure software correctly reads bipartite network, need code extra attribute. attribute focuses partition one. example, 10 nodes partition 1 use: Note: bipratite, yes, typo, typo package. Hence make sure misspell ; otherwise, get error. (FUN FACT!)","code":"snafun::add_vertex_attributes(BipNet, \"bipratite\", value = rep(10, 10), v = 1:10)"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"terms-for-bipartite-ergms","dir":"Articles","previous_headings":"Bipartite ERGMs","what":"Terms for Bipartite ERGMs","title":"Exponential Random Graph Models","text":"Bipartite ERGMs terms provided time partitions since relevant consider structure perspectives. can find full list bipartite terms running: 32 total, manageable.","code":"ergm::search.ergmTerms(categories = \"bipartite\")"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"the-most-popular-terms-are","dir":"Articles","previous_headings":"Bipartite ERGMs > Terms for Bipartite ERGMs","what":"The most popular terms are:","title":"Exponential Random Graph Models","text":"b1star(k) & b2star(k) – star(k) binary ERGMs gwb1dsp() & gwb2dsp() – gwdsp() binary ERGMs b1cov & b2cov – nodecov() binary ERGMs b1factor & b2factor – nodefactor() binary ERGMs b1nodematch & b2nodematch – nodematch() binary ERGMs","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"specifying-advanced-options","dir":"Articles","previous_headings":"Bipartite ERGMs","what":"Specifying advanced options","title":"Exponential Random Graph Models","text":"Since bipartite ERGM computationally demanding regular one, need make sure specify advanced options offered ergm package.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"constraints","dir":"Articles","previous_headings":"Bipartite ERGMs > Specifying advanced options","what":"Constraints","title":"Exponential Random Graph Models","text":"Constraints options allow set limits simulation takes account instance, can limit simulation setting min max degree. constraints= ~ bd(minout = 0, maxout = 7) instance, many constraints possible use","code":"m <- ergm::ergm(BipNet ~ edges  + b1factor(\"attr1\", levels = -1) + b1star(2),                  constraints= ~ bd(minout = 0, maxout = 7))"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"control","dir":"Articles","previous_headings":"Bipartite ERGMs > Specifying advanced options","what":"Control","title":"Exponential Random Graph Models","text":"Controls options allow aware simulation larger extent , reason, make faster. several options. instance, MCMC.burnin - ignore many chains starting estimate parameters MCMC.samplesize - collect number information previous state order inform following one seed - makes simulation go way every time run MCMLE.maxit - breaks algorithm number attempts. instance,","code":"m <- ergm::ergm(BipNet ~ edges  + b1factor(\"attr1\", levels = -1) + b1star(2),                  constraints= ~ bd(minout = 0, maxout = 7),                  control = ergm::control.ergm(MCMC.burnin = 5000,                                               MCMC.samplesize = 10000,                                               seed = 1234,                                               MCMLE.maxit = 20))"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"weighted-ergms","dir":"Articles","previous_headings":"","what":"Weighted ERGMs","title":"Exponential Random Graph Models","text":"weighted network network edges express weight intensity relationship. still unimodal, contains information. order use weighted ergms, network needs fully connected. Different kinds weights require different models. need check: kind variable type characterizes weights (integer, count, numeric, ordinal…) kind distribution weight GERGM package works fully connected networks (theoretically ) every kind weight variable. GERGM package recognize either network igraph classes. need work weighted adjacency matrices (NxN - squared, inside weight, rather 0s 1s).","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"documentation","dir":"Articles","previous_headings":"Weighted ERGMs","what":"Documentation","title":"Exponential Random Graph Models","text":"Installation: remotes::install_github(\"matthewjdenny/GERGM\", dependencies = TRUE) User manual https://github.com/matthewjdenny/GERGM Vignette Run browseVignettes(\"GERGM\")R console","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-endogenous-terms-markovian-and-curved","dir":"Articles","previous_headings":"Weighted ERGMs","what":"Most popular endogenous terms (Markovian and Curved)","title":"Exponential Random Graph Models","text":"twostars, equivalent star(2) ergm out2stars, equivalent ostar(2) ergm in2stars, equivalent istar(2) ergm ctriads, ergm mutual, ergm ttriads, ergm Convergence problems? Use exponential -weighting. AKA “curve” terms: E.g., out2stars(alpha = 0.25) - default = 1","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"most-popular-exgenous-terms","dir":"Articles","previous_headings":"Weighted ERGMs","what":"Most popular exgenous terms","title":"Exponential Random Graph Models","text":"absdiff(covariate = \"MyCov\") sender(covariate = \"MyCov\") – different ergm, can insert attribute receiver(covariate = \"MyCov\") – different ergm, can insert attribute nodematch(covariate = \"MyCov\", base = \"Ref.cat\") nodemix(covariate = \"MyCov\", base = \"Ref.cat\") netcov(network) – like edgecov ergm","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"running-the-model","dir":"Articles","previous_headings":"Weighted ERGMs","what":"Running the model","title":"Exponential Random Graph Models","text":"First, specify formula, run model GERGM::gergm function automatically prints results runs. However, also possible print separately.","code":"formula <- adjacencyMatrix ~ edges +   sender(\"myCov\") +   receiver(\"myCov\") +   netcov(otherAdjMat) +   mutual(alpha = .9) set.seed(5) gergmResults <- GERGM::gergm(formula,                       estimation_method = \"Metropolis\", # chose the algorithm to estimate the model                       covariate_data = covariateData, # passing attributes on                       number_of_networks_to_simulate = 100000, # same as ergm                       MCMC_burnin = 10000, # same as ergm                       thin = 1/10, # retaining only a small number of simulated Networks in the computer memory                       transformation_type = \"Cauchy\") # distribution of the weight"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"plotting-mcmc-diagnostics","dir":"Articles","previous_headings":"Weighted ERGMs > Running the model","what":"Plotting MCMC diagnostics","title":"Exponential Random Graph Models","text":"GERGM::Trace_Plot(gergmResults)","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"plotting-the-goodnes-of-fit","dir":"Articles","previous_headings":"Weighted ERGMs > Running the model","what":"Plotting the Goodnes of fit","title":"Exponential Random Graph Models","text":"GOF(gergmResults)","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"plotting-the-results","dir":"Articles","previous_headings":"Weighted ERGMs > Running the model","what":"Plotting the results","title":"Exponential Random Graph Models","text":"GERGM::Estimate_Plot(gergmResults)","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"printing-a-table-with-standard-errors-and-coefficients","dir":"Articles","previous_headings":"Weighted ERGMs > Running the model","what":"Printing a table with standard errors and coefficients","title":"Exponential Random Graph Models","text":"","code":"(EstSE <- rbind(t(attributes(gergmResults)$theta.coef),                 t(attributes(gergmResults)$lambda.coef)))"},{"path":"https://snanalyst.github.io/SNAfun/articles/ERGMs.html","id":"significance","dir":"Articles","previous_headings":"Weighted ERGMs > Running the model","what":"Significance","title":"Exponential Random Graph Models","text":"GERGM models use confidence intervals instead p-values. can estimate confidence interval using formula lower upper intervals negative positive, coefficient significant. lower upper intervals different sign, coefficient significant.","code":"lower = coef - SE*(-qnorm((1 - 0.95)/2)) upper = coef + SE*(-qnorm((1 - 0.95)/2))"},{"path":"https://snanalyst.github.io/SNAfun/articles/Graph-level-indices.html","id":"graph-level-indices","dir":"Articles","previous_headings":"","what":"Graph level indices","title":"Graph level indices","text":"find table determine foundational indices graph graph-level.","code":"snafun::g_summary(x, directed = TRUE) snafun::count_vertices(x) igraph::vcount() network::network.size() snafun::count_edges(x) igraph::ecount(x) igraph::gsize(x) network::network.edgecount(x) snafun::g_density(x, loops = FALSE) igraph::edge_density(g) # preferable for biprartite graphs network::network_density(g)  # preferable for valued graphs sna::gden(g) snafun::g_reciprocity(x) igraph::reciprocity(g) sna::grecip(g,'measure = 'edgewise') snafun::g_transitivity(x) igraph::transitivity(g, type = 'global') sna::gtrans(g, mode = 'digraph', measure = 'weak', use.adjacency = TRUE) snafun::g_mean_distance(x) igraph::mean_distance(g, directed = TRUE, unconnected = TRUE) snafun::g_degree_distribution(x, mode = c(\"out\", \"in\", \"all\"),                               type = c(\"density\", \"count\"),                               cumulative = FALSE,                                loops = FALSE,                               digits = 3) igraph::degree_distribution(graph, cumulative = FALSE, mode = 'out') snafun::count_dyads(x, echo = TRUE) igraph::dyad_census(g) sna::dyad.census(g) snafun::count_triads(x, echo = TRUE) igraph::triad_census(g) sna::triad.census(g, mode = 'digraph') igraph::assortativity_degree(g, directed = TRUE) snafun::g_diameter(x, directed = is_directed(x), unconnected = TRUE) igraph::diameter(g, directed = TRUE, unconnected = TRUE)  # what is the vertex pair with the longest geodesic igraph::farthest_vertices(g) snafun::g_radius(x, mode = c(\"all\", \"out\", \"in\")) igraph::radius(graph, mode = c(\"all\", \"out\", \"in\", \"total\")) snafun::g_compactness(x, mode = c(\"out\", \"in\", \"all\")) # a single function to calculate centralization (either `Freeman` or `sd`) # on a wide range of centrality indices  snafun::g_centralize(x, measure = \"betweenness\",   directed = TRUE, mode = c(\"all\", \"out\", \"in\"),   k = 3, damping = 0.85, normalized = TRUE,   method = c(\"freeman\", \"sd\")) # general function for Freeman centralization igraph::centralize(scores, theoretical.max = 0, normalized = TRUE)   # betweenness centralization igraph::centr_betw(g, directed = TRUE)  # closeness centralization igraph::centr_clo(g, mode = 'out', normalized = FALSE)   # degree centralization igraph::centr_degree(g, mode = 'all')  # eigenvector centralization igraph::centr_eigen(g, directed = TRUE) # general function for Freeman centralization, # include any function that calculates vertex centrality sna::centralization(g, FUN, mode = 'digraph', normalize=TRUE, ...) snafun::make_mixingmatrix(x, attrname, by_edge = FALSE, loops = has_loops(x)) network::mixingmatrix(object, attrname, useNA = \"ifany\", expand.bipartite = FALSE) snafun::g_correlation(g1, g2, diag = FALSE) sna::gcor(g1, g2, mode = 'graph') snafun::extract_comm_fastgreedy(x, weights = NA, modularity = TRUE,    merges = TRUE, membership = TRUE) igraph::cluster_fast_greedy(g, merges = TRUE, modularity = TRUE,   membership = TRUE, weights = NULL) snafun::extract_comm_girvan(x, weights = NA, directed = TRUE, modularity = TRUE,   edge.betweenness = FALSE, bridges = FALSE, merges = TRUE, membership = TRUE) igraph::cluster_edge_betweenness(g, weights = NULL, directed = TRUE, edge.betweenness = TRUE,   merges = TRUE, bridges = TRUE, modularity = TRUE, membership = TRUE) snafun::extract_comm_louvain(x, weights = NA, resolution = 1) igraph::cluster_louvain(graph, weights = NULL, resolution = 1) snafun::extract_comm_walktrap(x, weights = NA, steps = 4, modularity = TRUE,   merges = TRUE, membership = TRUE) igraph::cluster_walktrap(g, weights = NULL, steps = 4, merges = TRUE, modularity = TRUE,    membership = TRUE) snafun::merge_membership(coms, merges)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Graph-level-indices.html","id":"communities-and-other-subgroups","dir":"Articles","previous_headings":"Graph level indices","what":"Communities and other subgroups","title":"Graph level indices","text":"informative know snafun functions extract communities yield results can scrutinized igraph. snafun package smart enough , regardless whether original input graph class igraph network. Really handy. ’s example.  inclined, can plot community division dendrogram, follows:","code":"# generate a random directed graph with 20 vertices and 30 edges g <- snafun::create_random_graph(20, \"gnm\", m = 30)  # determine the walktrap communities walk <- snafun::extract_comm_walktrap(g) print(walk) #> IGRAPH clustering walktrap, groups: 6, mod: 0.33 #> + groups: #>   $`1` #>   [1]  7  9 10 12 13 18 #>    #>   $`2` #>   [1]  5  6 16 19 20 #>    #>   $`3` #>   [1]  1  2 14 #>    #>   $`4` #>   + ... omitted several groups/vertices  # get the modularity score igraph::modularity(walk) #> [1] 0.3344444  # who is member of which community igraph::communities(walk) #> $`1` #> [1]  7  9 10 12 13 18 #>  #> $`2` #> [1]  5  6 16 19 20 #>  #> $`3` #> [1]  1  2 14 #>  #> $`4` #> [1]  3 15 17 #>  #> $`5` #> [1]  4 11 #>  #> $`6` #> [1] 8  # which community is a vertex member of igraph::membership(walk) #>  [1] 3 3 4 5 2 2 1 6 1 1 5 1 1 3 4 2 4 1 2 2  # number of communities length(walk) #> [1] 6  # size of each community igraph::sizes(walk) #> Community sizes #> 1 2 3 4 5 6  #> 6 5 3 3 2 1  # which edge connects multiple communities igraph::crossing(walk, g) #>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #> [13] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE #> [25]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  # plot the network, highlighting the communities plot(walk, g) snafun::plot_comm_dendrogram(walk)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Graph-level-indices.html","id":"vertex-level-indices","dir":"Articles","previous_headings":"","what":"Vertex-level indices","title":"Graph level indices","text":"functions determine many vertex-level indices want use course.","code":"snafun::v_degree(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"),   loops = FALSE, rescaled = FALSE) igraph::degree(g, mode = 'out') sna::degree(g, gmode = 'digraph', cmode = 'outdegree') snafun::v_betweenness(x, vids = NULL, directed = TRUE, rescaled = FALSE) igraph::betweenness(g, directed = TRUE) sna::betweenness(g, gmode = 'digraph', cmode = 'directed') sna::flowbet(g, gmode = 'digraph', cmode = 'rawflow') igraph::power_centrality(g) sna::bonpow(g, gmode = 'digraph') snafun::v_closeness(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE) igraph::closeness(g, mode = 'all') sna::closeness(g, gmode = 'digraph', cmode = 'directed') snafun::v_harmonic(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE) igraph::harmonic_centrality(g, vids = V(graph),    mode = c(\"out\", \"in\", \"all\"), weights = NULL) snafun::v_stress(x, vids = NULL, directed = TRUE, rescaled = FALSE) sna::stresscent(g, gmode = 'digraph', cmode = 'directed') snafun::v_eccentricity(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE) igraph::eccentricity(g, mode = 'all') snafun::v_eigenvector(x, directed = TRUE, rescaled = FALSE) igraph::eigen_centrality(g, directed = TRUE, scale = FALSE)$vector sna::evcent(g, gmode = 'digraph', rescale=FALSE) snafun::v_pagerank(x, vids = NULL, damping = 0.85, directed = TRUE, rescaled = FALSE) igraph::page_rank(g, vids = V(graph), directed = TRUE, damping = 0.85, weights = NULL) # without using weights snafun::v_geokpath(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"),    k = 3, rescaled = FALSE)  # if weights are to be used snafun::v_geokpath_w(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"),   weights = NULL, k = 3) snafun::v_shapley(x, add.vertex.names = FALSE, vids = NULL, rescaled = FALSE) snafun::extract_neighbors(x, vertex, type = c(\"out\", \"in\", \"all\")) igraph::neighbors(g, 'Jane', mode = 'out')  # all options igraph::neighbors(graph, v, mode = c('out', 'in', 'all', 'total')) network::get.neighborhood(g, 1, 'out')  # all options network::get.neighborhood(x, v, type = c('out', 'in', 'combined'), na.omit = TRUE) igraph::make_ego_graph(g, order = 1, nodes = \"Jane\", mode = \"all\")  # all options igraph::make_ego_graph(graph, order = 1, nodes = V(graph),   mode = c(\"all\", \"out\", \"in\"), mindist = 0) sna::ego.extract(dat, ego = NULL, neighborhood = c(\"combined\", \"in\", \"out\"))  sna::neighborhood(dat, order, neighborhood.type = c(\"in\", \"out\", \"total\"),   mode = \"digraph\", diag = FALSE, thresh = 0, return.all = FALSE, partial = TRUE)"},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/articles/Introduction.html","id":"overview-of-igraph-and-network-graph-objects","dir":"Articles","previous_headings":"Main packages in the SNA4DS course","what":"Overview of igraph and network graph objects","title":"Introduction","text":"two main packages basic graph generation manipulation: igraph package statnet package. Actually, statnet suite packages work together. course, make use several packages statnet suite. igraph package creates graph object type igraph. statnet suite creates graph object type network. many things can packages. packages can generate graphs basic manipulation, just use package whose API like best. igraph package provides mathematical functions apply graph data statnet suite provides loads statistical models igraph package .","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Introduction.html","id":"snafun-intro","dir":"Articles","previous_headings":"Main packages in the SNA4DS course","what":"The snafun package","title":"Introduction","text":"igraph package statnet suite jointly powerful can support much analyses network data. However, read , require graph objects specific structures can’t deal graph object different structure. , want use functions igraph sna packages, need network data igraph format (igraph package), network format (network package sna package) matrix format (many functions sna package). words, convert data formats also deal differing API’s various packages. Believe , pain quite annoying. snafun PACKAGE RESCUE! snafun package three things: First, provides (fairly) consistent API, don’t constantly figure specific argument means function; Second, functions snafun package work objects class igraph network. result, can want , without bothering whether object work class igraph network. Third, removing pain coming constant switching two groups packages inconsistent API, can now actually focus fun network analysis, rather frustration. Oh, fourth advantage : authors snafun package cool people. , need new function package, just get touch us ’ll see can . :-)","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Manipulating-the-graph-object.html","id":"manipulate","dir":"Articles","previous_headings":"","what":"Manipulating the graph object","title":"Manipulating the graph object","text":"network object, want explore access parts extract info . table functions ’ll use time SNA project.","code":"snafun::print(x) igraph::print.igraph(x) network::print.network(x) snafun::has_edge_attributes(x)  snafun::has_vertex_attributes(x)  snafun::has_vertex_attribute(x, attrname)  snafun::has_edge_attribute(x, attrname)  snafun::has_vertexnames(x)  snafun::has_loops(x)  snafun::is_bipartite(x)  snafun::is_connected(x, rule = c(\"weak\", \"strong\"))  snafun::is_directed(x)  snafun::is_network(x)  snafun::is_igraph(x)  snafun::is_signed(x)  snafun::is_weighted(x) # various functions, including igraph::any_loop(g) igraph::any_multiple(g) igraph::is_bipartite(graph) igraph::is_connected(graph, mode = c(\"weak\", \"strong\")) igraph::is_directed(graph) igraph::is_igraph(graph) igraph::is_named(graph) igraph::is_simple(graph) igraph::is_weighted(graph) # various functions, including: network::has.loops(x) network::is.bipartite(x) network::is.directed(x) network::is.multiplex(x) network::is.network(x) sna::is.connected(g, connected = \"strong\") igraph::V(x)              # vertices igraph::E(x)              # edges snafun::extract_vertex_attribute(x, name) snafun::extract_vertex_names(x)             # specific to access the vertex names attribute snafun::extract_edge_attribute(x, name) snafun::extract_graph_attribute(x, name) igraph::vertex_attr(graph, name, index = V(graph)) igraph::V(graph)attributenameigraph::edgeattr(graph,name,index=E(graph))igraph::E(graph)attributename          igraph::edge_attr(graph, name, index = E(graph))     igraph::E(graph)attributenameigraph::edgea​ttr(graph,name,index=E(graph))igraph::E(graph)attributename  igraph::graph_attr(graph, name) network::get.vertex.attribute(x, attrname) network::get.edge.attribute(x, attrname) network::get.network.attribute(x, attrname) snafun::extract_edge_id(object, ego, alter, edgelist) snafun::extract_vertex_names(x) igraph::V(x)$name igraph::vertex_attr(x, name = \"names\") network::get.vertex.attribute(x, \"vertex.names\") network::network.vertex.names(x) snafun::add_vertex_names(x, value) igraph::V(x)$name <- value igraph::set_vertex_attr(x, name = \"names\") network::set.vertex.attr(x, \"vertex.names\", value) network::network.vertex.names(x) <- value snafun::list_vertex_attribute(x, name) snafun::list_edge_attribute(x, name) snafun::list_graph_attribute(x, name) igraph::vertex_attr_names(graph) igraph::edge_attr_names(graph) igraph::graph_attr_names(graph) network::list.vertex.attributes(x) network::list.edge.attributes(x network::list.network.attributes(x) snafun::extract_all_vertex_attributes(g) # very flexible and powerful functions to add attributes  # in several ways, with the same function snafun::add_edge_attributes(object, attr_name, value, edgelist, overwrite = FALSE)  snafun::add_vertex_attributes(x, attr_name = NULL, value) snafun::add_graph_attribute(x, attr_name = NULL, value) igraph::set_edge_attr(g, \"name\", value) igraph::E(g)name<−valueigraph::setvertexattr(g,\"name\",value)igraph::V(g)name <- value          igraph::set_vertex_attr(g, \"name\", value)     igraph::V(g)name<−valueigraph::setv​ertexa​ttr(g,\"name\",value)igraph::V(g)name <- value  igraph::set_graph_attr(g, \"name\", value) g$name <- value network::set.edge.attribute(g, \"new_name\", value, e = seq_along(gmel))network::set.edge.value(g,\"newname\",value,e=seqalong(gmel))     network::set.edge.value(g, \"new_name\", value, e = seq_along(gmel))network::set.edge.value(g,\"newn​ame\",value,e=seqa​long(gmel))  network::set.network.attribute(g, \"new_name\", value)  network::set.vertex.attribute(g, \"new_name\", value, v = seq_len(network::network.size(g))) snafun::remove_edge_attribute(x, attr_name) snafun::remove_edge_weight(x)  # remove edge weights  snafun::remove_vertex_attribute(x, attr_name) snafun::remove_vertex_names(x)   # specific for the vertex name attribute  snafun::remove_graph_attribute(x, attr_name) igraph::delete_edge_attr(graph, name) igraph::delete_vertex_attr(graph, name) igraph::delete_graph_attr(graph, name) network::delete.edge.attribute(x, attrname, ...) network::delete.vertex.attribute(x, attrname, ...) network::delete.network.attribute(x, attrname, ...) igraph::add_vertices(graph, nv, ..., attr = list()) igraph::add_edges(graph, edges, ..., attr = list()) network::add.vertices(x, nv, vattr = NULL, last.mode = TRUE, ...) network::add.edge(x, tail, head, names.eval = NULL, vals.eval = NULL, edge.check = FALSE, ...) network::add.edges(x, tail, head, names.eval = NULL, vals.eval = NULL, ...) snafun::remove_vertices(x, vertices) igraph::delete_vertices(graph, v) igraph::delete_edges(graph, edges) network::delete.edges(x, eid) network::delete.vertices(x, vid) snafun::contract_vertices(g, vertices, method = c(\"min\", \"max\", \"union\", \"add\"),   attr = NULL, new_name = \"set\", out_as_igraph = TRUE) # single function to do it all snafun::extract_subgraph(x, v_to_keep, e_to_keep) # subset based on vertices igraph::induced_subgraph(g, vids = theVerticesYouWantToKeep)  # subset based on edges igraph::subgraph.edges(g, eids = theEdgesYouWantToKeep) # subset based on vertices network::get.inducedSubgraph(g, v = theVerticesYouWantToKeep)  # subset based on edges network::get.inducedSubgraph(g, eid = theEdgesYouWantToKeep) snafun::extract_egonet(x, vertices = NULL, order = 1, type = c(\"all\", \"out\", \"in\")) igraph::make_ego_graph(g, order = 1, nodes = V(graph), mode = c(\"all\", \"out\", \"in\"), mindist = 0) sna::ego.extract(dat, ego = NULL, neighborhood = c(\"combined\", \"in\", \"out\")) snafun::find_isolates(x, names = TRUE, loops = FALSE) snafun::remove_isolates(x, loops = FALSE) snafun::remove_loops(x) igraph::simplify(g)  # for example igraph::simplify(g, remove.multiple = TRUE,     remove.loops = TRUE, edge.attrib.comb = list(weight = 'max')) sna::isolates(g, diag=FALSE) snafun::make_union(net1, net2, net3, byname = 'auto') igraph::union(net1, net2, net3) snafun::extract_intersection(net, net2, net3, byname = 'auto', keep.all.vertices = TRUE) igraph::intersection(net, net2, net3)"},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/articles/Plotting.html","id":"plotting-in-snafun","dir":"Articles","previous_headings":"Plotting","what":"Plotting in snafun","title":"Plotting","text":"snafun package provides plot(x) function, allows user make quick plot network, regardless whether x graph class network igraph. function wraps network::plot.network igraph::plot.igraph use default settings functions. However, one can also use arguments network::plot.network igraph::plot.igraph make plots nicer wanted. example network object.   igraph graph object:   common use case function make quick plot network, using default settings, one usually initial phase study. , snafun provides consistent function name. snafun package also contains function plot centrality scores vertices. function options specified follows: yields plot like :  function takes object class igraph network plots centrality scores select, can visually compare . Make sure pick required value mode (default “”).","code":"g_n <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"network\") snafun::plot(g_n) snafun::plot(g_n, vertex.cex = 3, vertex.col = \"green\", edge.lwd = 10,    edge.col = \"darkgrey\", usecurve = TRUE, edge.curve = .05,    arrowhead.cex = 3, displaylabels = TRUE, label.pos = 5) g_i <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"igraph\") snafun::plot(g_i) snafun::plot(g_i, vertex.size = 12, vertex.color = \"green\", edge.width = 5, edge.curved = TRUE) snafun::plot_centralities(   net,   measures = c(\"betweenness\", \"closeness\", \"degree\", \"eccentricity\"),   directed = TRUE,   mode = c(\"all\", \"out\", \"in\"),   k = 3,   rescaled = FALSE,   ... )"},{"path":"https://snanalyst.github.io/SNAfun/articles/Plotting.html","id":"basic-plotting-in-igraph","dir":"Articles","previous_headings":"Plotting","what":"Basic plotting in igraph","title":"Plotting","text":"plot function alone already plots nodes edges default options. sophisticated specifications need manually set. works networks class igraph.","code":"igraph::plot.igraph(net,      edge.arrow.size = .2,                # edge and arrow size      edge.color = \"red\",                  # edge color      vertex.color = \"blue\",               # vertex filling color      vertex.frame.color = \"green\",        # vertex perimeter color      vertex.label = igraph::V(net)$label, # vertex labels      vertex.label.cex = 0.6,              # vertex label size      vertex.label.color = \"black\")        # vertex label color"},{"path":"https://snanalyst.github.io/SNAfun/articles/Plotting.html","id":"basic-plotting-in-network","dir":"Articles","previous_headings":"Plotting","what":"Basic plotting in network","title":"Plotting","text":"gplot function alone already plots nodes edges default options. sophisticated specifications need manually set. works networks class network.","code":"network::plot.network(net,       arrowhead.cex = 0.2,     # edge and arrow size       edge.col = 'red',        # edge color       vertex.col = 'blue',     # vertex filling color       vertex.border = 'green', # vertex perimeter color       displaylabels = TRUE,    # vertex labels       label.cex = 0.6,         # vertex label size       label.col = 'black')     # vertex label color"},{"path":"https://snanalyst.github.io/SNAfun/articles/Plotting.html","id":"basic-plotting-in-sna","dir":"Articles","previous_headings":"Plotting","what":"Basic plotting in sna","title":"Plotting","text":"gplot function alone already plots nodes edges default options. sophisticated specifications need manually set. works networks class network. gplot function additional arguments compared network::plot.network therefore slightly flexible.","code":"sna::gplot(net,       arrowhead.cex = 0.2,     # edge and arrow size       edge.col = 'red',        # edge color       vertex.col = 'blue',     # vertex filling color       vertex.border = 'green', # vertex perimeter color       displaylabels = TRUE,    # vertex labels       label.cex = 0.6,         # vertex label size       label.col = 'black')     # vertex label color"},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"overview-table","dir":"Articles","previous_headings":"Statistical models","what":"Overview table","title":"Statistical Models","text":"overview statistical models discussed course.","code":"snafun::stat_nam sna::cug.test sna::qaptest sna::netlm sna::netlogit ergm::ergm"},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"network-autocorrelation-models","dir":"Articles","previous_headings":"Statistical models","what":"Network autocorrelation models","title":"Statistical Models","text":"network autocorrelation model run snafun::stat_nam function. implementation appropriate continuous dependent variables. basic function call follows: , formula formula form DEP ~ EXO1 + EXO2 + EXO3 DEP ~ . follows standard way formulating formulas R. Run ?stats::formula console details. data data.frame list containing variables included model. W matrix dimension network, containing weights drive network influence process (lag model) network disturbances process (error model). W2 matrix dimension network, containing weights drive network disturbances running combined model. intercept added model default, best include separate exogenous variable. weigh matrix (matrices) () row-normalized function. want run model using non-standardized weight matrices, use sna::lnam function instead. snafun package provides useful stat_nam_summary method (shows overview results) plot_nam method (use check model assumptions).","code":"snafun::stat_nam(   formula,   data = list(),   W,   W2 = NULL,   model = c(\"lag\", \"error\", \"combined\"),   na.action,   Durbin = FALSE,   quiet = TRUE,   zero.policy = TRUE,   check_vars = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"conditional-uniform-graphs-cug","dir":"Articles","previous_headings":"Statistical models","what":"Conditional Uniform graphs (CUG)","title":"Statistical Models","text":"two methods perform conditional Uniform graph test. first generate graphs manually calculate measures graph. Generation graphs can done using snafun::create_random_graph (conditions size density). equivalent functions sna sna::rgraph sna::rgnm (note generate matrix, rather igraph network graph). See data generation table functions. second approach use function graph generation computes network measure . preferred sna::cugtest, specified follows: See sna help function details. FUN function needs calculated graph FUN.args contains arguments required function specified FUN cmode determines type graphs drawn (ie. condition ). options “size”: generates graphs particular size density 0.5. rarely want . “edges”: conditions specific edge count (exact edge value distribution) “dyad.census”: conditions dyad census (dyad value distribution) example, order test whether transitivity graph g exceptional network size density g, run wise always explicitly tell function whether graph directed , better way specify previous function Testing betweenness centralization network g performed follows, conditioning size density: also useful plot method result CUG test.  huuuuuge downside cug.test function takes specific input graps (perferably matrix-format) allows one test functions implemented within sna package. However, snafun can fix . need construct simple function following structure (yes, always start function x <- snafun::fix_cug_input(x, directed = directed), fixes peculiarities related sna::cug.test function): can now test transitivity graph works snafun::g_transitivity(x) (includes formats ’ll work ). , perform CUG test follows: Et voila. simply works. Wanna use involved measure doesn’t exist sna package anyway? Sure, run CUG test number walktrap communities graph: said, snafun puts FUN straight SNA.","code":"sna::cug.test(g, FUN, mode = c(\"digraph\", \"graph\"), cmode = c(\"size\",     \"edges\", \"dyad.census\"), reps = 1000,     ignore.eval = TRUE, FUN.args = list()) sna::cug.test(g, sna::gtrans, cmode = \"edges\") sna::cug.test(g, mode = \"graph\", FUN = sna::gtrans,               cmode = \"edges\", reps = 1000,               FUN.args = list(mode = \"graph\")) sna::cug.test(g,               sna::centralization,               FUN.arg=list(FUN = sna::betweenness),               mode=\"graph\",               cmode=\"edges\") trans_f <- function(x, directed = FALSE) {   x <- snafun::fix_cug_input(x, directed = directed)   snafun::g_transitivity(x) } sna::cug.test(graph_object,                mode = \"graph\",                FUN = trans_f,                cmode = \"edges\",                reps = 200) walk_num <- function(x, directed = FALSE) {   x <- snafun::fix_cug_input(x, directed = directed)   snafun::extract_comm_walktrap(x) |> length() }  sna::cug.test(graph_object, mode = \"graph\", FUN = walk_num, cmode = \"edges\", reps = 200)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"qap-test","dir":"Articles","previous_headings":"Statistical models","what":"QAP test","title":"Statistical Models","text":"two methods perform QAP test. first manually permute graph. Generation graphs can done using igraph::permute sna::rmperm. See data generation table functions. second approach use function graph permutation computes required measure (typically correlation) . preferred sna::qaptest, specified follows: See sna help function details. FUN function needs calculated permutation ... contains arguments required function specified FUN Typically, want test correlation two graphs, follows: useful summary method plot method output function.","code":"sna::qaptest(g, FUN, reps = 1000, ...) sna::qaptest(list(firstNetwork, secondNetwork),              FUN = sna::gcor, reps = 1000,              g1 = 1, g2 = 2)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"qap-linear-regression","dir":"Articles","previous_headings":"Statistical models","what":"QAP linear regression","title":"Statistical Models","text":"QAP linear regression performed sna::netlm function. function looks follows: Make sure always set intercept = TRUE nullhyp = \"qapspp\". small networks, 1000 replications enough, larger networks typically use higher number (say, 2000). example, specify model graph g modeled linear function graphs g1, g2, g3. wise add names networks output object, like see . strictly necessary, makes output function easier read.","code":"sna::netlm(y, x, intercept = TRUE, mode = \"digraph\",     nullhyp = \"qapspp\", reps = 1000) mod <- sna::netlm(y = g, x = list(g1, g2, g3), intercept = TRUE,                               nullhyp = 'qapspp', reps = 1001) mod$names <- c(\"Intcpt\", \"Net1\", \"Net2\", \"Net3\") summary(mod)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Statistical-models.html","id":"qap-logistic-regression","dir":"Articles","previous_headings":"Statistical models","what":"QAP logistic regression","title":"Statistical Models","text":"QAP logistic regression performed sna::netlogit function. function looks follows: Make sure always set intercept = TRUE nullhyp = \"qapspp\". small networks, 1000 replications enough, larger networks typically use higher number (say, 2000). example, specify model binary graph g modeled function graphs g1, g2, g3.","code":"sna::netlogit(y, x, intercept = TRUE, mode = \"digraph\",     nullhyp = \"qapspp\", reps = 1000) mod <- sna::netlogit(g, list(g1, g2, g3),                      intercept = TRUE,                      nullhyp = \"qapspp\", reps = 1001) mod$names <- c(\"Intcpt\", \"Net1\", \"Net2\", \"Net3\") summary(mod)"},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"temporal-networks-exploration-and-description","dir":"Articles","previous_headings":"","what":"Temporal networks (exploration and description)","title":"Temporal networks exploration and description","text":"main packages use course descriptive exploratory analysis temporal networks networkDynamic construct manipulate temporal networks), tsna (sna-like network measures), ndtv (visualization). Edges typically starting time (onset), end time (terminus), duration, sender (tail), receiver (head). course, edges can start end multiple times observation period can durations length 0 positive number. temporal networks class networkDynamic.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"network-generation-and-manipulation","dir":"Articles","previous_headings":"Temporal networks (exploration and description)","what":"Network generation and manipulation","title":"Temporal networks exploration and description","text":"networkDynamic::networkDynamic: construction temporal network. many ways can construct temporal network. common way first construct network vertex names, vertex static attributes, edge attributes, whether network directed, et cetera.  network called base.net used function extract basic aspects network. Don’t worry values (e.g., vertex attributes) may change time, temporal info add function override base.net. base.net excellent efficient way provide much data function temporal network cumbersome add later .  , can provide dynamic data data.frames vertices edges several ways. Consult help function details, vignette become far long otherwise. .data.frame(g) Extract dynamic edge info network, data.frame. functions allow specify time segment interested . Typically, include onset, terminus, length, . , give one example function can specified. networkDynamic::list.vertex.attributes.active(g, onset = 5, terminus = 8) List attributes vertices active specific time segment. networkDynamic::get.vertex.attribute.active(g, \"attrName\", = 1) value vertex attribute attrName specific time segment. networkDynamic::list.edge.attributes.active(g, onset = 0, terminus = 49) List attributes edge active specific time segment. networkDynamic::get.edge.attribute.active(g, \"attrName\", = 1) value edge attribute attrName specific time segment. networkDynamic::network.extract(classroom, onset = 0, terminus = 1) Extract part temporal network specific time segment. networkDynamic::network.collapse(classroom, onset = 0, terminus = 1) Collapse temporal network static network based activity within specific time segment. networkDynamic::activate.vertex.attribute, networkDynamic::activate.edge.attribute, activate.edge.value, activate.network.attribute Set modify attributes within specific time segment. deactivate.vertex.attribute, deactivate.edge.attribute, deactivate.network.attribute Make attribute inactive specific time segment. NOTE: functions accessing setting attributes networkDynamic object user friendly. Luckily, can also access /set attributes using network package snafun package like network manipulation table. long want access /set attributes static, works much easier uses functions used multiple times already course second nature now.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"network-measures-and-descriptives","dir":"Articles","previous_headings":"Temporal networks (exploration and description)","what":"Network measures and descriptives","title":"Temporal networks exploration and description","text":"networkDynamic::duration.matrix(g, changes, start, end) function takes given temporal network g, matrix columns “time”, “tail”, “head” (matrix called toggle list), start end time. returns data.frame list edges activity spells. toggle represents switch active state inactive, vice-versa. network.size(g, onset = 5, length = 10). size network specific time segment. following functions provide useful descriptives durations temporal network. tsna::edgeDuration(g, mode = \"duration\") tsna::edgeDuration(g, mode = \"counts\") Sums activity duration number edge events time segment. tsna::vertexDuration(g, mode = \"duration\") tsna::vertexDuration(g, mode = \"counts\") Sums activity duration number vertex events time segment. tsna::tiedDuration(g, mode = \"duration\") Measures total amount time vertex ties. tsna::tiesDuration(g, mode = \"counts\") Computes total number edge spells vertex tied . functions tsna::tEdgeFormation tsna::tEdgeDissolution compute number edges forming dissolving time points time segment. result.type = 'fraction' fraction number edges formed (dissolved) computed. tsna::tEdgeFormation(g, start = 1, end = 4, time.interval = 1) Counts times 1, 2, 3, 4. tsna::tEdgeDissolution(g, start = 1, end = 4, time.interval = 1) Counts times 1, 2, 3, 4.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"calculating-measures-from-sna-over-time","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network measures and descriptives","what":"Calculating measures from sna over time","title":"Temporal networks exploration and description","text":"can calculate measure sna package collapsed time segment series collapsed time segments tsna::tSnaStats function. measures can vertex level statistics (e.g., sna:betweenness) graph-level measures (e.g., sna::grecip). specify function want calculate time segments calculated . function returns time series, makes outcomes easy plot. example, want calculate transitivity intervals 5 time points wide. following function calculates transitivity time intervals [0-5), [5-10), [10-15), etc: tsna::tSnaStats(g, snafun = \"gtrans\", time.interval = 5, aggregate.dur = 5) can cause sudden shifts values, often informative use overlapping segments. , let us calculate density windows width 0, intervals 3. calculates density intervals 0-10, 3-13, 6-16, et cetera: tsna::tSnaStats(g, snafun = \"gden\", time.interval = 3, aggregate.dur = 10)","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"calculating-ergm-terms-over-time","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network measures and descriptives","what":"Calculating ergm terms over time","title":"Temporal networks exploration and description","text":"tsna also allows compute ergm terms specific time segments. model terms provided ergm package (various add-ons) ‘change statistics’ (determine effect changing single tie overall network structure), can use terms describe network within specific time segments. specify terms want calculate using formula. example, tsna::tErgmStats(g,'~edges + degree(c(1, 2))', start = 3, end = 10) calculates number edges (edges) values degree(1) degree(2 specified time segment. output time series (column statistic) can simply plotted using plot. plots time series term others, can see develop time.  lecture, discussed participation shifts–also known p-shifts. Gibson (2003) defined 13 P-shifts, tsna::pShiftCount function can count often type occurs specific time segment. Gibson describes thirteen types:","code":"data(windsurfers, package = \"networkDynamic\")  plot(tsna::tErgmStats(windsurfers,'~edges + degree(2) + kstar(3)',                       aggregate.dur = 5), main = \"ERGM terms over time\") knitr::include_graphics(\"pshifts.png\")"},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"participation-shifts","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network measures and descriptives","what":"Participation shifts","title":"Temporal networks exploration and description","text":"tsna::pShiftCount(g, start = 1, end = 3) Calculates number times P-shifts occurred specified time segment. words, calculates P-shift census.","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"temporal-paths","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network measures and descriptives","what":"Temporal paths","title":"Temporal networks exploration and description","text":"tsna::tPath function calculates set temporally reachable vertices given source vertex starting specific time. tsna::tPath(g, v = 12, direction = \"fwd\", start = 0, end = 3) calculates temporal paths vertex 12 vertices, start specified time segment. direction = \"bkwd\", determines paths vertex 12. can specify whether find paths arrive first ones leave vertex latest possible times. generally relevant parts resulting object : tdist time specific path takes. path exist, value Inf. gsteps length path (terms number steps). path exist, value Inf. tsna::plotPaths plots network highlights calculated temporal paths chosen vertex (vertex 12, example ). can also add label edge, can see much time takes edge activated focal vertex. can tweak plot like tweak network plot class network. related concept “temporal reachability.” tsna::tReach function computes, vertex, number vertices temporally reachable entire observation period.<> want compute specific time segment, first use networkDynamic::network.extract extract segment interest feed tsna::tReach function. tsna::tReach(g, direction = \"fwd\", start = 10, end = 20) function calculate temporal reachable sets using temporally forward steps (can also specify direction = \"bkwd\" determine many vertices vertex can temporally reached).","code":"tsna::plotPaths(   g,   paths = tsna::tPath(g, v = 12, direction = \"fwd\", start = 0, end = 3),   displaylabels = FALSE,        # remove the vertex labels, to prevent too much visual clutter   vertex.col = \"white\",   edge.label.cex = 1.5          # the color of the printed times )"},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"network-visualization","dir":"Articles","previous_headings":"Temporal networks (exploration and description)","what":"Network visualization","title":"Temporal networks exploration and description","text":"Temporal networks can visualized two ways. First, static plots can made temporal network, either collapsing temporal network static network (break temporal network static networks specific time segments).","code":""},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"visualizing-as-static-networks","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network visualization","what":"Visualizing as static networks","title":"Temporal networks exploration and description","text":"obvious way visualize entire temporal network static network simply use plot(g). Alternatively, temporal network can collapsed smaller time segments plot network slices static representations. two functions can . ndtv package ndtv::filmstrip follows: ndtv::filmstrip(g, frames = 9) plots network 9 points time. provide overview network changes time, provides series snapshots (9, example) network. timing edges continuous time, function tendency plot nearly empty graphs, evaluates networks specific time points, rather time intervals. snafun package implements function divides specified time period time segments equal time length plots segment static network. useful see network changes time. also works nicely networks changes happen continuous time. sometimes useful function ndtv::proximity.timeline, shows distance edges time. main purpose see edges move vis--vis time (based geodesic path distance) often helps see subgroups forming time. function call : can change mode different scaling algorithm. actual research projects, want try various settings check gives informative output data hand. function allows set many arguments (labels colors).","code":"snafun::plot_network_slices(9, number = 93) ndtv::proximity.timeline(g,  start = 10, end = 50,                          time.increment = .5,                          mode = 'isoMDS')"},{"path":"https://snanalyst.github.io/SNAfun/articles/Temporal-networks-exploration.html","id":"visualizing-as-a-dynamic-network-animation","dir":"Articles","previous_headings":"Temporal networks (exploration and description) > Network visualization","what":"Visualizing as a dynamic network animation","title":"Temporal networks exploration and description","text":"ndtv package includes functions create animation network unfolds time. many arguments can tweak, focus main approach. Make sure consult package help details. two steps creating dynamic visualization ndtv: first run ndtv::compute.animation, determines coordinates aspects dynamic plot. Second, run ndtv::render.d3movie, , guessed , renders actual movie. important arguments ndtv::render.d3movie include: launchBrowser: defaults TRUE: determines whether animation shown Browser rendering. output.mode: kind output want (defaults ‘HTML’) filename: file name HTML JSON file generated. relevant picked ‘HTML’ ‘JSON’ output.mode. , can set common graphical parameters, vertex.col, label.cex, use.arrows, edge.lwd, et cetera. want fix vertices location throughout animation, follows","code":"# step 0: unfortunately, we have to load the package into our session library(ndtv)  # step 1: compute the settings ndtv::compute.animation(g, animation.mode = \"kamadakawai\",                         slice.par = list(start = 0, end = 45,                                          aggregate.dur = 1,                                          interval = 1, rule = \"any\"))  # step 2, render the animation ndtv::render.d3movie(g, usearrows = TRUE, displaylabels = FALSE ,                      bg = \"#111111\",                      edge.col = \"#55555599\",                      render.par = list(tween.frames = 15,                                        show.time = TRUE),                      d3.options = list(animationDuration = 1000,                                        playControls = TRUE,                                        durationControl = TRUE),                      output.mode = 'htmlWidget'                      ) # use some way to determine a matrix of vertex locations coords <- ndtv::network.layout.animate.kamadakawai(g)  # add the x and y coordinates as vertex attributes # adapt onset and terminus if required networkDynamic::activate.vertex.attribute(g, \"x\", coords[, 1],                                           onset = -Inf, terminus = Inf)  networkDynamic::activate.vertex.attribute(g, \"y\", coords[, 2],                                           onset = -Inf, terminus = Inf)  # compute the new animation settings # We now use `animation.mode = \"useAttribute\"` ndtv::compute.animation(g, animation.mode = \"useAttribute\",                         slice.par = list(start = 0, end = 45,                                          aggregate.dur = 1,                                          interval = 1, rule = \"any\"))"},{"path":"https://snanalyst.github.io/SNAfun/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Roger Leenders. Author, maintainer. Claudia Zucca. Author.","code":""},{"path":"https://snanalyst.github.io/SNAfun/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Leenders R, Zucca C (2024). snafun: Bringing fun Social Network Analysis. R package version 0.2024.2, https://snanalyst.github.io/SNAfun/, https://github.com/SNAnalyst/SNAfun.","code":"@Manual{,   title = {snafun: Bringing more fun to Social Network Analysis},   author = {Roger Leenders and Claudia Zucca},   year = {2024},   note = {R package version 0.2024.2, https://snanalyst.github.io/SNAfun/},   url = {https://github.com/SNAnalyst/SNAfun}, }"},{"path":"https://snanalyst.github.io/SNAfun/index.html","id":"snafun","dir":"","previous_headings":"","what":"Bringing more fun to Social Network Analysis","title":"Bringing more fun to Social Network Analysis","text":"FUNctions enjoy alongside SNA4DS course following API used: add_* : add stuff network objects count_* : counting things graph, number vertices, number edges, dyad census, triad census create_* : create graphs (igraph network format) specific characteristics extract_* : access specific data (network) objects is_* : checks, whether network bipartite has_* : checks, whether network loops list_*: list characteristics, list_edge_attributes make_* : create objects based graphs, ie. make matrix vertex attributes, make mixing_matrix, etc. plot_* : several plot functions remove_* : delete parts network, remove isolates stat_* : help functions statistical modeling to_* : conversion methods, converting igraph, network, matrix, data.frame igraph, network, matrix, data.frame , indices/measures three levels: - e_* : edge level indices - g_* : graph level indices, betweenness centralization - v_* : vertex level indices, betweenness Finally, functions don’t fit within clear category don’t follow API.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_edge_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Add edge attributes to a graph — add_edge_attributes","title":"Add edge attributes to a graph — add_edge_attributes","text":"Add one edge attributes graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_edge_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add edge attributes to a graph — add_edge_attributes","text":"","code":"add_edge_attributes(object, attr_name, value, edgelist, overwrite = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/add_edge_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add edge attributes to a graph — add_edge_attributes","text":"object graph attr_name vector one names attributes value vector, matrix, data.frame edgelist matrix dataframe containing edgelist edge attributes overwrite logical, edge attribute overwritten already exists inside graph?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_edge_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add edge attributes to a graph — add_edge_attributes","text":"graph added edge attributes","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_edge_attributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add edge attributes to a graph — add_edge_attributes","text":"Consistent API easily add one edge attributes graph class igraph network. igraph statnet packages (simple) functions . Adding edge attributes easy, several options: vector values specified value name attribute specified attr_name. safe option know sure order edges value identical order edges inside graph object.! data.frame matrix value. Provide names edge attributes get attr_name (can vector one name: number names columns value). Note: column names value overridden whatever provided attr_name. safe option know sure order edges value identical order edges inside graph object! edgelist (data.frame matrix) edgelist. attrname provided, attributes edgelist added graph. attrname provided, columns edgelist added graph occur attr_name. edgelist assumed least three columns. first column contains sender second column contains receiver edge (irrespective names columns sender-receiver order irrelevant undirected graphs). columns assumed edge attributes. safe option, function makes sure edge attributes added correct edge.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_graph_attribute.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a graph attribute — add_graph_attribute","title":"Add a graph attribute — add_graph_attribute","text":"Add graph-level attribute graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_graph_attribute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a graph attribute — add_graph_attribute","text":"","code":"add_graph_attribute(x, attr_name = NULL, value)"},{"path":"https://snanalyst.github.io/SNAfun/reference/add_graph_attribute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a graph attribute — add_graph_attribute","text":"x graph class igraph network attr_name character, name used attribute value value given attribute","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_graph_attribute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a graph attribute — add_graph_attribute","text":"graph added graph attribute","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Add vertex attributes to a graph — add_vertex_attributes","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"Add one vertex attributes graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"","code":"add_vertex_attributes(x, attr_name = NULL, value)"},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"x graph object vertex attributes need added attr_name optional, character vector attribute names (see 'Details') value data.frame, matrix (column names), vector (see 'Details')","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"graph object new attributes added","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"Consistent API easily add one vertex attributes graph class igraph network. igraph statnet packages (simple) functions . Adding vertex attributes easy, several options: vector values specified value name attribute specified attr_name. data.frame value. columns data.frame added graph vertex attributes names data.frame used names new attributes, matrix value. matrix needs appropriate column names. columns matrix added graph vertex attributes column names matrix used names new attributes, data.frame matrix (column names) character vector variable names attr_name. variables names specified attr_name argument taken  data.frame matrix added graph vertex attributes. useful case larger data.frame want add columns vertex attributes. cases, attributes added vertices, need make sure values correct order exist vertices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add vertex attributes to a graph — add_vertex_attributes","text":"","code":"g <- igraph::graph.ring(5) #> Registered S3 methods overwritten by 'igraph': #>   method       from   #>   plot.igraph  snafun #>   print.igraph snafun add_vertex_attributes(g, \"at1\", 1:5) |>    igraph::vertex_attr(\"at1\") #> [1] 1 2 3 4 5  add_vertex_attributes(g, value = data.frame(naam = 1:5)) |>    igraph::vertex_attr(\"naam\") #> [1] 1 2 3 4 5  add_vertex_attributes(g, value = data.frame(een = 11:15, twee = 21:25)) #> IGRAPH aa8edf0 U--- 5 5 -- Ring graph #> + attr: name (g/c), mutual (g/l), circular (g/l), een (v/n), twee (v/n) #> + edges from aa8edf0: #> [1] 1--2 2--3 3--4 4--5 1--5  add_vertex_attributes(g, c(\"twee\", \"een\"),    value = data.frame(een = 11:15, twee = 21:25, drie = 31:35)) #> IGRAPH aa8edf0 U--- 5 5 -- Ring graph #> + attr: name (g/c), mutual (g/l), circular (g/l), twee (v/n), een (v/n) #> + edges from aa8edf0: #> [1] 1--2 2--3 3--4 4--5 1--5  g <- sna::rgraph(10, tprob = .2) |> network::as.network() #> Registered S3 methods overwritten by 'network': #>   method        from   #>   plot.network  snafun #>   print.network snafun add_vertex_attributes(g, \"naam\", value = data.frame(naam = 1:10)) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 17  #>     missing edges= 0  #>     non-missing edges= 17  #>  #>  Vertex attribute names:  #>     naam vertex.names  #>  #> No edge attributes  add_vertex_attributes(g, value = data.frame(naam = 1:10)) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 17  #>     missing edges= 0  #>     non-missing edges= 17  #>  #>  Vertex attribute names:  #>     naam vertex.names  #>  #> No edge attributes  add_vertex_attributes(g, value = data.frame(een = 10:19, twee = 20:29)) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 17  #>     missing edges= 0  #>     non-missing edges= 17  #>  #>  Vertex attribute names:  #>     een twee vertex.names  #>  #> No edge attributes  add_vertex_attributes(g, c(\"twee\", \"een\"),    value = data.frame(een = 10:19, twee = 20:29, drie = 30:39)) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 17  #>     missing edges= 0  #>     non-missing edges= 17  #>  #>  Vertex attribute names:  #>     een twee vertex.names  #>  #> No edge attributes"},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Add vertex names to a graph — add_vertex_names","title":"Add vertex names to a graph — add_vertex_names","text":"Add vertex names graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add vertex names to a graph — add_vertex_names","text":"","code":"add_vertex_names(x, value, vids = NULL)"},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add vertex names to a graph — add_vertex_names","text":"x graph object vertex attributes need added value vertex names set vids id's vertices names set. useful want set/correct names vertices. igraph objects, can number name vertices. network objects, numeric ID allowed. default NULL, selects vertices, order occur graph object.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add vertex names to a graph — add_vertex_names","text":"graph object new attributes added","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add vertex names to a graph — add_vertex_names","text":"Consistent API easily add vertex names graph class igraph network. vertex attribute holds vertex names called differently igraph network objects, use incorrect name attribute, new names recognized subsequent steps network analysis pipeline. function puts vertex names correct vertex attribute, need remember called.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/add_vertex_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add vertex names to a graph — add_vertex_names","text":"","code":"g <- snafun::create_random_graph(5, \"gnp\", p = .1, graph = \"igraph\") # there are no names yet snafun::extract_vertex_names(g)  # NULL #> NULL g <- snafun::add_vertex_names(g, LETTERS[5:1]) snafun::extract_vertex_names(g) # \"E\" \"D\" \"C\" \"B\" \"A\" #> [1] \"E\" \"D\" \"C\" \"B\" \"A\" g <- snafun::add_vertex_names(g, \"X\", vids = 2) snafun::extract_vertex_names(g) # \"E\" \"X\" \"C\" \"B\" \"A\" #> [1] \"E\" \"X\" \"C\" \"B\" \"A\" g <- snafun::add_vertex_names(g, c(\"Y\", \"Z\"), vids = c(\"C\", \"A\")) snafun::extract_vertex_names(g) # \"\"E\" \"X\" \"Y\" \"B\" \"Z\" #> [1] \"E\" \"X\" \"Y\" \"B\" \"Z\"  g <- snafun::create_random_graph(5, \"gnp\", p = .1, graph = \"network\") snafun::extract_vertex_names(g)  # 1 2 3 4 5 #> [1] 1 2 3 4 5 g <- snafun::add_vertex_names(g, LETTERS[5:1]) snafun::extract_vertex_names(g) # \"E\" \"D\" \"C\" \"B\" \"A\" #> [1] \"E\" \"D\" \"C\" \"B\" \"A\" g <- snafun::add_vertex_names(g, \"X\", vids = 2) snafun::extract_vertex_names(g) # \"E\" \"X\" \"C\" \"B\" \"A\" #> [1] \"E\" \"X\" \"C\" \"B\" \"A\" # network objects accept only numeric id's g <- snafun::add_vertex_names(g, c(\"Y\", \"Z\"), vids = c(3, 5)) snafun::extract_vertex_names(g) # \"\"E\" \"X\" \"Y\" \"B\" \"Z\" #> [1] \"E\" \"X\" \"Y\" \"B\" \"Z\""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":null,"dir":"Reference","previous_headings":"","what":"Contract multiple vertices into 1 new vertex — contract_vertices","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"contract_vertices combines set vertices one pseudo-vertex returns reduced network.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"","code":"contract_vertices(   g,   vertices,   method = c(\"min\", \"max\", \"union\", \"add\"),   attr = NULL,   new_name = \"set\",   out_as_igraph = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"g network igraph object adjacency matrix. vertices Numeric vertor indicating indeces vertices contracted. method Indication grouping criterion used.method=\"min\" indicates \"minimum\" criterion (edge values distances).method=\"max\" indicates \"maximum\" criterion (edge values non-cumulative strengths).method=\"add\" indicates \"addition\" criterion (edge values cumulative strengths).method=\"union\" indicates \"union\" criterion (edge values probability). default \"min\". See details examples. attr Either NULL character string giving edge attribute name used weights. NULL, unweighted network used calculate values resulting contracted network. NULL values given edge attribute included adjacency matrix. graph multiple edges, edge attribute arbitrarily chosen edge (multiple edges) included. new_name character, name new pseudovertex. specified, called \"set\". out_as_igraph logical. TRUE resulting network returned igraph object. FALSE, output returned adjacency matrix.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"igraph object adjacency matrix contracted network.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"function contracts set vertices pseudo-vertex returns network new vertex included (contracted vertices excluded). Weighted ties can used. requires either provide weighted adjacency matrix igraph object attribute used weights. Make sure attribute numeric. default, igraph object contains edge attribute called weight, attribute used weight default, unless different edge attribute explicitly specified attr. method specifies (possibly weighted) edges selected vertices vertices combined edges new pseudovertex vertices. default use min procedure. NOTE: g igraph object without vertex names, names added automatically (integeres, numbered 1). useful, clear --vertex contraction. Minimum Criterion: edge value group outside vertex measured minimal value among (nonzero) edge values vertex group outside vertex. Suggested edge values interpreted distances.Example: suppose vertex C distance 2 B C distance 1, according minimum criterion, distance C merged set AB 1. Note B C connected, algorithm takes distance C describe distance AB C. Maximum Criterion: edge value group outside vertex measured maximal value among (nonzero) edge values vertex group outside vertex. Suggested edge values interpreted non-cumulative strengths. Example: keep using example, figure now indicates strength tie. According maximum criterion, strength tie AB C 2. Addition Criterion: edge value group outside vertex measured sum edge values vertex group outside vertex. Suggested edge values cummulative strengths. Example: according addition criterion, strength tie AB C 3 Union Criterion: edge value group outside vertex measured probability least one path connecting group outside vertex. Suggested edge values probability. Example: suppose probability 0.2 reach C B probability 0.5 reach C, C can reached merged AB probability 1 - (1 - 0.2) * (1 - 0.5) = 0.6 according union criterion.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"Based contract function keyplayer package. implementation package general.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/contract_vertices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contract multiple vertices into 1 new vertex — contract_vertices","text":"","code":"# Create a 5x5 weighted and directed adjacency matrix, where edge values # represent the strength of tie W <- matrix(   c(0, 1, 3, 0, 0,     0, 0, 0, 4, 0,     1, 1, 0, 2, 0,     0, 0, 0, 0, 3,     0, 2, 0, 0, 0),     nrow = 5, ncol = 5, byrow = TRUE)  # If the strength is believed to be non-accumulative for a group of vertices, # it is proper to use the \"maximum\" criterion to contract vertex 2 and 3 contract_vertices(W, c(2, 3), \"max\") #> IGRAPH abfe72d UN-- 4 12 --  #> + attr: name (v/c) #> + edges from abfe72d (vertex names): #>  [1] 1--set 1--set 1--set 4--5   4--5   4--5   4--set 4--set 4--set 4--set #> [11] 5--set 5--set  # Transform the edge value to probability interpretaion P <- W * 0.2  # Contract vertex 2 and 3 using the \"union\" criterion as it is proper for # probability matrix input contract_vertices(P, c(2, 3), \"union\") #> IGRAPH ac001cc UN-- 4 0 --  #> + attr: name (v/c) #> + edges from ac001cc (vertex names):"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":null,"dir":"Reference","previous_headings":"","what":"Count dyad types — count_dyads","title":"Count dyad types — count_dyads","text":"Perform dyad census","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count dyad types — count_dyads","text":"","code":"count_dyads(x, echo = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count dyad types — count_dyads","text":"x graph data echo logical, result printed console? Default TRUE.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count dyad types — count_dyads","text":"data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count dyad types — count_dyads","text":"Perform dyad census network data. input, x can igraph, network, matrix. Mutual represents number reciprocated dyads Asymmetric represents number unreciprocated dyads. always 0 undirected graphs. Null represents number dyads without relation vertices output invisibly returned (echo TRUE) also printed console.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_dyads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count dyad types — count_dyads","text":"","code":"data(judge_net, package = \"snafun\") count_dyads(judge_net) #>  Mutual Null #>      94  686"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of edges in the graph — count_edges","title":"Number of edges in the graph — count_edges","text":"Count number edges graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of edges in the graph — count_edges","text":"","code":"count_edges(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of edges in the graph — count_edges","text":"x graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of edges in the graph — count_edges","text":"integer","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of edges in the graph — count_edges","text":"Returns number edges object class network igraph.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of edges in the graph — count_edges","text":"","code":"net <- igraph::random.graph.game(10, p.or.m = .15, type = \"gnp\") count_edges(net) #> [1] 10  net <- sna::rgraph(n = 10, tprob = 0.15) |> network::as.network() count_edges(net) #> [1] 19"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges_in_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Count edges in time interval — count_edges_in_interval","title":"Count edges in time interval — count_edges_in_interval","text":"Count number edges time interval","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges_in_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count edges in time interval — count_edges_in_interval","text":"","code":"count_edges_in_interval(x, start = NULL, end = NULL, number = 30)"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges_in_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count edges in time interval — count_edges_in_interval","text":"x object class networkDynamic start start time calculation end end time calculation number number intervals start end","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges_in_interval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count edges in time interval — count_edges_in_interval","text":"vector counts","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_edges_in_interval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count edges in time interval — count_edges_in_interval","text":"Counts many edges happen (ie. start within interval) time period (start, end). time period split number intervals, equal time length. , start = 0, end = 10, number = 2, time period divided time intervals 0 (inclusive) 5 (exclusive) 5 (inclusive) 10 (exclusive). count_edges_in_interval counts number edges start interval. count_unique_edges_in_interval counts number unique edges start interval, edges occur multiple times counted .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":null,"dir":"Reference","previous_headings":"","what":"Count triad types — count_triads","title":"Count triad types — count_triads","text":"Perform trad census","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count triad types — count_triads","text":"","code":"count_triads(x, echo = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count triad types — count_triads","text":"x graph data echo logical, result printed console? Default TRUE.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count triad types — count_triads","text":"data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count triad types — count_triads","text":"Perform trad census network data. input, x can igraph, network, matrix. output data.frame countains counts 16 triad types. output invisibly returned (echo TRUE) also printed console.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_triads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count triad types — count_triads","text":"","code":"data(judge_net, package = \"snafun\") count_triads(judge_net) #>   003 012  102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210 300 #>  6703   0 2880    0    0    0    0    0    0    0 199    0    0    0   0  98"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_unique_edges_in_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Count unique edges in time interval — count_unique_edges_in_interval","title":"Count unique edges in time interval — count_unique_edges_in_interval","text":"Count number unique edges time interval","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_unique_edges_in_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count unique edges in time interval — count_unique_edges_in_interval","text":"","code":"count_unique_edges_in_interval(   x,   start = NULL,   end = NULL,   number = 30,   directed = network::is.directed(x) )"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_unique_edges_in_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count unique edges in time interval — count_unique_edges_in_interval","text":"x object class networkDynamic start start time calculation end end time calculation number number intervals start end directed logical, graph treated directed? Defaults value directed encoded inside x .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_unique_edges_in_interval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count unique edges in time interval — count_unique_edges_in_interval","text":"vector counts","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_unique_edges_in_interval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count unique edges in time interval — count_unique_edges_in_interval","text":"Counts many edges happen (ie. start within interval) time period (start, end). toime period split number intervals, equal time length. , start = 0, end = 10, number = 2, time period divided time intervals 0 (inclusive) 5 (exclusive) 5 (inclusive) 10 (exclusive). count_edges_in_interval counts number edges start interval. count_unique_edges_in_interval counts number unique edges start interval, edges occur multiple times counted .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of vertices in the graph — count_vertices","title":"Number of vertices in the graph — count_vertices","text":"Count number vertices graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of vertices in the graph — count_vertices","text":"","code":"count_vertices(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of vertices in the graph — count_vertices","text":"x graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of vertices in the graph — count_vertices","text":"integer","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of vertices in the graph — count_vertices","text":"Returns number vertices object class network igraph.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/count_vertices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of vertices in the graph — count_vertices","text":"","code":"net <- igraph::random.graph.game(10, p.or.m = .15, type = \"gnp\") count_vertices(net) #> [1] 10  net <- sna::rgraph(n = 10, tprob = 0.15) |> network::as.network() count_vertices(net) #> [1] 10"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_bipartite.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a random bipartite network — create_bipartite","title":"Create a random bipartite network — create_bipartite","text":"Generate bipartite graphs using Erdos-Renyi model","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_bipartite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a random bipartite network — create_bipartite","text":"","code":"create_bipartite(   n_type1,   n_type2,   strategy = c(\"gnp\", \"gnm\"),   p,   m,   directed = FALSE,   mode = c(\"out\", \"in\", \"all\"),   graph = c(\"igraph\", \"network\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_bipartite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a random bipartite network — create_bipartite","text":"n_type1 integer, number vertices first type n_type2 integer, number vertices first type strategy Character scalar, type graph, ‘gnp’ creates $G(n,p)$ graph, ‘gnm’ creates $G(n,m)$ graph. See details . p probability $G(n,p)$ graphs. given $G(n,m)$ graphs. m integer, number edges $G(n,p)$ graphs. given $G(n,p)$ graphs. directed logical, whether create directed graph mode Character scalar, specifies direct edges directed graphs. ‘’, directed edges point bottom vertices top vertices. ‘’, edges point top vertices bottom vertices. ‘’ ‘’ generate mutual edges. argument ‘’, edge direction considered independently mutual edges might generated. argument ignored undirected graphs. graph character, type graph generated: igraph network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_bipartite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a random bipartite network — create_bipartite","text":"graph class network igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_bipartite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a random bipartite network — create_bipartite","text":"Generate random bipartite network, either igraph network object. using strategy 'gnp', bipartite network generated edge probability 'p' occuring. means consecutive runs algorithm usually result graphs different numbers edges. using strategy 'gnm', bipartite network generated exactly 'm' edges. means consecutive runs algorithm result graphs number edges (occur different vertices). generation done sample_bipartite function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"Generate network pre-specified dyad census","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"","code":"create_census_graph(   n_vertices,   mut = 0.25,   asym = 0.5,   null = 0.25,   method = c(\"probability\", \"exact\"),   graph = c(\"igraph\", \"network\", \"matrix\", \"edgelist\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"n_vertices number vertices graph. mut method == \"probability\", probability obtaining mutual dyad; otherwise, number mutual dyads. asym method == \"probability\", probability obtaining asymmetric dyad; otherwise, number asymmmetric dyads. null method == \"probability\", probability obtaining null dyad; otherwise, number null dyads. method either \"probability\" \"exact\", see details graph output class, either \"igraph\", \"network\", \"matrix\", \"edgelist\"","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"graph desired MAN property","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"Two approaches offered, exact method probability method. method == \"probability\", graph generated based independent draws multinomial distribution. rarely yield graph exact probabilities, large graphs get quite close. values passed function add 1, rescaled (message printed console). method == \"exact\", graph generated exact MAN count, long add actualnumber edges graph. function largely builds rguman function. main difference allow multiple classes output generate single conditioned graph. large number MAN-conditioned graphs generated, rguman potentially efficient.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_census_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Dyad Census-Conditioned Random Graph — create_census_graph","text":"","code":"create_census_graph(10, mut = 45, asym = 0, null = 0, method = \"exact\") #> IGRAPH ae07064 U--- 10 45 --  #> + edges from ae07064: #>  [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--10 2-- 3 2-- 4 2-- 5 #> [13] 2-- 6 2-- 7 2-- 8 2-- 9 2--10 3-- 4 3-- 5 3-- 6 3-- 7 3-- 8 3-- 9 3--10 #> [25] 4-- 5 4-- 6 4-- 7 4-- 8 4-- 9 4--10 5-- 6 5-- 7 5-- 8 5-- 9 5--10 6-- 7 #> [37] 6-- 8 6-- 9 6--10 7-- 8 7-- 9 7--10 8-- 9 8--10 9--10 # empty graph create_census_graph(10, mut = 0, asym = 0, null = 45, method = \"exact\") #> IGRAPH ae081ee U--- 10 0 --  #> + edges from ae081ee: create_census_graph(10, mut = 0, asym = 0, null = 45, method = \"probability\") #> Probabilities did not add to 1, they have been rescaled #> IGRAPH ae08bb1 U--- 10 0 --  #> + edges from ae08bb1: create_census_graph(10, mut = 0, asym = 0, null = 1, method = \"probability\") #> IGRAPH ae096d6 U--- 10 0 --  #> + edges from ae096d6:  create_census_graph(10, mut = 0, asym = 45, null = 0, method = \"exact\") |>    snafun::count_dyads() #>  Mutual Asymmetric Null #>       0         45    0  # will be rescaled create_census_graph(10, mut = 0, asym = 45, null = 0, method = \"probability\") |>    snafun::count_dyads() #> Probabilities did not add to 1, they have been rescaled #>  Mutual Asymmetric Null #>       0         45    0  create_census_graph(10, mut = 0, asym = 1, null = 0, method = \"probability\") |>    snafun::count_dyads() #>  Mutual Asymmetric Null #>       0         45    0  create_census_graph(10, mut = .25, asym = .30, null = .45, method = \"probability\") |>    snafun::count_dyads() #>  Mutual Asymmetric Null #>      15         14   16  create_census_graph(10, method = \"probability\", graph = \"igraph\") #> IGRAPH ae0daab D--- 10 42 --  #> + edges from ae0daab: #>  [1]  1-> 2  1-> 3  1-> 4  1-> 7  1-> 9  2-> 3  2-> 6  2-> 7  2-> 8  2->10 #> [11]  3-> 2  3-> 8  4-> 1  4-> 5  4->10  5-> 2  5-> 4  5-> 6  5-> 7  5-> 9 #> [21]  6-> 1  6-> 2  6-> 4  6-> 5  6-> 8  6->10  7-> 1  7-> 3  7-> 9  7->10 #> [31]  8-> 2  8-> 3  8-> 4  8-> 7  9-> 2  9-> 4  9-> 8 10-> 2 10-> 4 10-> 5 #> [41] 10-> 8 10-> 9 create_census_graph(10, method = \"probability\", graph = \"network\") #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 46  #>     missing edges= 0  #>     non-missing edges= 46  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes create_census_graph(10, method = \"probability\", graph = \"edgelist\") #>    from to #> 1     1  3 #> 2     1  4 #> 3     1  9 #> 4     2  1 #> 5     2  3 #> 6     2  4 #> 7     2  5 #> 8     2  8 #> 9     2  9 #> 10    3  1 #> 11    3  2 #> 12    3  4 #> 13    3  5 #> 14    3  6 #> 15    3  7 #> 16    3  9 #> 17    3 10 #> 18    4  2 #> 19    4  3 #> 20    4  7 #> 21    4  8 #> 22    5  2 #> 23    5  3 #> 24    5  7 #> 25    5  8 #> 26    5  9 #> 27    5 10 #> 28    6  1 #> 29    6  2 #> 30    6  3 #> 31    6  5 #> 32    6  7 #> 33    6  8 #> 34    6  9 #> 35    7  1 #> 36    7  2 #> 37    7  3 #> 38    7  4 #> 39    7  5 #> 40    7  8 #> 41    7 10 #> 42    8  1 #> 43    8  5 #> 44    8  7 #> 45    9  1 #> 46    9  2 #> 47    9  4 #> 48    9  6 #> 49    9  7 #> 50    9  8 #> 51   10  5 #> 52   10  7 #> 53   10  9 create_census_graph(10, method = \"probability\", graph = \"matrix\") #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    0    0    0    1    1    1    1    1     0 #>  [2,]    1    0    0    0    0    1    0    0    0     1 #>  [3,]    1    1    0    0    0    1    1    0    1     1 #>  [4,]    1    1    1    0    1    0    0    1    1     1 #>  [5,]    0    1    1    0    0    1    1    1    0     1 #>  [6,]    1    0    0    1    0    0    0    1    0     0 #>  [7,]    0    0    0    0    1    0    0    0    0     1 #>  [8,]    1    0    1    0    1    1    0    0    0     0 #>  [9,]    0    0    0    0    0    0    1    1    0     0 #> [10,]    0    1    1    1    1    1    1    1    0     0"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graph with a given community structure — create_community_graph","title":"Create a graph with a given community structure — create_community_graph","text":"Generates random network probabilistic community structure","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graph with a given community structure — create_community_graph","text":"","code":"create_community_graph(   communitySizes = c(10, 20, 30),   p_intra = c(0.3, 0.2, 0.3),   p_inter = 0.2,   p_del = 0,   graph = c(\"igraph\", \"network\", \"matrix\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graph with a given community structure — create_community_graph","text":"communitySizes vector, number communities equals number vertices vector. p_intra vector probability vertex randomly linked vertices community. p_inter probability vertex randomly linked vertices communities. p_del proportion links randomly deleted. graph output class, either \"igraph\" (default), \"network\", \"matrix\"","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graph with a given community structure — create_community_graph","text":"graph given community structure","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a graph with a given community structure — create_community_graph","text":"researcher specifies size community probabilities vertices within community. addition, overall probability edges vertices different communities specified fraction edges removed graph. internal code largely based upon network.simu, wfg package, implements simulation networks framework Girvan Newman.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_community_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a graph with a given community structure — create_community_graph","text":"","code":"create_community_graph(graph = \"matrix\") #> $graph #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    0    0    0    0    0    0    1    1     1     0     0     0 #>  [2,]    0    0    0    0    0    1    0    0    0     0     0     1     0 #>  [3,]    0    0    0    0    1    0    0    1    0     1     0     0     0 #>  [4,]    0    0    0    0    0    1    0    1    0     0     0     0     0 #>  [5,]    0    0    1    0    0    0    1    0    0     1     0     0     0 #>  [6,]    0    1    0    1    0    0    0    1    0     0     0     0     0 #>  [7,]    0    0    0    0    1    0    0    0    0     0     0     0     0 #>  [8,]    1    0    1    1    0    1    0    0    1     1     1     0     0 #>  [9,]    1    0    0    0    0    0    0    1    0     0     0     0     1 #> [10,]    1    0    1    0    1    0    0    1    0     0     1     1     1 #> [11,]    0    0    0    0    0    0    0    1    0     1     0     1     0 #> [12,]    0    1    0    0    0    0    0    0    0     1     1     0     0 #> [13,]    0    0    0    0    0    0    0    0    1     1     0     0     0 #> [14,]    0    1    1    0    0    0    0    0    0     0     0     0     0 #> [15,]    0    0    0    0    0    1    0    0    1     1     0     0     0 #> [16,]    0    0    1    0    0    1    0    0    1     0     0     0     0 #> [17,]    0    0    1    1    0    0    0    1    0     0     0     0     0 #> [18,]    0    0    0    0    1    0    0    0    0     0     1     0     1 #> [19,]    0    0    0    0    0    1    0    1    1     0     0     1     0 #> [20,]    0    0    0    0    1    0    1    0    0     1     0     1     0 #> [21,]    0    0    0    0    0    0    1    0    1     0     0     0     0 #> [22,]    0    1    0    0    0    1    0    0    1     1     0     0     0 #> [23,]    0    0    0    1    0    0    0    0    0     0     1     0     0 #> [24,]    0    0    1    1    0    1    0    0    1     0     1     0     0 #> [25,]    0    0    0    0    0    0    0    0    0     1     0     1     1 #> [26,]    0    0    0    1    0    0    0    0    1     0     0     0     0 #> [27,]    0    0    1    0    1    0    0    0    0     0     0     0     0 #> [28,]    1    0    0    0    0    0    1    0    0     0     1     0     0 #> [29,]    0    0    0    0    0    0    0    0    0     1     0     0     1 #> [30,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [31,]    0    0    0    0    0    0    0    1    0     1     0     1     0 #> [32,]    0    1    1    0    0    0    0    1    0     1     1     0     1 #> [33,]    0    0    0    0    0    0    0    0    1     1     0     0     0 #> [34,]    0    1    1    0    1    0    0    0    0     0     0     0     0 #> [35,]    1    0    0    1    0    0    1    1    0     0     1     0     0 #> [36,]    0    1    0    1    0    0    1    1    0     1     0     0     0 #> [37,]    0    0    0    0    0    1    1    0    0     0     0     0     0 #> [38,]    1    1    0    0    0    0    0    0    0     0     1     0     0 #> [39,]    1    1    0    0    0    0    1    0    0     0     0     0     0 #> [40,]    0    0    0    0    0    0    0    1    0     1     0     0     0 #> [41,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [42,]    0    0    0    0    0    0    1    1    0     0     0     0     0 #> [43,]    1    0    0    0    0    0    0    0    0     0     1     0     0 #> [44,]    1    0    1    0    1    0    0    0    0     0     0     1     0 #> [45,]    1    0    1    0    0    0    1    1    0     0     0     0     0 #> [46,]    0    0    0    0    0    0    0    0    0     1     1     0     1 #> [47,]    0    0    1    0    0    0    0    0    0     0     0     0     0 #> [48,]    0    1    0    0    1    0    0    0    0     0     0     0     0 #> [49,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [50,]    0    0    0    0    0    1    0    0    1     0     0     0     0 #> [51,]    1    0    0    0    0    0    0    0    0     0     0     1     0 #> [52,]    0    0    0    0    1    0    0    0    0     0     1     1     0 #> [53,]    0    0    0    1    0    0    0    1    0     0     0     1     0 #> [54,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [55,]    0    0    0    0    0    0    0    0    0     0     0     0     1 #> [56,]    0    0    0    0    0    1    0    0    0     0     0     0     0 #> [57,]    0    0    0    1    0    0    0    0    1     0     0     0     0 #> [58,]    1    0    1    0    0    0    0    0    1     0     0     0     1 #> [59,]    1    0    0    0    1    0    0    0    0     0     0     0     0 #> [60,]    1    0    0    0    0    0    0    0    0     0     0     0     0 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #>  [1,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [2,]     1     0     0     0     0     0     0     0     1     0     0     0 #>  [3,]     1     0     1     1     0     0     0     0     0     0     1     0 #>  [4,]     0     0     0     1     0     0     0     0     0     1     1     0 #>  [5,]     0     0     0     0     1     0     1     0     0     0     0     0 #>  [6,]     0     1     1     0     0     1     0     0     1     0     1     0 #>  [7,]     0     0     0     0     0     0     1     1     0     0     0     0 #>  [8,]     0     0     0     1     0     1     0     0     0     0     0     0 #>  [9,]     0     1     1     0     0     1     0     1     1     0     1     0 #> [10,]     0     1     0     0     0     0     1     0     1     0     0     1 #> [11,]     0     0     0     0     1     0     0     0     0     1     1     0 #> [12,]     0     0     0     0     0     1     1     0     0     0     0     1 #> [13,]     0     0     0     0     1     0     0     0     0     0     0     1 #> [14,]     0     0     0     1     1     0     0     0     0     0     0     0 #> [15,]     0     0     0     1     0     0     0     0     0     0     0     0 #> [16,]     0     0     0     0     0     1     1     0     0     0     1     1 #> [17,]     1     1     0     0     0     1     0     0     1     0     0     0 #> [18,]     1     0     0     0     0     1     0     0     1     0     0     0 #> [19,]     0     0     1     1     1     0     1     0     0     0     0     0 #> [20,]     0     0     1     0     0     1     0     0     1     0     1     0 #> [21,]     0     0     0     0     0     0     0     0     1     0     0     1 #> [22,]     0     0     0     1     1     0     1     1     0     0     0     0 #> [23,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [24,]     0     0     1     0     0     0     1     0     0     0     0     0 #> [25,]     0     0     1     0     0     0     0     1     0     0     0     0 #> [26,]     0     0     0     0     0     0     0     1     0     1     0     1 #> [27,]     1     0     0     0     0     1     0     0     1     0     0     0 #> [28,]     0     0     0     1     0     0     0     1     0     0     0     0 #> [29,]     0     0     0     0     0     0     0     1     0     1     0     0 #> [30,]     0     0     0     1     0     0     1     0     1     0     0     0 #> [31,]     0     0     0     1     0     1     0     0     0     1     0     0 #> [32,]     0     0     0     0     0     0     0     0     1     0     0     0 #> [33,]     0     0     0     0     0     0     1     0     1     0     0     0 #> [34,]     0     0     0     0     0     0     0     1     1     1     0     1 #> [35,]     0     0     1     0     0     0     0     0     1     0     0     0 #> [36,]     0     0     0     0     0     1     0     1     0     0     0     0 #> [37,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [38,]     0     0     1     0     0     0     0     1     0     1     0     0 #> [39,]     0     0     0     0     1     0     0     0     0     0     1     1 #> [40,]     1     1     0     0     0     0     0     0     0     0     0     1 #> [41,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [42,]     0     1     0     0     0     0     1     0     0     0     0     0 #> [43,]     0     1     1     0     1     0     0     1     1     0     1     0 #> [44,]     1     0     1     0     0     0     1     0     0     0     0     0 #> [45,]     0     0     1     1     0     0     1     0     0     0     0     0 #> [46,]     0     0     0     0     0     1     0     0     0     0     1     0 #> [47,]     0     0     0     1     1     0     1     0     0     0     0     0 #> [48,]     0     1     0     0     0     1     1     0     1     0     0     0 #> [49,]     0     0     0     0     0     0     0     0     0     0     1     0 #> [50,]     0     0     0     0     0     0     1     0     0     1     0     0 #> [51,]     0     0     0     0     0     1     0     0     0     0     0     0 #> [52,]     0     0     0     1     0     1     0     0     0     1     0     1 #> [53,]     0     0     0     0     0     0     1     0     0     1     1     0 #> [54,]     0     0     0     0     0     0     0     0     0     0     1     0 #> [55,]     1     0     0     0     0     0     0     0     0     0     0     1 #> [56,]     0     0     0     0     0     0     0     0     1     0     0     0 #> [57,]     1     0     1     0     0     0     0     1     0     0     0     0 #> [58,]     0     0     0     0     0     0     0     0     0     0     0     1 #> [59,]     0     0     1     0     1     0     1     0     0     1     0     0 #> [60,]     1     0     1     0     1     0     0     1     0     0     0     0 #>       [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] #>  [1,]     0     0     1     0     0     0     0     0     0     1     0     0 #>  [2,]     0     0     0     0     0     0     1     0     1     0     1     0 #>  [3,]     0     1     0     0     0     0     1     0     1     0     0     0 #>  [4,]     1     0     0     0     0     0     0     0     0     1     1     0 #>  [5,]     0     1     0     0     0     0     0     0     1     0     0     0 #>  [6,]     0     0     0     0     0     0     0     0     0     0     0     1 #>  [7,]     0     0     1     0     0     0     0     0     0     1     1     1 #>  [8,]     0     0     0     0     0     1     1     0     0     1     1     0 #>  [9,]     1     0     0     0     0     0     0     1     0     0     0     0 #> [10,]     0     0     0     1     0     1     1     1     0     0     1     0 #> [11,]     0     0     1     0     0     0     1     0     0     1     0     0 #> [12,]     0     0     0     0     0     1     0     0     0     0     0     0 #> [13,]     0     0     0     1     0     0     1     0     0     0     0     0 #> [14,]     0     1     0     0     0     0     0     0     0     0     0     0 #> [15,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [16,]     0     0     0     0     0     0     0     0     0     1     0     0 #> [17,]     0     0     1     0     1     1     0     0     0     0     0     0 #> [18,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [19,]     0     1     0     0     0     1     0     0     0     0     1     0 #> [20,]     0     0     0     0     1     0     0     1     0     0     0     0 #> [21,]     1     0     1     1     0     0     0     0     1     0     1     0 #> [22,]     0     1     0     0     1     0     1     1     1     1     0     0 #> [23,]     1     0     0     1     0     1     0     0     1     0     0     0 #> [24,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [25,]     1     0     0     0     0     0     0     0     1     0     0     0 #> [26,]     0     0     0     1     0     0     1     0     0     0     1     0 #> [27,]     0     0     0     0     0     0     0     1     0     0     0     0 #> [28,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [29,]     1     0     0     0     0     0     0     0     0     0     0     0 #> [30,]     0     0     0     0     0     0     1     1     0     0     1     0 #> [31,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [32,]     1     0     0     0     1     0     0     1     0     1     0     1 #> [33,]     0     1     0     0     1     0     1     0     0     1     0     0 #> [34,]     0     0     0     0     0     0     0     0     0     1     0     0 #> [35,]     0     0     0     0     0     0     1     1     1     0     0     1 #> [36,]     1     0     0     0     1     0     0     0     0     0     0     1 #> [37,]     0     0     0     0     0     0     1     0     0     1     1     0 #> [38,]     1     0     0     0     0     1     0     0     0     0     0     0 #> [39,]     0     0     1     0     1     1     1     0     0     1     0     0 #> [40,]     0     0     0     1     0     0     0     0     0     1     0     0 #> [41,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [42,]     1     0     1     0     1     0     1     0     0     0     0     1 #> [43,]     1     1     0     0     1     1     0     0     1     1     0     0 #> [44,]     0     0     0     1     0     0     1     1     0     0     1     0 #> [45,]     0     0     0     0     1     0     0     0     0     1     0     0 #> [46,]     0     1     0     0     1     0     0     0     0     0     0     0 #> [47,]     0     0     0     0     1     0     0     0     1     1     0     0 #> [48,]     0     0     0     0     0     0     0     0     1     1     1     0 #> [49,]     0     1     0     0     1     1     0     0     0     0     0     0 #> [50,]     0     0     0     0     0     0     0     1     0     0     0     0 #> [51,]     0     0     0     1     0     0     1     0     0     0     0     0 #> [52,]     1     0     0     0     0     0     1     1     0     0     0     0 #> [53,]     0     0     0     1     0     0     0     0     0     0     1     1 #> [54,]     1     1     0     0     0     0     0     0     0     0     1     0 #> [55,]     0     0     0     1     0     0     1     0     1     0     0     1 #> [56,]     0     0     0     0     0     0     1     1     0     1     0     1 #> [57,]     0     0     0     0     0     0     0     0     0     0     0     1 #> [58,]     0     0     0     0     0     0     0     0     1     0     0     0 #> [59,]     0     0     1     0     0     0     1     0     0     0     0     0 #> [60,]     1     0     0     0     0     0     0     0     0     0     0     0 #>       [,38] [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] #>  [1,]     1     1     0     0     0     1     1     1     0     0     0     0 #>  [2,]     1     1     0     0     0     0     0     0     0     0     1     0 #>  [3,]     0     0     0     0     0     0     1     1     0     1     0     0 #>  [4,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [5,]     0     0     0     0     0     0     1     0     0     0     1     0 #>  [6,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [7,]     0     1     0     0     1     0     0     1     0     0     0     0 #>  [8,]     0     0     1     0     1     0     0     1     0     0     0     0 #>  [9,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [10,]     0     0     1     0     0     0     0     0     1     0     0     0 #> [11,]     1     0     0     0     0     1     0     0     1     0     0     0 #> [12,]     0     0     0     0     0     0     1     0     0     0     0     0 #> [13,]     0     0     0     0     0     0     0     0     1     0     0     0 #> [14,]     0     0     1     0     0     0     1     0     0     0     0     0 #> [15,]     0     0     1     0     1     1     0     0     0     0     1     0 #> [16,]     1     0     0     0     0     1     1     1     0     0     0     0 #> [17,]     0     0     0     0     0     0     0     1     0     1     0     0 #> [18,]     0     1     0     0     0     1     0     0     0     1     0     0 #> [19,]     0     0     0     0     0     0     0     0     1     0     1     0 #> [20,]     0     0     0     0     1     0     1     1     0     1     1     0 #> [21,]     1     0     0     0     0     1     0     0     0     0     0     0 #> [22,]     0     0     0     0     0     1     0     0     0     0     1     0 #> [23,]     1     0     0     0     0     0     0     0     0     0     0     0 #> [24,]     0     1     0     0     0     1     0     0     1     0     0     1 #> [25,]     0     1     1     0     0     0     0     0     0     0     0     0 #> [26,]     1     0     0     0     1     1     0     0     0     0     0     0 #> [27,]     0     0     0     0     0     1     0     0     1     0     0     1 #> [28,]     0     1     0     0     1     0     0     0     0     0     0     0 #> [29,]     0     0     1     0     0     0     1     0     0     0     0     0 #> [30,]     0     1     0     0     1     1     0     1     1     1     0     1 #> [31,]     1     1     0     0     0     1     0     0     0     0     0     1 #> [32,]     0     1     0     0     1     0     1     0     0     0     0     0 #> [33,]     0     0     0     0     0     0     1     0     0     0     0     0 #> [34,]     0     0     0     0     0     1     0     0     0     1     1     0 #> [35,]     0     1     1     0     0     1     0     1     0     1     1     0 #> [36,]     0     0     0     0     0     0     1     0     0     0     1     0 #> [37,]     0     0     0     0     1     0     0     0     0     0     0     0 #> [38,]     0     0     0     0     0     0     0     0     0     1     1     0 #> [39,]     0     0     0     1     0     1     0     0     0     1     0     0 #> [40,]     0     0     0     1     0     1     0     0     0     0     0     1 #> [41,]     0     1     1     0     1     0     1     0     0     0     1     1 #> [42,]     0     0     0     1     0     1     0     0     0     0     0     0 #> [43,]     0     1     1     0     1     0     0     0     0     0     1     1 #> [44,]     0     0     0     1     0     0     0     0     0     1     0     0 #> [45,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [46,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [47,]     1     1     0     0     0     0     1     0     0     0     1     0 #> [48,]     1     0     0     1     0     1     0     0     0     1     0     1 #> [49,]     0     0     1     1     0     1     0     0     0     0     1     0 #> [50,]     0     1     1     1     0     0     0     0     0     1     1     1 #> [51,]     1     1     1     1     1     0     0     0     0     1     0     0 #> [52,]     1     0     0     0     0     0     0     1     1     1     0     0 #> [53,]     1     0     0     1     1     1     0     0     1     1     1     0 #> [54,]     1     0     1     0     0     0     0     0     1     0     1     1 #> [55,]     0     0     0     1     0     0     0     0     0     1     1     0 #> [56,]     1     1     0     1     0     0     0     0     0     0     0     0 #> [57,]     0     1     0     1     0     0     0     0     1     0     0     0 #> [58,]     0     1     0     0     0     0     1     1     0     1     1     1 #> [59,]     0     1     0     0     0     0     0     0     1     1     1     0 #> [60,]     0     0     0     0     1     0     0     0     1     0     0     0 #>       [,50] [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] #>  [1,]     0     1     0     0     0     0     0     0     1     1     1 #>  [2,]     0     0     0     0     0     0     0     0     0     0     0 #>  [3,]     0     0     0     0     0     0     0     0     1     0     0 #>  [4,]     0     0     0     1     0     0     0     1     0     0     0 #>  [5,]     0     0     1     0     0     0     0     0     0     1     0 #>  [6,]     1     0     0     0     0     0     1     0     0     0     0 #>  [7,]     0     0     0     0     0     0     0     0     0     0     0 #>  [8,]     0     0     0     1     0     0     0     0     0     0     0 #>  [9,]     1     0     0     0     0     0     0     1     1     0     0 #> [10,]     0     0     0     0     0     0     0     0     0     0     0 #> [11,]     0     0     1     0     0     0     0     0     0     0     0 #> [12,]     0     1     1     1     0     0     0     0     0     0     0 #> [13,]     0     0     0     0     0     1     0     0     1     0     0 #> [14,]     0     0     0     0     0     1     0     1     0     0     1 #> [15,]     0     0     0     0     0     0     0     0     0     0     0 #> [16,]     0     0     0     0     0     0     0     1     0     1     1 #> [17,]     0     0     1     0     0     0     0     0     0     0     0 #> [18,]     0     0     0     0     0     0     0     0     0     1     1 #> [19,]     0     1     1     0     0     0     0     0     0     0     0 #> [20,]     1     0     0     1     0     0     0     0     0     1     0 #> [21,]     0     0     0     0     0     0     0     1     0     0     1 #> [22,]     0     0     0     0     0     0     1     0     0     0     0 #> [23,]     1     0     1     1     0     0     0     0     0     1     0 #> [24,]     0     0     0     1     1     0     0     0     0     0     0 #> [25,]     0     0     1     0     0     1     0     0     1     0     0 #> [26,]     0     0     1     0     1     0     0     0     0     0     1 #> [27,]     0     0     0     0     1     0     0     0     0     0     0 #> [28,]     0     0     0     0     0     0     0     0     0     1     0 #> [29,]     0     1     0     1     0     1     0     0     0     0     0 #> [30,]     0     0     0     0     0     0     0     0     0     0     0 #> [31,]     0     0     0     0     0     0     0     0     0     0     0 #> [32,]     0     1     1     0     0     1     1     0     0     1     0 #> [33,]     1     0     1     0     0     0     1     0     0     0     0 #> [34,]     0     0     0     0     0     1     0     0     1     0     0 #> [35,]     0     0     0     0     0     0     1     0     0     0     0 #> [36,]     0     0     0     1     1     0     0     0     0     0     0 #> [37,]     0     0     0     1     0     1     1     1     0     0     0 #> [38,]     0     1     1     1     1     0     1     0     0     0     0 #> [39,]     1     1     0     0     0     0     1     1     1     1     0 #> [40,]     1     1     0     0     1     0     0     0     0     0     0 #> [41,]     1     1     0     1     0     1     1     1     0     0     0 #> [42,]     0     1     0     1     0     0     0     0     0     0     1 #> [43,]     0     0     0     1     0     0     0     0     0     0     0 #> [44,]     0     0     0     0     0     0     0     0     1     0     0 #> [45,]     0     0     1     0     0     0     0     0     1     0     0 #> [46,]     0     0     1     1     1     0     0     1     0     1     1 #> [47,]     1     1     1     1     0     1     0     0     1     1     0 #> [48,]     1     0     0     1     1     1     0     0     1     1     0 #> [49,]     1     0     0     0     1     0     0     0     1     0     0 #> [50,]     0     0     1     0     1     1     1     0     1     0     0 #> [51,]     0     0     1     0     0     0     0     1     0     0     0 #> [52,]     1     1     0     0     0     0     0     0     1     0     0 #> [53,]     0     0     0     0     0     0     0     1     0     1     0 #> [54,]     1     0     0     0     0     0     0     1     0     0     0 #> [55,]     1     0     0     0     0     0     0     0     0     0     0 #> [56,]     1     0     0     0     0     0     0     0     0     0     1 #> [57,]     0     1     0     1     1     0     0     0     0     0     0 #> [58,]     1     0     1     0     0     0     0     0     0     0     0 #> [59,]     0     0     0     1     0     0     0     0     0     0     1 #> [60,]     0     0     0     0     0     0     1     0     0     1     0 #>  #> $group #>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 #> [39] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #>  create_community_graph(c(10, 10, 15), p_intra = c(.25, .35, .45),     p_inter = .2, p_del = .2, graph = \"network\") #> $graph #>  Network attributes: #>   vertices = 35  #>   directed = FALSE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 112  #>     missing edges= 0  #>     non-missing edges= 112  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes #>  #> $group #>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #>  create_community_graph(c(30, 30, 30), p_intra = c(.4, .2, .15),     p_inter = .4, p_del = .4) #> $graph #> IGRAPH ae59a25 U--- 90 836 --  #> + edges from ae59a25: #>   [1] 1-- 2 1-- 4 1-- 5 1-- 6 1--10 1--15 1--19 1--26 1--27 1--30 1--32 1--35 #>  [13] 1--38 1--40 1--41 1--44 1--46 1--49 1--51 1--55 1--58 1--61 1--65 1--70 #>  [25] 1--72 1--79 1--85 1--86 1--87 2-- 8 2--12 2--16 2--18 2--19 2--21 2--24 #>  [37] 2--28 2--31 2--32 2--38 2--40 2--44 2--48 2--55 2--69 2--72 2--78 2--80 #>  [49] 2--82 2--85 2--89 3--11 3--17 3--24 3--31 3--33 3--34 3--35 3--37 3--39 #>  [61] 3--40 3--42 3--45 3--47 3--48 3--49 3--50 3--53 3--54 3--55 3--58 3--63 #>  [73] 3--64 3--65 3--66 3--75 3--76 3--78 3--82 4-- 5 4-- 9 4--12 4--15 4--21 #>  [85] 4--23 4--26 4--28 4--31 4--37 4--46 4--50 4--51 4--57 4--60 4--62 4--63 #>  [97] 4--70 4--74 4--77 4--79 4--81 4--83 5--15 5--16 5--19 5--24 5--28 5--39 #> + ... omitted several edges #>  #> $group #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 #> [39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #> [77] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #>  if (FALSE) { # \\dontrun{ g <- create_community_graph(c(5, 5, 5), p_intra = c(.75, .75, .70),     p_inter = .15, p_del = .2) g$graph <- snafun::add_vertex_attributes(g$graph, \"color\", g$group) snafun::plot(g$graph) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graph with strict components — create_components_graph","title":"Create a graph with strict components — create_components_graph","text":"Create graph consisting separate components","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graph with strict components — create_components_graph","text":"","code":"create_components_graph(   n_vertices,   directed = FALSE,   membership = NULL,   graph = c(\"igraph\", \"network\", \"matrix\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graph with strict components — create_components_graph","text":"n_vertices single number one-mode graph, vector two numbers two-mode graph directed logical, connections directed (default) membership numeric vector, group membership vertex graph output class, either \"igraph\" (default), \"network\", \"matrix\"","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graph with strict components — create_components_graph","text":"graph specified class","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a graph with strict components — create_components_graph","text":"Creates graph vertices () vertices connected member ame component. n_vertices length 1, one-mode graph created. component internal density 1 connections components. n_vertices length 1, two-mode graph created. edge two vertices occurs vertices dissimilar type thesame component. Regardless choice directed, ensuing graph undirected definition. vertices final graph numerically named, 1 n_vertices one-mode graphs 1 sum(n_vertices) two-mode graphs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create a graph with strict components — create_components_graph","text":"Much code comes create_components manynet package.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_components_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a graph with strict components — create_components_graph","text":"","code":"create_components_graph(10, membership = c(1,1,1,2,2,2,3,3,3,3)) #> IGRAPH aea38ed UN-- 10 12 --  #> + attr: name (v/c) #> + edges from aea38ed (vertex names): #>  [1] 1--2  1--3  2--3  4--5  4--6  5--6  7--8  7--9  7--10 8--9  8--10 9--10 create_components_graph(10, membership = c(1,1,1,2,2,2,3,3,3,3), directed = TRUE)  #> IGRAPH aea45bd DN-- 10 12 --  #> + attr: name (v/c) #> + edges from aea45bd (vertex names): #>  [1] 1->2  1->3  2->3  4->5  4->6  5->6  7->8  7->9  7->10 8->9  8->10 9->10  # bipartite if (FALSE) { # \\dontrun{ create_components_graph(c(4, 6), membership = c(1,1,1,2,2,2,3,3,3,3))  |>    snafun::plot() } # } # the row vertices are numbered 1-4, the column vertices are 5-10 create_components_graph(c(4, 6), membership = c(1,1,2,3,2,2,3,3,3,1), graph = \"matrix\") #>   5 6 7 8 9 10 #> 1 0 0 0 0 0  1 #> 2 0 0 0 0 0  1 #> 3 1 1 0 0 0  0 #> 4 0 0 1 1 1  0"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_empty_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an empty network — create_empty_graph","title":"Create an empty network — create_empty_graph","text":"Generate graph edges","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_empty_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an empty network — create_empty_graph","text":"","code":"create_empty_graph(n_vertices, directed = TRUE, graph = c(\"igraph\", \"network\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_empty_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an empty network — create_empty_graph","text":"n_vertices numeric, number vertices directed logical, whether create directed graph graph character, type graph generated: igraph network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_empty_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an empty network — create_empty_graph","text":"graph class network igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_empty_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an empty network — create_empty_graph","text":"Generate graph edges, either igraph network object.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a manual (literal) graph — create_manual_graph","title":"Create a manual (literal) graph — create_manual_graph","text":"Create (small) graph quickly","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a manual (literal) graph — create_manual_graph","text":"","code":"create_manual_graph(..., simplify = TRUE, graph = c(\"igraph\", \"network\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a manual (literal) graph — create_manual_graph","text":"... formulae giving structure graph, see details . simplify Logical scalar. default graph simplified, loops multiple edges removed. graph character, type graph generated: igraph (default) network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a manual (literal) graph — create_manual_graph","text":"graph class network igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a manual (literal) graph — create_manual_graph","text":"function useful want create small (named) graph quickly, works directed undirected graphs. need supply one R expressions giving structure graph. expressions consist vertex names edge operators. edge operator sequence ‘-’ ‘+’ characters, former edges latter used arrow heads. edges can arbitrarily long, .e. may use many ‘-’ characters “draw” like. function mainly acts wrapper graph_from_literal almost examples come function well.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_manual_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a manual (literal) graph — create_manual_graph","text":"","code":"# undirected graph create_manual_graph(1-2) #> IGRAPH b047fbc UN-- 2 1 --  #> + attr: name (v/c) #> + edge from b047fbc (vertex names): #> [1] 1--2 ##  the length of the edges does not matter, so the following this creates the same graph create_manual_graph( 1-----2 ) #> IGRAPH b048c9f UN-- 2 1 --  #> + attr: name (v/c) #> + edge from b048c9f (vertex names): #> [1] 1--2 create_manual_graph(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 4-6, 4-7, 5-6, 6-7, 8,    graph =\"network\") #>  Network attributes: #>   vertices = 8  #>   directed = FALSE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 10  #>     missing edges= 0  #>     non-missing edges= 10  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes # directed graph create_manual_graph(Sam-+Mary, Sam-+Tom, Mary++Tom) #> IGRAPH b04c071 DN-- 3 4 --  #> + attr: name (v/c) #> + edges from b04c071 (vertex names): #> [1] Sam ->Mary Sam ->Tom  Mary->Tom  Tom ->Mary  # bipartite graph g_bipartite <- create_manual_graph(# listing organizations       organization1:organization2:organization3,         # listing projects       project1:project2,       # specifying connections between organizations and projects        organization1:organization2 - project1,        organization2:organization3 - project2) # note that the graph is bipartite mathematically, but the graph object  # 'does not know' that yet. snafun::extract_vertex_names(g_bipartite) #> [1] \"organization1\" \"organization2\" \"organization3\" \"project1\"      #> [5] \"project2\"      g_bipartite <- snafun::add_vertex_attributes(g_bipartite, \"type\",    value = grepl(pattern = \"^project\", x = snafun::extract_vertex_names(g_bipartite))) snafun::is_bipartite(g_bipartite) #> [1] TRUE   # If you have many disconnected components in the graph, separate them with commas.  # You can also give isolate vertices. create_manual_graph( A--B, C--D, E--F, G--H, I, J, K ) #> IGRAPH b04e4e6 UN-- 11 4 --  #> + attr: name (v/c) #> + edges from b04e4e6 (vertex names): #> [1] A--B C--D E--F G--H  # The ‘:’ operator can be used to define vertex sets.  # If an edge operator connects two vertex sets then every vertex from the first  # set will be connected to every vertex in the second set.  # The following form creates a full graph, including loop edges: create_manual_graph( A:B:C:D -- A:B:C:D ) #> IGRAPH b04f3e8 UN-- 4 6 --  #> + attr: name (v/c) #> + edges from b04f3e8 (vertex names): #> [1] A--B A--C A--D B--C B--D C--D  # In directed graphs, edges will be created only if the edge operator includes  # a arrow head (‘+’) at the end of the edge: create_manual_graph( A -+ B -+ C ) #> IGRAPH b0502d6 DN-- 3 2 --  #> + attr: name (v/c) #> + edges from b0502d6 (vertex names): #> [1] A->B B->C create_manual_graph( A +- B -+ C ) #> IGRAPH b051010 DN-- 3 2 --  #> + attr: name (v/c) #> + edges from b051010 (vertex names): #> [1] B->A B->C create_manual_graph( A +- B -- C ) #> IGRAPH b051a8c DN-- 3 1 --  #> + attr: name (v/c) #> + edge from b051a8c (vertex names): #> [1] B->A # Thus in the third example no edge is created between vertices B and C.   # Mutual edges can be also created with a simple edge operator: create_manual_graph( A +-+ B +---+ C ++ D + E) #> IGRAPH b052884 DN-- 5 8 --  #> + attr: name (v/c) #> + edges from b052884 (vertex names): #> [1] A->B B->A B->C C->B C->D D->C D->E E->D # Note again that the length of the edge operators is arbitrary.  # If the vertex names include spaces or other special characters then you  # need to quote them: create_manual_graph( \"this is\" +- \"a silly\" -+ \"graph here\" ) #> IGRAPH b0536e3 DN-- 3 2 --  #> + attr: name (v/c) #> + edges from b0536e3 (vertex names): #> [1] a silly->this is    a silly->graph here # You can include any character in the vertex names this way,  # even ‘+’ and ‘-’ characters.   # More examples # A simple undirected graph g <- create_manual_graph(   Alice - Bob - Cecil - Alice,   Daniel - Cecil - Eugene,   Cecil - Gordon ) g #> IGRAPH b05432c UN-- 6 6 --  #> + attr: name (v/c) #> + edges from b05432c (vertex names): #> [1] Alice--Bob    Alice--Cecil  Bob  --Cecil  Cecil--Daniel Cecil--Eugene #> [6] Cecil--Gordon  # Another undirected graph, \":\" notation g2 <- create_manual_graph(Alice - Bob:Cecil:Daniel, Cecil:Daniel - Eugene:Gordon) g2 #> IGRAPH b055515 UN-- 6 7 --  #> + attr: name (v/c) #> + edges from b055515 (vertex names): #> [1] Alice --Bob    Alice --Cecil  Alice --Daniel Cecil --Eugene Cecil --Gordon #> [6] Daniel--Eugene Daniel--Gordon  # A directed graph g3 <- create_manual_graph(   Alice +-+ Bob --+ Cecil +-- Daniel,   Eugene --+ Gordon:Helen ) g3 #> IGRAPH b057177 DN-- 7 6 --  #> + attr: name (v/c) #> + edges from b057177 (vertex names): #> [1] Alice ->Bob    Bob   ->Alice  Bob   ->Cecil  Daniel->Cecil  Eugene->Gordon #> [6] Eugene->Helen   # A graph with isolate vertices g4 <- create_manual_graph(Alice -- Bob -- Daniel, Cecil:Gordon, Helen) g4 #> IGRAPH b05854a UN-- 6 2 --  #> + attr: name (v/c) #> + edges from b05854a (vertex names): #> [1] Alice--Bob    Bob  --Daniel snafun::extract_vertex_names(g4) #> [1] \"Alice\"  \"Bob\"    \"Daniel\" \"Cecil\"  \"Gordon\" \"Helen\"   # \"Arrows\" can be arbitrarily long g5 <- create_manual_graph(Alice +---------+ Bob) g5 #> IGRAPH b0599fa DN-- 2 2 --  #> + attr: name (v/c) #> + edges from b0599fa (vertex names): #> [1] Alice->Bob   Bob  ->Alice  # Special vertex names g6 <- create_manual_graph(\"+\" -- \"-\", \"*\" -- \"/\", \"%%\" -- \"%/%\") g6 #> IGRAPH b05aa1e UN-- 6 3 --  #> + attr: name (v/c) #> + edges from b05aa1e (vertex names): #> [1] + ---   * --/   %%--%/%"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a random bipartite network — create_random_graph","title":"Create a random bipartite network — create_random_graph","text":"Generate random graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a random bipartite network — create_random_graph","text":"","code":"create_random_graph(   n_vertices,   strategy = c(\"gnp\", \"gnm\"),   p,   m,   directed = TRUE,   graph = c(\"igraph\", \"network\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a random bipartite network — create_random_graph","text":"n_vertices integer, number vertices include graph strategy Character scalar, type graph, ‘gnp’ creates $G(n,p)$ graph, ‘gnm’ creates $G(n,m)$ graph. See details . p probability $G(n,p)$ graphs. given $G(n,m)$ graphs. m integer, number edges $G(n,p)$ graphs. given $G(n,p)$ graphs. directed logical, whether create directed graph graph character, type graph generated: igraph network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a random bipartite network — create_random_graph","text":"graph class network igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a random bipartite network — create_random_graph","text":"Generate random network, either igraph network object. using strategy 'gnp', bipartite network generated edge probability 'p' occuring. means consecutive runs algorithm usually result graphs different numbers edges. using strategy 'gnm', bipartite network generated exactly 'm' edges. means consecutive runs algorithm result graphs number edges (occur different vertices).","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/create_random_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a random bipartite network — create_random_graph","text":"","code":"create_random_graph(n_vertices = 10, \"gnp\", p = .25, graph = \"igraph\") #> IGRAPH b0bb171 D--- 10 17 -- Erdos-Renyi (gnp) graph #> + attr: name (g/c), type (g/c), loops (g/l), p (g/n) #> + edges from b0bb171: #>  [1]  8-> 1  1-> 2  6-> 2  2-> 3  8-> 3  2-> 4  4->10  6-> 4  5->10  6->10 #> [11]  1-> 7  3-> 7  4-> 7 10-> 7  1-> 8  4-> 8  9-> 8 create_random_graph(n_vertices = 10, \"gnp\", p = .25, graph = \"network\") #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 24  #>     missing edges= 0  #>     non-missing edges= 24  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes create_random_graph(n_vertices = 10, \"gnm\", m = 15, graph = \"igraph\") #> IGRAPH b0bcdb9 D--- 10 15 -- Erdos-Renyi (gnm) graph #> + attr: name (g/c), type (g/c), loops (g/l), m (g/n) #> + edges from b0bcdb9: #>  [1]  1-> 7  1-> 9  3->10  4-> 1  4-> 2  5->10  6-> 4  7-> 2  8-> 4  8-> 5 #> [11]  8-> 7  9-> 1  9-> 3 10-> 6 10-> 7 create_random_graph(n_vertices = 10, \"gnm\", m = 15, graph = \"network\") #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 15  #>     missing edges= 0  #>     non-missing edges= 15  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes"},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":null,"dir":"Reference","previous_headings":"","what":"Dyad level indices — dli","title":"Dyad level indices — dli","text":"Dyad level indices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dyad level indices — dli","text":"","code":"d_distance(x, mode = c(\"all\", \"out\", \"in\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dyad level indices — dli","text":"x graph object mode Character constant, gives whether shortest paths given vertices calculated directed graphs. shortest paths vertex, considered. , default, corresponding undirected graph used, ie. directed paths searched. argument ignored undirected graphs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dyad level indices — dli","text":"Calculate several dyad level indices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Dyad level indices — dli","text":"d_distance(): Distance pair vertices graph. Weights discarded. output function matrix. Use distances geodist edge weights used specific options needed.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/dli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dyad level indices — dli","text":"","code":"#  # distance g <- igraph::make_ring(10) igraph::distances(g) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    1    2    3    4    5    4    3    2     1 #>  [2,]    1    0    1    2    3    4    5    4    3     2 #>  [3,]    2    1    0    1    2    3    4    5    4     3 #>  [4,]    3    2    1    0    1    2    3    4    5     4 #>  [5,]    4    3    2    1    0    1    2    3    4     5 #>  [6,]    5    4    3    2    1    0    1    2    3     4 #>  [7,]    4    5    4    3    2    1    0    1    2     3 #>  [8,]    3    4    5    4    3    2    1    0    1     2 #>  [9,]    2    3    4    5    4    3    2    1    0     1 #> [10,]    1    2    3    4    5    4    3    2    1     0 d_distance(g) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    1    2    3    4    5    4    3    2     1 #>  [2,]    1    0    1    2    3    4    5    4    3     2 #>  [3,]    2    1    0    1    2    3    4    5    4     3 #>  [4,]    3    2    1    0    1    2    3    4    5     4 #>  [5,]    4    3    2    1    0    1    2    3    4     5 #>  [6,]    5    4    3    2    1    0    1    2    3     4 #>  [7,]    4    5    4    3    2    1    0    1    2     3 #>  [8,]    3    4    5    4    3    2    1    0    1     2 #>  [9,]    2    3    4    5    4    3    2    1    0     1 #> [10,]    1    2    3    4    5    4    3    2    1     0 d_distance(snafun::to_network(g)) #>    1 2 3 4 5 6 7 8 9 10 #> 1  0 1 2 3 4 5 4 3 2  1 #> 2  1 0 1 2 3 4 5 4 3  2 #> 3  2 1 0 1 2 3 4 5 4  3 #> 4  3 2 1 0 1 2 3 4 5  4 #> 5  4 3 2 1 0 1 2 3 4  5 #> 6  5 4 3 2 1 0 1 2 3  4 #> 7  4 5 4 3 2 1 0 1 2  3 #> 8  3 4 5 4 3 2 1 0 1  2 #> 9  2 3 4 5 4 3 2 1 0  1 #> 10 1 2 3 4 5 4 3 2 1  0 igraph::V(g)$name <- LETTERS[1:10] igraph::distances(g) #>   A B C D E F G H I J #> A 0 1 2 3 4 5 4 3 2 1 #> B 1 0 1 2 3 4 5 4 3 2 #> C 2 1 0 1 2 3 4 5 4 3 #> D 3 2 1 0 1 2 3 4 5 4 #> E 4 3 2 1 0 1 2 3 4 5 #> F 5 4 3 2 1 0 1 2 3 4 #> G 4 5 4 3 2 1 0 1 2 3 #> H 3 4 5 4 3 2 1 0 1 2 #> I 2 3 4 5 4 3 2 1 0 1 #> J 1 2 3 4 5 4 3 2 1 0 d_distance(g) #>   A B C D E F G H I J #> A 0 1 2 3 4 5 4 3 2 1 #> B 1 0 1 2 3 4 5 4 3 2 #> C 2 1 0 1 2 3 4 5 4 3 #> D 3 2 1 0 1 2 3 4 5 4 #> E 4 3 2 1 0 1 2 3 4 5 #> F 5 4 3 2 1 0 1 2 3 4 #> G 4 5 4 3 2 1 0 1 2 3 #> H 3 4 5 4 3 2 1 0 1 2 #> I 2 3 4 5 4 3 2 1 0 1 #> J 1 2 3 4 5 4 3 2 1 0 d_distance(snafun::to_network(g)) #>   A B C D E F G H I J #> A 0 1 2 3 4 5 4 3 2 1 #> B 1 0 1 2 3 4 5 4 3 2 #> C 2 1 0 1 2 3 4 5 4 3 #> D 3 2 1 0 1 2 3 4 5 4 #> E 4 3 2 1 0 1 2 3 4 5 #> F 5 4 3 2 1 0 1 2 3 4 #> G 4 5 4 3 2 1 0 1 2 3 #> H 3 4 5 4 3 2 1 0 1 2 #> I 2 3 4 5 4 3 2 1 0 1 #> J 1 2 3 4 5 4 3 2 1 0"},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":null,"dir":"Reference","previous_headings":"","what":"Structural equivalence — d_structural_equivalence","title":"Structural equivalence — d_structural_equivalence","text":"Calculate structural equivalence","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Structural equivalence — d_structural_equivalence","text":"","code":"d_structural_equivalence(x, weights = NA, digits = 3, suppressWarnings = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Structural equivalence — d_structural_equivalence","text":"x graph class igraph, network, matrix weights Either NA (default), NULL, character string giving edge attribute name. NULL, edge attribute 'weight' used exists graph. NA, weight applied. character, edge attribute name used (error thrown attribute occur x.) graph multiple edges, edge attribute arbitrarily chosen edge (multiple edges) included. Note function requires attribute either logical numeric. parameter ignored x matrix. case, weights assumed already inside adjacency matrix. digits number decimals use result suppressWarnings logical, whether warnings returned (issued cor).","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Structural equivalence — d_structural_equivalence","text":"matrix size n*n, n equal number vertices graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Structural equivalence — d_structural_equivalence","text":"Calculate structural equivalence based correlations. function, course, disregards diagonal. Vertices also perfectly structurally equivalent . requested, edge attribute can taken account weights argument. default, weights used. value varies \\[-1, 1\\], -1 denoting maximally possible distance two vertices +1 denoting exact structural equivalence. implementation network graph, sedist (method == \"correlation\"). yields result, allow use weight.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/d_structural_equivalence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Structural equivalence — d_structural_equivalence","text":"","code":"if (FALSE) { # \\dontrun{ data(\"judge_net\", package = \"snafun\") d_structural_equivalence(judge_net)  g1 <- create_random_graph(10, \"gnm\", m = 15, directed = TRUE, graph = \"igraph\") g2 <- create_random_graph(10, \"gnm\", m = 15, directed = FALSE, graph = \"igraph\") d_structural_equivalence(g1) d_structural_equivalence(g2) d_structural_equivalence(to_network(g1)) d_structural_equivalence(to_matrix(g1))  g3 <- add_edge_attributes(g1, \"weight\", value = 1:count_edges(g1)) d_structural_equivalence(g3, weights = NA)  # no weight used d_structural_equivalence(g3, weights = NULL) d_structural_equivalence(g3, weights = \"weight\") # same as NULL } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract attributes from the graph object — extract","title":"Extract attributes from the graph object — extract","text":"Extract attributes graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract attributes from the graph object — extract","text":"","code":"extract_vertex_attribute(x, name)  extract_vertex_names(x)  extract_edge_attribute(x, name)  extract_graph_attribute(x, name)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract attributes from the graph object — extract","text":"x graph object class igraph network name name attribute accessed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract attributes from the graph object — extract","text":"values requested attributes ()","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract all vertex attributes — extract_all_vertex_attributes","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"Extract vertex attributes network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"","code":"extract_all_vertex_attributes(g)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"g name input network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"data.frame case vertex attributes, otherwise NULL","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"function extract vertex attributes network object igraph object returns data.frame. columns data.frame corresponding attribute names. attempt made assign specific class attributes. user set appropriately analysis hand. Note network objects tend vertex attribute called na. , correctly, included, likely irrelevant. vertex attributes, NULL returned.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_all_vertex_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract all vertex attributes — extract_all_vertex_attributes","text":"","code":"if (FALSE) { # \\dontrun{ data(florentine, package = \"SNA4DSData\") flomar <- florentine$flomarriage extract_all_vertex_attributes(flomar)  # NULL extract_all_vertex_attributes(igraph::erdos.renyi.game(10, 4, type = \"gnm\"))  flomar_nw <- to_network(flomar) extract_all_vertex_attributes(flomar_nw) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"Extract communities via greedy optimization modularity","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"","code":"extract_comm_fastgreedy(   x,   weights = NA,   modularity = TRUE,   merges = TRUE,   membership = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"x undirected input graph, edge directions ignored directed graphs. weights weights edges. must positive numeric vector, NULL NA. NULL input graph ‘weight’ edge attribute, attribute used. NULL attribute present, edges equal weights. Set NA graph ‘weight’ edge attribute, want use community detection. Larger edge weights increase probability edge selected random walker. words, larger edge weights correspond stronger connections. modularity Logical scalar, whether include vector modularity scores result. membership argument TRUE, always calculated. merges Logical scalar, whether include merge matrix result. membership Logical scalar, whether calculate membership vector split corresponding highest modularity value.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"communities object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"NOTE: algorithm works undirected graphs. function tries find dense subgraph, also called communities graphs via directly optimizing modularity score. result function can queried using utility functions documented : membership,","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_fastgreedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure via greedy optimization of modularity — extract_comm_fastgreedy","text":"function just wraps cluster_fast_greedy function documentation.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure based on edge betweenness — extract_comm_girvan","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"Extract communities via Girvan Newman method","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"","code":"extract_comm_girvan(   x,   weights = NA,   directed = TRUE,   modularity = TRUE,   edge.betweenness = FALSE,   bridges = FALSE,   merges = TRUE,   membership = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"x input graph, edge directions ignored directed graphs. weights weights edges. must positive numeric vector, NULL NA. NULL input graph ‘weight’ edge attribute, attribute used. NULL attribute present, edges equal weights. Set NA graph ‘weight’ edge attribute, want use community detection. Larger edge weights increase probability edge selected random walker. words, larger edge weights correspond stronger connections. directed Logical constant, whether calculate directed edge betweenness directed graphs. ignored undirected graphs. modularity Logical scalar, whether include vector modularity scores result. membership argument TRUE, always calculated. edge.betweenness Logical constant, whether return edge betweenness edges time removal. bridges Logical constant, whether return list edge removals actually splitted component graph. merges Logical scalar, whether include merge matrix result. membership Logical scalar, whether calculate membership vector split corresponding highest modularity value.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"communities object can handled functions membership.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"edge betweenness score edge measures number shortest paths . idea edge betweenness-based community structure detection likely edges connecting separate modules high edge betweenness shortest paths one module another must traverse . gradually remove edge highest edge betweenness score get hierarchical map, rooted tree, called dendrogram graph. leafs tree individual vertices root tree represents whole graph. result function can queried using utility functions documented : membership,","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_girvan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure based on edge betweenness — extract_comm_girvan","text":"function just wraps edge_betweenness function documentation.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure via multi-level optimization of modularity — extract_comm_louvain","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"Extract communities using Louvain algorithm undirected graphs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"","code":"extract_comm_louvain(x, weights = NA, resolution = 1)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"x undirected input graph, edge directions ignored directed graphs. weights weights edges. must positive numeric vector, NULL NA. NULL input graph ‘weight’ edge attribute, attribute used. NULL attribute present, edges equal weights. Set NA graph ‘weight’ edge attribute, want use community detection. Larger edge weights increase probability edge selected random walker. words, larger edge weights correspond stronger connections. resolution Optional resolution parameter allows user adjust resolution parameter modularity function algorithm uses internally. Lower values typically yield fewer, larger clusters. original definition modularity recovered resolution parameter set 1.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"communities object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"NOTE: algorithm works undirected graphs. function implements multi-level modularity optimization algorithm finding community structure, also known \"Louvain\" algorithm. based modularity measure hierarchical approach. Initially, vertex assigned community . every step, vertices re-assigned communities local, greedy way: vertex moved community achieves highest contribution modularity. vertices can reassigned, community considered vertex , process starts merged communities. process stops single vertex left modularity increased step.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure via multi-level optimization of modularity — extract_comm_louvain","text":"function just wraps cluster_louvain function documentation.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure via short random walks — extract_comm_walktrap","title":"Community structure via short random walks — extract_comm_walktrap","text":"Extract communities using walktrap algorithm","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure via short random walks — extract_comm_walktrap","text":"","code":"extract_comm_walktrap(   x,   weights = NA,   steps = 4,   modularity = TRUE,   merges = TRUE,   membership = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure via short random walks — extract_comm_walktrap","text":"x input graph, edge directions ignored directed graphs. weights weights edges. must positive numeric vector, NULL NA. NULL input graph ‘weight’ edge attribute, attribute used. NULL attribute present, edges equal weights. Set NA graph ‘weight’ edge attribute, want use community detection. Larger edge weights increase probability edge selected random walker. words, larger edge weights correspond stronger connections. steps length random walks perform. modularity Logical scalar, whether include vector modularity scores result. membership argument TRUE, always calculated. merges Logical scalar, whether include merge matrix result. membership Logical scalar, whether calculate membership vector split corresponding highest modularity value.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure via short random walks — extract_comm_walktrap","text":"communities object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure via short random walks — extract_comm_walktrap","text":"Find community structure graph using random walks across edges graph. idea short random walks tend stay community. result function can queried using utility functions documented : membership,","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_comm_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure via short random walks — extract_comm_walktrap","text":"function just wraps cluster_walktrap function documentation.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_edge_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract edge id's — extract_edge_id","title":"Extract edge id's — extract_edge_id","text":"Extract edge id's given sets ego(s) alter(s)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_edge_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract edge id's — extract_edge_id","text":"","code":"extract_edge_id(object, ego, alter, edgelist, ordered = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_edge_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract edge id's — extract_edge_id","text":"object graph class network igraph ego numeric vector vertex id's alter numeric vector vertex id's edgelist matrix data.frame two numeric columns, containing vertex id's. ignored ego /alter () specified. ordered logical, output ordered according edgelist","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_edge_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract edge id's — extract_edge_id","text":"data.frame three columns: ego (=sender), alter (=receiver), eid (= edge id)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_edge_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract edge id's — extract_edge_id","text":"utility function extracts id specific edges. mainly useful working graph, network igraph object, objects constructed differently internally order edges differently. three arguments help determine edges id's extracted. ego specified, edges included 'ego' node sender (case directed graph) sender receiver (case undirected graph). alter specified, edges included 'alter' node receiver (case directed graph) sender receiver (case undirected graph). ego alter specified, edges included 'ego' sender 'alter' receiver (vice versa, case undirected graph). edgelist specified, exact edges specified edgelist used. case id requested edge occur graph, zero returned non-existent edge(s). Note ego, vertex, edgelist contain numeric vertex id's accept vertex names current implementation function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract ego networks — extract_egonet","title":"Extract ego networks — extract_egonet","text":"Extract one ego network input graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract ego networks — extract_egonet","text":"","code":"extract_egonet(x, vertices = NULL, order = 1, type = c(\"all\", \"out\", \"in\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract ego networks — extract_egonet","text":"x input graph class igraph network vertices NULL egonetworks vertex graph returned. vertices single vertex vector, ego networks specific vertices returned. generally want. order order resulting graph type Character constant, specifies use direction edges directed graph analyzed. ‘’ outgoing edges followed, vertices reachable source vertex order steps counted. ‘\"\"’ vertices source vertex reachable order steps counted. ‘\"\"’ ignores direction edges. argument ignored undirected graphs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract ego networks — extract_egonet","text":"list graphs class input graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract ego networks — extract_egonet","text":"vertex vertices, ego network returned. includes vertices can reached order number steps. type argument determines whether edges followed incoming, outgoing, undirected (considered undirected anyway undirected graph.) output list egonetworks, one ego vertex.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_egonet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract ego networks — extract_egonet","text":"","code":"g <- igraph::graph_from_literal(One --+ Two +-+ Three +-- Four --+ Five +-- Six +-- Seven +-+ Eight +-+ One +-+ Five) snafun::to_matrix(g) #>       One Two Three Four Five Six Seven Eight #> One     0   1     0    0    1   0     0     1 #> Two     0   0     1    0    0   0     0     0 #> Three   0   1     0    0    0   0     0     0 #> Four    0   0     1    0    1   0     0     0 #> Five    1   0     0    0    0   0     0     0 #> Six     0   0     0    0    1   0     0     0 #> Seven   0   0     0    0    0   1     0     1 #> Eight   1   0     0    0    0   0     1     0 extract_egonet(g, vertices = 1, order = 1, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Five Eight #> One     0    1     1 #> Five    1    0     0 #> Eight   1    0     0 extract_egonet(g, vertices = 1, order = 1, type = \"out\")[[1]] |> snafun::to_matrix() #>       One Two Five Eight #> One     0   1    1     1 #> Two     0   0    0     0 #> Five    1   0    0     0 #> Eight   1   0    0     0 extract_egonet(g, vertices = 1, order = 1, type = \"all\")[[1]] |> snafun::to_matrix() #>       One Two Five Eight #> One     0   1    1     1 #> Two     0   0    0     0 #> Five    1   0    0     0 #> Eight   1   0    0     0 extract_egonet(g, vertices = 1, order = 2, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Four Five Six Seven Eight #> One     0    0    1   0     0     1 #> Four    0    0    1   0     0     0 #> Five    1    0    0   0     0     0 #> Six     0    0    1   0     0     0 #> Seven   0    0    0   1     0     1 #> Eight   1    0    0   0     1     0 extract_egonet(g, vertices = 1, order = 2, type = \"out\")[[1]] |> snafun::to_matrix() #>       One Two Three Five Seven Eight #> One     0   1     0    1     0     1 #> Two     0   0     1    0     0     0 #> Three   0   1     0    0     0     0 #> Five    1   0     0    0     0     0 #> Seven   0   0     0    0     0     1 #> Eight   1   0     0    0     1     0 extract_egonet(g, vertices = 1, order = 2, type = \"all\")[[1]] |> snafun::to_matrix() #>       One Two Three Four Five Six Seven Eight #> One     0   1     0    0    1   0     0     1 #> Two     0   0     1    0    0   0     0     0 #> Three   0   1     0    0    0   0     0     0 #> Four    0   0     1    0    1   0     0     0 #> Five    1   0     0    0    0   0     0     0 #> Six     0   0     0    0    1   0     0     0 #> Seven   0   0     0    0    0   1     0     1 #> Eight   1   0     0    0    0   0     1     0  extract_egonet(g, vertices = c(\"One\"), order = 2, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Four Five Six Seven Eight #> One     0    0    1   0     0     1 #> Four    0    0    1   0     0     0 #> Five    1    0    0   0     0     0 #> Six     0    0    1   0     0     0 #> Seven   0    0    0   1     0     1 #> Eight   1    0    0   0     1     0 extract_egonet(g, vertices = c(\"One\", \"Three\"), order = 2, type = \"in\") #> [[1]] #> IGRAPH b307adc DN-- 6 9 --  #> + attr: name (v/c) #> + edges from b307adc (vertex names): #> [1] One  ->Five  One  ->Eight Four ->Five  Five ->One   Six  ->Five  #> [6] Seven->Six   Seven->Eight Eight->One   Eight->Seven #>  #> [[2]] #> IGRAPH b307b10 DN-- 4 4 --  #> + attr: name (v/c) #> + edges from b307b10 (vertex names): #> [1] One  ->Two   Two  ->Three Three->Two   Four ->Three #>   g_n <- snafun::to_network(g) extract_egonet(g_n, vertices = 1, order = 1, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Five Eight #> One     0    1     1 #> Five    1    0     0 #> Eight   1    0     0 extract_egonet(g_n, vertices = 1, order = 1, type = \"out\")[[1]] |> snafun::to_matrix() #>       One Two Five Eight #> One     0   1    1     1 #> Two     0   0    0     0 #> Five    1   0    0     0 #> Eight   1   0    0     0 extract_egonet(g_n, vertices = 1, order = 1, type = \"all\")[[1]] |> snafun::to_matrix() #>       One Two Five Eight #> One     0   1    1     1 #> Two     0   0    0     0 #> Five    1   0    0     0 #> Eight   1   0    0     0 extract_egonet(g_n, vertices = 1, order = 2, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Four Five Six Seven Eight #> One     0    0    1   0     0     1 #> Four    0    0    1   0     0     0 #> Five    1    0    0   0     0     0 #> Six     0    0    1   0     0     0 #> Seven   0    0    0   1     0     1 #> Eight   1    0    0   0     1     0 extract_egonet(g_n, vertices = 1, order = 2, type = \"out\")[[1]] |> snafun::to_matrix() #>       One Two Three Five Seven Eight #> One     0   1     0    1     0     1 #> Two     0   0     1    0     0     0 #> Three   0   1     0    0     0     0 #> Five    1   0     0    0     0     0 #> Seven   0   0     0    0     0     1 #> Eight   1   0     0    0     1     0 extract_egonet(g_n, vertices = 1, order = 2, type = \"all\")[[1]] |> snafun::to_matrix() #>       One Two Three Four Five Six Seven Eight #> One     0   1     0    0    1   0     0     1 #> Two     0   0     1    0    0   0     0     0 #> Three   0   1     0    0    0   0     0     0 #> Four    0   0     1    0    1   0     0     0 #> Five    1   0     0    0    0   0     0     0 #> Six     0   0     0    0    1   0     0     0 #> Seven   0   0     0    0    0   1     0     1 #> Eight   1   0     0    0    0   0     1     0 extract_egonet(g_n, vertices = c(\"One\"), order = 2, type = \"in\")[[1]] |> snafun::to_matrix() #>       One Four Five Six Seven Eight #> One     0    0    1   0     0     1 #> Four    0    0    1   0     0     0 #> Five    1    0    0   0     0     0 #> Six     0    0    1   0     0     0 #> Seven   0    0    0   1     0     1 #> Eight   1    0    0   0     1     0 extract_egonet(g_n, vertices = c(\"One\", \"Three\"), order = 2, type = \"in\") #> $`1` #>  Network attributes: #>   vertices = 6  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 9  #>     missing edges= 0  #>     non-missing edges= 9  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes #>  #> $`3` #>  Network attributes: #>   vertices = 4  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 4  #>     missing edges= 0  #>     non-missing edges= 4  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes #>"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":null,"dir":"Reference","previous_headings":"","what":"Intersection of graphs — extract_intersection","title":"Intersection of graphs — extract_intersection","text":"intersection two graphs created. graphs may identical overlapping vertex sets.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Intersection of graphs — extract_intersection","text":"","code":"extract_intersection(..., byname = \"auto\", keep.all.vertices = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Intersection of graphs — extract_intersection","text":"... Graph objects lists graph objects. Allowed graph classes igraph, network, matrix. byname logical scalar, character scalar \"auto\". Whether perform operation based symbolic vertex names. \"auto\", means TRUE graphs named FALSE otherwise. warning generated \"auto\" () graphs named. keep..vertices Logical, whether keep vertices appear subset input graphs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Intersection of graphs — extract_intersection","text":"graph object class igraph, network, matrix.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Intersection of graphs — extract_intersection","text":"extract_intersection() extracts intersection two graphs. graphs intersected can class igraph, network, matrix. edges present graphs included. byname argument TRUE (\"auto\" graphs named), operation performed symbolic vertex names instead internal numeric vertex ids. extract_intersection() keeps attributes graphs. graph, vertex edge attributes copied result. attribute present multiple graphs result name clash, attribute renamed adding suffixes: _1, _2, etc. name vertex attribute treated specially operation performed based symbolic vertex names. case name must present graphs, renamed result graph. error generated input graphs directed others undirected. actual intersection performed intersection.igraph function, also basis documentation function. extract_intersection() mainly adds opportunity intersect graphs different classes, just class igraph. fact, intrepid can even intersect graphs different types together (although rarely useful). output graph class first graph passed function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_intersection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Intersection of graphs — extract_intersection","text":"","code":"net1 <- snafun::create_manual_graph( D - A:B:F:G, A - C - F - A, B - E - G - B, A - B, F - G, H - F:G, H - I - J ) net2 <- snafun::create_manual_graph(D - A:F:Y, B - A - X - F - H - Z, F - Y) extract_intersection(net1, net2) #> Error in eval(kall[[1]]): object 'net1' not found  g1 <- snafun::create_random_graph(10, \"gnm\", m = 15) g2 <- snafun::create_random_graph(10, \"gnm\", m = 15) extract_intersection(g1, g2) #> Error in eval(kall[[1]]): object 'g1' not found  # intersection of three graphs g3 <- snafun::create_random_graph(15, \"gnm\", m = 20) extract_intersection(g1, g2, g3) #> Error in eval(kall[[1]]): object 'g1' not found"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the isolates — extract_isolates","title":"Extract the isolates — extract_isolates","text":"isolates network?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the isolates — extract_isolates","text":"","code":"extract_isolates(x, names = TRUE, loops = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the isolates — extract_isolates","text":"x network class network igraph names logical, names isolates returned ( TRUE IDs (FALSE)? default TRUE. loops logical, self-loops () taken account? Default FALSE, (almost) always want.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the isolates — extract_isolates","text":"vector isolates","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract the isolates — extract_isolates","text":"Identifies isolates () network. function works objects class network graph, potentially bipartite. output vector numbers isolates names. latter default, numbers returned names network object. self-loops network (ie. vertex tie ), vertices ties others seen isolates. Therefore, user can decide whether self-ties taken account. FALSE, default, self-loops ignored vertices ties others identified isolates. However, (uncommon) case tie oneself longer make vertex isolate, one can set loops argument TRUE.","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_isolates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the isolates — extract_isolates","text":"","code":"mat <- matrix(0, nrow = 4, ncol = 4) # edges, incl one self-loop mat[1, 3] <- mat[4,4] <- 1 ig <- igraph::graph_from_adjacency_matrix(mat) extract_isolates(ig)  # 2 4 #> [1] 2 4 # 4 has a loop to itself, including this removes its isolate-ship extract_isolates(ig, loops = TRUE)  # 2 #> [1] 2 igraph::V(ig)$name <-  LETTERS[1:4] extract_isolates(ig)  # B D #> [1] \"B\" \"D\" extract_isolates(ig, names = FALSE)  # 2 4 #> [1] 2 4  nw <- network::as.network(mat, loops = TRUE) extract_isolates(nw)  # 2 4 #> [1] 2 4 network::set.vertex.attribute(nw, \"vertex.names\", LETTERS[1:4]) extract_isolates(nw)  # B D #> [1] \"B\" \"D\" extract_isolates(nw, names = FALSE)  # 2 4 #> [1] 2 4"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract loops — extract_loops","title":"Extract loops — extract_loops","text":"Extract edges run actor ","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract loops — extract_loops","text":"","code":"extract_loops(x)  extract_loops_vertex(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract loops — extract_loops","text":"x input graph class igraph network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract loops — extract_loops","text":"see ","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract loops — extract_loops","text":"Several functions package deal loops (also sometimes redundantly called \"self-loops\")\"ties run vertex vertex. specific function extracts edge id's loops, can identified , required, removed. extract_loops returns edge ID's loops graph extract_loops_vertex returns table two columns, first contains vertex least one loop graph second gives number loops vertex graph.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_loops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract loops — extract_loops","text":"","code":"data(florentine, package = \"snafun\") x <- florentine$flobusiness has_loops(x)             # FALSE #> [1] FALSE extract_loops(x)         # NULL #> NULL extract_loops_vertex(x)  # NULL #> NULL x <- igraph::add_edges(x, c(\"Barbadori\", \"Barbadori\", \"Medici\", \"Medici\")) has_loops(x)             # FALSE #> [1] TRUE extract_loops(x)         # loops detected #> [1] 16 17 extract_loops_vertex(x) #>      vertex number_of_loops #> 1 Barbadori               1 #> 2    Medici               1"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the neighbors of a vertex — extract_neighbors","title":"Extract the neighbors of a vertex — extract_neighbors","text":"Get names ID's vertices focal vertex connected","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the neighbors of a vertex — extract_neighbors","text":"","code":"extract_neighbors(x, vertex, type = c(\"out\", \"in\", \"all\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the neighbors of a vertex — extract_neighbors","text":"x graph object class igraph network vertex number name (graph vertex names) single vertex type type neighborhood returned","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the neighbors of a vertex — extract_neighbors","text":"vector vertex ID's names neighbors","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract the neighbors of a vertex — extract_neighbors","text":"mode == \"\" function returns vertices receive edge vertex. mode == \"\" function returns vertices send edge vertex. mode == \"\" vertices edge vertex returned. undirected graph, mode always taken \"\". Note vertex needs single vertex, vector.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_neighbors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the neighbors of a vertex — extract_neighbors","text":"","code":"m <- matrix(0, 3, 3) m[1, 2] <- 1; m[2, 3] <- 1; m[3, 1] <- 1 g_i <- snafun::to_igraph(m) extract_neighbors(g_i, 1, \"out\") #> [1] 2 extract_neighbors(g_i, 1, \"in\") #> [1] 3 extract_neighbors(g_i, 1, \"all\") #> [1] 2 3  g_n <- snafun::to_network(m) extract_neighbors(g_n, 1, \"out\") #> [1] 2 extract_neighbors(g_n, 1, \"in\") #> [1] 3 extract_neighbors(g_n, 1, \"all\") #> [1] 2 3"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a subgraph — extract_subgraph","title":"Extract a subgraph — extract_subgraph","text":"Extract subgraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a subgraph — extract_subgraph","text":"","code":"extract_subgraph(x, v_to_keep, e_to_keep)"},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a subgraph — extract_subgraph","text":"x input graph v_to_keep Numeric vector, vertices original graph form subgraph. e_to_keep edge ids edges kept resulting graph.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a subgraph — extract_subgraph","text":"graph class input graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract a subgraph — extract_subgraph","text":"Extract subgraph input graph object either choosing vertices keep edges keep. v_to_keep e_to_keep provided, v_to_keep used. course, resulting graph can subsequently used input function providing e_to_keep prune network. vertices removed (v_to_keep), exactly specified vertices already existing edges kept resulting graph. Edges lose sender /receiver removed resulting graph. v_to_keep e_to_keep numeric vectors take names. function works igraph network returns subgraph class. underlying functions perform actual extraction induced_subgraph, subgraph.edges, get.inducedSubgraph. Consult functions detail , cases, functionality.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/extract_subgraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a subgraph — extract_subgraph","text":"","code":"g <- igraph::make_ring(10) extract_subgraph(g, v_to_keep = 3:8) #> IGRAPH b45d18d U--- 6 5 -- Ring graph #> + attr: name (g/c), mutual (g/l), circular (g/l) #> + edges from b45d18d: #> [1] 1--2 2--3 3--4 4--5 5--6 extract_subgraph(g, e_to_keep = 4:8) #> IGRAPH b45d974 U--- 6 5 -- Ring graph #> + attr: name (g/c), mutual (g/l), circular (g/l) #> + edges from b45d974: #> [1] 1--2 2--3 3--4 4--5 5--6 extract_subgraph(g, v_to_keep = 3:8, e_to_keep = 4:8) #> Warning: When both 'v_to_keep' and 'e_to_keep' are specified, only 'v_to_keep' is used, to ensure result integrity. #> IGRAPH b45e213 U--- 6 5 -- Ring graph #> + attr: name (g/c), mutual (g/l), circular (g/l) #> + edges from b45e213: #> [1] 1--2 2--3 3--4 4--5 5--6  g <- to_network(g) extract_subgraph(g, v_to_keep = 3:8) #>  Network attributes: #>   vertices = 6  #>   directed = FALSE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 5  #>     missing edges= 0  #>     non-missing edges= 5  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes extract_subgraph(g, e_to_keep = 4:8) #>  Network attributes: #>   vertices = 6  #>   directed = FALSE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 5  #>     missing edges= 0  #>     non-missing edges= 5  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes extract_subgraph(g, v_to_keep = 3:8, e_to_keep = 4:8) #> Warning: When both 'v_to_keep' and 'e_to_keep' are specified, only 'v_to_keep' is used, to ensure result integrity. #>  Network attributes: #>   vertices = 6  #>   directed = FALSE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 5  #>     missing edges= 0  #>     non-missing edges= 5  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes  data(emon, package = \"network\") g <- emon$MtStHelens extract_subgraph(g, e_to_keep = which(extract_edge_attribute(g, 'Frequency') == 2)) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   total edges= 12  #>     missing edges= 0  #>     non-missing edges= 12  #>  #>  Vertex attribute names:  #>     Command.Rank.Score Decision.Rank.Score Formalization Location Paid.Staff Sponsorship Volunteer.Staff vertex.names  #>  #>  Edge attribute names:  #>     Frequency   g_i <- to_igraph(g) extract_subgraph(g_i, e_to_keep = which(extract_edge_attribute(g_i, 'weight') == 2)) #> IGRAPH b488887 DN-- 0 0 --  #> + attr: name (v/c), vertex.names (v/c), Sponsorship (v/c), Paid.Staff #> | (v/n), Volunteer.Staff (v/n), Location (v/c), Formalization (v/n), #> | Decision.Rank.Score (v/n), Command.Rank.Score (v/n), Frequency (e/n) #> + edges from b488887 (vertex names):"},{"path":"https://snanalyst.github.io/SNAfun/reference/fix_cug_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix intermediate CUG input — fix_cug_input","title":"Fix intermediate CUG input — fix_cug_input","text":"Fix intermediate input sna::cug.test","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/fix_cug_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix intermediate CUG input — fix_cug_input","text":"","code":"fix_cug_input(el, directed = TRUE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/fix_cug_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix intermediate CUG input — fix_cug_input","text":"el input generated single run sna::cug.test directed logical, graph directed ?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/fix_cug_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix intermediate CUG input — fix_cug_input","text":"object class igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/fix_cug_input.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fix intermediate CUG input — fix_cug_input","text":"function makes cug.test useable snafun. cug.test function generates series networks various specific ways. function converts data format object class igraph, can handled (almost) function snafun igraph code works igraph objects. somwtimes slows computations cug.test little, can sometimes also speed . Either way, added flexibility huge gain. Make sure set correctly whether actual graph directed .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/florentine.html","id":null,"dir":"Reference","previous_headings":"","what":"Florentine families — florentine","title":"Florentine families — florentine","text":"Network data 16 Florentine families, igraph format.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/florentine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Florentine families — florentine","text":"","code":"data(florentine, package = \"snafun\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/florentine.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Florentine families — florentine","text":"list containing two igraph networks data.frame attributes.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/florentine.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Florentine families — florentine","text":"http://networkdata.ics.uci.edu/netdata/html/florentine.html","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/florentine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Florentine families — florentine","text":"list containing two networks data.frame attributes. data set 1520 marriage 15 business ties among Renaissance Florentine families. data originally Padgett (1994) via UCINET stored igraph object. dataset subset original data contains data sixteen families. two relations business ties (flobusiness, recorded financial ties loans, credits joint partnerships) marriage alliances (flomarriage). addition, data.frame attributes: wealth family's net wealth 1427 (thousands lira) priorates number priorates (seats civic council) held 1282- 1344 totalties total number business marriage ties total dataset 116 families. data symmetrically coded. makes sense marital ties, unfortunate financial ties (almost certainly directed real life). Substantively, data include families engaged struggle political control city Florence around 1430. Two factions dominant struggle: one revolved around infamous Medicis (9), around powerful Strozzis (15).","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph level indices — gli","title":"Graph level indices — gli","text":"Graph level indices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph level indices — gli","text":"","code":"g_summary(x, directed = TRUE)  g_density(x, loops = FALSE)  g_mean_distance(x)  g_correlation(g1, g2, diag = FALSE, weight = TRUE, wf = NULL)  g_reciprocity(x)  g_transitivity(x)  g_diameter(x, directed = is_directed(x), unconnected = TRUE)  g_radius(x, mode = c(\"all\", \"out\", \"in\"))  g_compactness(x, mode = c(\"out\", \"in\", \"all\"))  g_degree_distribution(   x,   mode = c(\"out\", \"in\", \"all\"),   type = c(\"density\", \"count\"),   cumulative = FALSE,   loops = FALSE,   digits = 3 )"},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph level indices — gli","text":"x graph object directed Logical, whether directed undirected paths considered. ignored undirected graphs. default TRUE x directed FALSE otherwise loops logical, loops/diagonal included? Default FALSE. almost always want. g1 input graph class igraph, network, matrix g2 input graph class igraph, network, matrix diag logical, indicating whether diagonal treated valid data. Set TRUE data can contain loops. FALSE default. weight local, weight included? TRUE default. wf set user, internal use unconnected Logical, graph unconnected. FALSE, function return number one larger largest possible diameter, always number vertices. TRUE, diameters connected components calculated largest one returned. mode Character constant, gives whether shortest paths given vertices calculated directed graphs. shortest paths vertex, considered. , default, corresponding undirected graph used, edge directions ignored. argument ignored undirected graphs. type character, either \"density\" \"count\" cumulative logical, raw densities returned cumulative sum digits maximal number decimals result","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graph level indices — gli","text":"Calculate several graph level indices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Graph level indices — gli","text":"g_summary(): Summary indices graph. function provides basic summary indices graph. default settings underlying functions (package) used. investigation, consider settings. directed == TRUE (default), graph treated directed (undirected ). directed == FALSE directed graph forced become undirected graph using to_symmetric_matrix rule = \"weak\". can sometimes informative compare summary stats directed graph undirected equivalent. g_density(): Density graph. Weights discarded. Use gden edge weights used code graph class network. Note function computes density bipartite network without symmetrizing, density reported half density reported gden specific case. Also note edge_density correctly deal loops, current function reports correct density values whereas edge_density reports incorrect values. g_mean_distance(): Mean path distance g_correlation(): Product-moment correlation two networks. Missing values permitted. Takes account whether graph (un)directed (judged g1). NOTE: input graphs class igraph,network matrix. possible mix graph classes, correlations can calculated graphs class network igraph, example. weight attribute included graphs, used default. possible common provide two graphs directly, function also accepts list two graphs array two graph (, array size 2 x n x n). case, provide list array g1 argument. g2 ignored g1 list array. Internally, graphs converted matrices correlation calculated. g_reciprocity(): Reciprocity g_transitivity(): Transitivity Transitivity triadic, algebraic structural constraint. weak form (common form), transitive constraint corresponds -> b -> c implying -> c. measure returns  fraction potentially intransitive triads obeying weak condition. words, count number triplets -> j, j -> k, -> k, divide number triplets -> j j -> k (regardless whether -> k edge). Weights discarded. Specific functions can alternatively used (called function) include gtrans (objects class network) transitivity (objects class igraph). network igraph implementations differ can give somewhat different results. g_diameter(): Diameter graph. Weights discarded. diameter equal maximum eccentricity scores across vertices. Substantively, measures maximum number steps needed connect two vertices graph (given connected). Use diameter edge weights used specific options needed. g_radius(): Radius graph. Weights discarded. diameter equal minimum eccentricity scores across vertices. Substantively, measures minimum number steps needed connect two vertices graph (given connected). words, regardless vertex considered, possible reach vertices within fewer number steps. g_compactness(): Compactness graph. Weights discarded. compactness graph average inverse distances across dyads graph. Mathematically: $$\\frac{\\sum_{,j : \\neq j} (\\frac{1}{d_{ij}})}{n(n-1)}$$ denominator altered according number dyads graph. vertices directly tied , compactness 1. shorter paths vertices, larger inverse distances become. Hence, shorter paths, higher compactness. , often seen measure cohesion. measure works well disconnected graphs. Inverse distances disconnected vertices 0, disconnected graph, lower compactness. Thus, measure runs 0 (abolutely \"uncompact\") 1 (maximally compact). g_degree_distribution(): Degree distribution. distribution degrees vertices graph. Returns matrix counts densities degree degrees column names. result can raw cumulative (starting degree 0.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/gli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph level indices — gli","text":"","code":"m <- matrix(rbinom(25, 1, 0.5), 5, 5) diag(m) <- 0 g_density(snafun::to_network(m)) #> [1] 0.5 g_density(snafun::to_igraph(m)) #> [1] 0.5 # when loops matter g <- igraph::graph( c(1,2, 2,2, 2,3) ) g_density(g, loops = FALSE)   # this is wrong, if loops matter #> [1] 0.5 g_density(g, loops = TRUE)   # this is correct, if loops matter #> [1] 0.3333333  g <- sna::rgraph(10, mode = \"digraph\") g_n <- snafun::to_network(g) g_mean_distance(g_n) #> [1] 1.411111 g_i <- snafun::to_igraph(g) g_mean_distance(g_i) #> [1] 1.411111  g <- sna::rgraph(10, mode = \"graph\") g_n <- snafun::to_network(g) g_mean_distance(g_n) #> [1] 1.444444 g_i <- snafun::to_igraph(g) g_mean_distance(g_i) #> [1] 1.444444 # # correlation # matrices #  g1 <- sna::rgraph(10,1,tprob=c(0.2,0.2,0.5,0.5,0.8,0.8)) g2 <- sna::rgraph(10,1,tprob=c(0.2,0.2,0.5,0.5,0.8,0.8)) g_correlation(g1, g2) #> [1] 0.09815487 g1 <- to_network(g1); g2 <- to_network(g2) g_correlation(g1, g2) #> [1] 0.09815487 g1 <- to_igraph(g1); g2 <- to_igraph(g2) g_correlation(g1, g2)               #> [1] 0.09815487 #  # reciprocity g <- igraph::erdos.renyi.game(10, .3, type = \"gnp\", directed = TRUE) g_reciprocity(g) #> [1] 0.4 g_reciprocity(snafun::to_network(g)) #> [1] 0.4  g <- snafun::create_random_graph(10, strategy = \"gnm\", m = 2, directed = FALSE, graph = \"igraph\") g_reciprocity(g) #> [1] 1 g_reciprocity(snafun::to_network(g)) #> [1] 1 # # transitivity data(\"emon\", package = \"network\") g <- emon$Cheyenne is_directed(g)  # TRUE #> [1] TRUE g_transitivity(g) #> [1] 0.593361 g_transitivity(to_network(g)) #> [1] 0.593361  data(florentine, package = \"snafun\") g <- florentine$flobusiness is_directed(g)  # FALSE #> [1] FALSE g_transitivity(g) #> [1] 0.4166667 g_transitivity(to_network(g)) #> [1] 0.4166667 # # diameter g <- igraph::make_ring(10) g2 <- igraph::delete_edges(g, c(1,2,1,10)) igraph::diameter(g2, unconnected=TRUE) #> [1] 7 igraph::diameter(g2, unconnected=FALSE) #> [1] Inf g_diameter(g2)  # 7 #> [1] 7 g_diameter(g2, unconnected = FALSE)  # Inf #> [1] Inf  g_diameter(to_network(g2)) # 7 #> [1] 7 g_diameter(to_network(g2), unconnected = FALSE) # Inf #> [1] Inf # # radius g_i <- snafun::create_random_graph(10, strategy = \"gnp\", p = .2,     directed = TRUE, graph = \"igraph\") # add isolate g_i_iso <- igraph::add_vertices(g_i, nv = 1) igraph::radius(g_i) #> [1] 2 snafun::v_eccentricity(g_i) #>  [1] 2 2 3 3 3 3 3 2 3 3 snafun::extract_isolates(g_i_iso) #> [1] 11 snafun::v_eccentricity(g_i_iso)  # the isolate has eccentricity 0 #>  [1] 2 2 3 3 3 3 3 2 3 3 0 igraph::radius(g_i_iso)  # also 0, should raise a flag about isolates #> [1] 0 g_radius(g_i, mode = \"all\") #> [1] 2 g_radius(g_i, mode = \"in\") #> [1] 0 g_radius(g_i, mode = \"out\") #> [1] 2  g_n <- snafun::to_network(g_i) g_radius(g_n, mode = \"all\") #> [1] 2 g_radius(g_n, mode = \"in\") #> [1] 0 g_radius(g_n, mode = \"out\") #> [1] 2 # # compactness g_i <- snafun::create_random_graph(10, strategy = \"gnp\", p = .2,     directed = TRUE, graph = \"igraph\") # add isolate g_i_iso <- igraph::add_vertices(g_i, nv = 1) g_n <- snafun::to_network(g_i) g_n_iso <- snafun::to_network(g_i_iso) g_compactness(g_i) #> [1] 0.4883333 g_compactness(g_n) #> [1] 0.4883333 g_compactness(g_i, mode = \"all\")   # if direction is irrelevant #> [1] 0.6666667 g_compactness(g_i_iso) #> [1] 0.3995455 g_compactness(g_n_iso) #> [1] 0.3995455  g1 <- igraph::graph_from_literal(A-B-C-D-E-F) g2 <- igraph::delete_edges(g1, 5) g3 <- igraph::delete.edges(g1, 3) #> Warning: `delete.edges()` was deprecated in igraph 2.0.0. #> ℹ Please use `delete_edges()` instead. g4 <- igraph::delete_edges(g1, c(4, 5)) g5 <- igraph::delete_edges(g1, c(2, 4)) g_compactness(g1) #> [1] 0.58 g_compactness(g2) #> [1] 0.4277778 g_compactness(g3) #> [1] 0.3333333 g_compactness(g4) #> [1] 0.2888889 g_compactness(g5) #> [1] 0.2 # # degree distribution g <- snafun::create_random_graph(1000, \"gnp\", p = .01) g_degree_distribution(g) #>      1     2     3     4     5     6     7     8     9    10    11    12    13 #> [1,] 0 0.001 0.005 0.009 0.015 0.041 0.064 0.088 0.118 0.124 0.128 0.108 0.093 #>         14    15    16    17    18    19    20    21 #> [1,] 0.075 0.053 0.036 0.019 0.008 0.005 0.007 0.003"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":null,"dir":"Reference","previous_headings":"","what":"Centralization — g_centralize","title":"Centralization — g_centralize","text":"Centralization around several vertex measures","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Centralization — g_centralize","text":"","code":"g_centralize(   x,   measure = \"betweenness\",   directed = TRUE,   mode = c(\"all\", \"out\", \"in\"),   k = 3,   damping = 0.85,   normalized = TRUE,   method = c(\"freeman\", \"sd\") )"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Centralization — g_centralize","text":"x graph measure character, name centrality index needs used directed logical, graph considered directed (undirected, ignored) mode parameter several centrality indices k parameter v_geokpath damping parameter v_pagerank normalized Logical scalar. Whether normalize graph level centrality score dividing theoretical maximum. used method == \"freeman\". method character, either \"freeman\" (default) \"sd\"","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Centralization — g_centralize","text":"method == \"freeman\" list, method == \"sd\" numeric. See Details info.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Centralization — g_centralize","text":"Centralization method creating graph level centralization measure centrality scores vertices. Centralization general method calculating graph-level centrality score based vertex-level centrality measure. many ways aggregating vertex-level centrality scores graph-level centralization. common method Freeman method. formula $$C(G)=\\sum_v (\\max_w c_w - c_v)$$ \\(c_v\\) centrality vertex \\(v\\). summed absolute deviation maximum C G. Generally, value normalized theoretical maximum centralization score, conditional graph values arguments (choice mode directed). Freeman method implemented method == \"freeman\". default. method chosen, function returns list following components: centralization graph level centrality index. theoretical_max maximum theoretical graph level     centralization score graph given number vertices,     using parameters. normalized argument     TRUE, result divided number. calculating Freeman centralization native packages, see centralize (igraph objects) centralization (network objects). \"freeman\" \"method implemented \"betweenness\", \"closeness\", \"degree\", \"eigenvector\".#' alternative way calculating centralization taking standard deviation vertex-level scores. method implemented method == \"sd\". method chosen, function returns value standard deviation. \"sd\" method implemented centrality indices \"betweenness\", \"closeness\", \"degree\", \"eccentricity\", \"eigenvector\", \"geokpath\", \"harmonic\", \"pagerank\", \"shapley\", \"stress\".","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_centralize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Centralization — g_centralize","text":"","code":"# A BA graph is quite centralized g <- igraph::sample_pa(1000, m = 4) g_centralize(g, \"degree\", method = \"freeman\") #> $centralization #> [1] 0.1534701 #>  #> $theoretical_max #> [1] 1994004 #>  g_centralize(snafun::to_network(g), \"degree\", method = \"freeman\") #> $centralization #> [1] 0.1534701 #>  #> $theoretical_max #> [1] 1994004 #>  g_centralize(g, \"betweenness\", method = \"freeman\") #> $centralization #> [1] 0.001418214 #>  #> $theoretical_max #> [1] 996004998 #>  g_centralize(g, \"betweenness\", method = \"freeman\", directed = FALSE) #> $centralization #> [1] 0.2390259 #>  #> $theoretical_max #> [1] 498002499 #>  g_centralize(g, \"betweenness\", method = \"freeman\") #> $centralization #> [1] 0.001418214 #>  #> $theoretical_max #> [1] 996004998 #>  g_centralize(g, \"closeness\", method = \"freeman\") #> $centralization #> [1] 0.4136059 #>  #> $theoretical_max #> [1] 499.2499 #>  g_centralize(g, \"closeness\", method = \"freeman\", mode = \"out\") # can be NaN #> $centralization #> [1] NaN #>  #> $theoretical_max #> [1] 998.001 #>  # eigenvector does not work for this directed graph, so make it undirected g_centralize(g, \"eigenvector\", method = \"freeman\", directed = FALSE)  #> $centralization #> [1] 0.941694 #>  #> $theoretical_max #> [1] 998 #>   # The most centralized graph according to eigenvector centrality g0 <- igraph::make_graph(c(2,1), n = 10, dir = FALSE) g1 <- igraph::make_star(10, mode = \"undirected\") g_centralize(g0, \"eigenvector\", method = \"freeman\")$centralization #> [1] 1 g_centralize(g1, \"eigenvector\", method = \"freeman\")$centralization #> [1] 0.75  # method sd g_centralize(g, \"degree\", method = \"sd\") #> [1] 20.05497 g_centralize(g, \"degree\", method = \"sd\", mode = \"out\") #> [1] 0.1730027 g_centralize(g, \"betweenness\", method = \"sd\") #> [1] 81.51237 g_centralize(g, \"betweenness\", method = \"sd\", directed = FALSE) #> [1] 6611.934 g_centralize(g, \"betweenness\", method = \"sd\") #> [1] 81.51237 g_centralize(g, \"closeness\", method = \"sd\") #> [1] 3.230691e-05 g_centralize(g, \"closeness\", method = \"sd\", mode = \"out\")  #> [1] 0.04703194 g_centralize(g, \"eccentricity\", method = \"sd\") #> [1] 0.402931 g_centralize(g, \"eigenvector\", directed = FALSE, method = \"sd\") #> [1] 0.02310723 g_centralize(g, \"geokpath\", method = \"sd\", k = 4) #> [1] 0.04469897 g_centralize(g, \"geokpath\", method = \"sd\", k = 2) #> [1] 175.9244 g_centralize(g, \"harmonic\", method = \"sd\") #> [1] 36.75391 g_centralize(g, \"pagerank\", method = \"sd\", damping = .9) #> [1] 0.007685786 g_centralize(g, \"pagerank\", method = \"sd\", damping = .5) #> [1] 0.003576802 g_centralize(g, \"shapley\", method = \"sd\") #> [1] 3.133777 g_centralize(g, \"stress\", method = \"sd\") #> [1] 116.0976"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_efficiency.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Graph Efficiency — g_efficiency","title":"Compute Graph Efficiency — g_efficiency","text":"Computation efficiency network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_efficiency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Graph Efficiency — g_efficiency","text":"","code":"g_efficiency(g, diag = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_efficiency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Graph Efficiency — g_efficiency","text":"g graph, object class igraph, network, matrix, data.frame (edgelist) diag TRUE diagonal contains valid data; default, diag==FALSE.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_efficiency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Graph Efficiency — g_efficiency","text":"single numeric value 0 (completely inefficient graph) 1 (maximally efficient graph). value 0 can occur network disconnected.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_efficiency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Graph Efficiency — g_efficiency","text":"function able calculate efficiency network class igraph. function calculation efficiency, require conversion igraph object network object non-sparse adjacency matrix. current function conversion non-sparse adjacency matrix hood feeds  efficiency actual calculation. Edge weights included algorithm, graph  dichotomized default.  Make sure feed multiplex graphs algorithm,  obvious define graph efficiency case. sna help: Let G= G_1 U ... U G_n digraph weak components  G_1,G_2,...,G_n.  convenience, denote cardinalities  components' vertex sets |V(G)|=N |V(G_i)|=N_i,  1,...,n.  Krackhardt efficiency G given  1 - ( |E(G)| - Sum(N_i-1,=1,..,n) )/( Sum(N_i(N_i-1) - (N_i-1),=1,..,n) )  can interpreted 1 minus proportion  possible 'extra' edges (needed weakly connect  existing components) actually present graph.  graph efficiency 1 precisely many edges  needed connect components; additional  edges added, efficiency gradually falls towards 0.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":null,"dir":"Reference","previous_headings":"","what":"secrecy index — g_secrecy","title":"secrecy index — g_secrecy","text":"Calculates graph level secrecy index graph vertices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"secrecy index — g_secrecy","text":"","code":"g_secrecy(g, type = 0, p = 0.25, digits = 3)  v_secrecy(g, type = 1, p = 0.25, digits = 3)"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"secrecy index — g_secrecy","text":"g graph class igraph, network, matrix type numeric, secrecy type needs returned: 0, 1, 2, 3. p probability, needed type == 0 type == 2 digits number decimals used","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"secrecy index — g_secrecy","text":"data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"secrecy index — g_secrecy","text":"secrecy measure useful covert networks members want remain undetected law enforcement agencies (LEA's), even peers detected. secrecy measure defined fraction network remains unexposed single member network detected. Hence, score runs 0 (= everybody gets exposed soon 1 person exposed) 1 (= nobody gets exposed 1 person exposed). real cases, boundary values 0 1 occur pathological networks. relies two things: 1. probability individual becoming exposed LEA conducts surveillance; 2. fraction network exposed member network becomes detected surveillance. several ways computing network's secrecy. S1 assumes every actor probability detected surveillance (p = 1/number_of_vertices) defines secrecy individual 'contributes' network fraction individuals remain unexposed upon monitoring individual links neighbors detected. S2 assumes whenever individual network monitored, communication one neighbors detected independently probability p. case p = 1 therefore corresponds measure S1. individual di neighbors number neighbors detected binomially distributed. S1, assumed every actor probability detected surveillance (p = 1/number_of_vertices). calculation S2 requires user specify reasonable value p, may obvious. S3 longer assumes = 1/n V (S1 S2). can argued = 1/n fair assumption covert operation initial phase. However, operation passed initial stage probability exposure vary among network members. happens certain individuals, due central position network, likely discovered. S3 captured equilibrium distribution random walk graph. random walk chooses next vertex random neighbors current vertex including . NOTE: measure S3 can break certain graphs longer bound \\[0,1\\]. Discard S3 situations. function either returns one three secrecy measures (specified type) data.frame containing three. type == 0 type == 2, reasonable value p specified. function g_secrecy returns overall secrecy score graph: fraction vertices graph expected remain unexposed single surveillance single vertex exposed LEA. , default scenario type = 0. function v_secrecy returns secrecy score per vertex, fraction vertices graph remain unexposed surveillance vertex exposed multiplied probability vertex exposed begin . words: 1 vertex graph exposed, fraction vertices likely remain unexposed, due vertex ? indeed determined number neighbors risk one exposed. scenarios 1 2, vertices probability exposed, secrecy score proportional fraction leave unexposed captured. scenario 3, central vertices likely exposed , central vertices lower secrecy vertices (number neighbors): central vertices easily exposed therefore threaten secrecy graph . , default scenario type = 1. Note graph-level secrecy score equal (barring rounding differences) sum vertex-level secrecy scores.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"secrecy index — g_secrecy","text":"formulas come Lindelauf, R., Borm, P., & Hamers, H. (2009). influence secrecy communication structure covert networks. Social Networks, 31(2), 126-137.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_secrecy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"secrecy index — g_secrecy","text":"","code":"if (FALSE) { # \\dontrun{ data(Madrid_bombing, package = \"snafun\") g <- Madrid_bombing[[25]] g_secrecy(g) # all three measures, p = .25 g_secrecy(g, p = .1) # all three measures, p = .1 g_secrecy(g, type = 1)  # only S1  v_secrecy(g, type = 0) # almost the same, difference only due to rounding of each score v_secrecy(g, type = 0) |> colSums() } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_attack.html","id":null,"dir":"Reference","previous_headings":"","what":"Vulnerability: attack — g_vuln_attack","title":"Vulnerability: attack — g_vuln_attack","text":"Check vulnerability graph attack vertices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_attack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vulnerability: attack — g_vuln_attack","text":"","code":"g_vuln_attack(g, mode = c(\"all\", \"out\", \"in\"), weight = NA, k = 10, digits = 4)"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_attack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vulnerability: attack — g_vuln_attack","text":"g graph, object class igraph, network, matrix mode Character constant, gives whether shortest paths vertices calculated directed graphs. shortest paths direction edges taken, paths go direction edge. , default, corresponding undirected graph used, ie. edge direction taken account. argument ignored undirected graphs. weight Possibly numeric vector giving edge weights. NA–default– weights used (even graph weight attribute). set NULL graph weight edge attribute (exact name!), edge attribute used calculation distances. k number simulations random scenario. digits number decimals output","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_attack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vulnerability: attack — g_vuln_attack","text":"numeric matrix appropriately named columns","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_attack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vulnerability: attack — g_vuln_attack","text":"Many complex systems display surprising degree tolerance errors. However, error tolerance frequently comes high price networks become quite vulnerable attacks (, removal nodes play vital role maintaining network's connectivity). function drops vertices graph according four different regimes. Every time, one vertex removed, next one well, et cetera, network become empty. network performance measure implemented total number vertices can reached vertices network. Mathematically, equivalent number geodesics finite length. fact, number normalized, value shows fraction \"total number vertices can reached vertices original network\" lost removal specific vertex–number cumulative. first vertex removed, total number vertices can reached vertices network recalculated. course, number vertices can reached reduced already fact now one vertex less can reached can start geodesic. network becomes emptier, vertices may become isolates, longer reduction total number vertices can reached given vertex removed. algorithm useful show (groups vertices) critical functioning graph attack approach yields best results. Scenario 1: vertices removed based betweenness score original graph. First vertex removed highest betweenness, one second highest betweenness, etc. column Betw.-based. Say, first vertex score 0.40. means 40 percent vertex pairs (directed, including pairs include vertex ) reach vertex removed can longer reach . Hence, 60 percent reachable paths remain. second vertex score 0.45, means removing second vertex removed additional 5 percent original reachable paths. Scenario 2: vertices removed based degree original graph. First vertex removed highest degree, one second highest degree, etc. column Degree-based. Scenario 3: vertices removed based betweenness score active graph. First vertex removed highest betweenness. , betweenness scores recalculated new, smaller graph. mimicks case graph resettles attack/failure, redistributing load across remaining vertices. , vertex highest betweenness new graph removed. , betweenness scores recalculated new, smaller graph vertex highest betweenness new graph removed. Etc. column Cascade. Scenario 4: vertices removed random. done k times average effect determined removing 1 random vertex, 2 random vertices, etc. useful check vulnerable network random attack random drop-. Random column. PropRemoved column details proportion vertices removed row. Expected shows score one expect see connected network density. useful see whether network affected faster slower expect random connected network. Note number correct potential isolates network.","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":null,"dir":"Reference","previous_headings":"","what":"Vulnerability: efficiency — g_vuln_efficiency","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"vulnerability network, terms change necessary path lengths.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"","code":"g_vuln_efficiency(   g,   method = c(\"harmonic\", \"sum\"),   mode = c(\"all\", \"out\", \"in\"),   weight = NA,   disconnected = c(\"size\", \"max\", \"infinite\"),   digits = 3 )"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"g object class igraph, network, matrix method Either \"harmonic\" (default) \"sum\". Denotes method use measure efficiency. mode Character constant, gives whether shortest paths vertices calculated directed graphs. shortest paths direction edges taken, paths go direction edge. , default, corresponding undirected graph used, ie. edge direction taken account. argument ignored undirected graphs. weight Possibly numeric vector giving edge weights. NA–default– weights used (even graph weight attribute). set NULL graph weight edge attribute, edge attribute used calculation distances. disconnected deal disconnected vertices. See Details. irrelevant fully connected graphs need set. default disconnected == \"size\". digits number decimals vuln_prop.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"vertex removed network, vertices might able reach efficiently anymore. example, -B-C, removal vertex B requires C connect vertices B, might require steps. \"efficiency\" graph can defined many ways, adopt two common definitions: sum geodesic lengths pair vertices harmonic mean lengths. latter default function. Actually, measure captures **lack** efficiency: efficient network, lower sum harmonic mean geodesic lengths. result, efficiency score might appropriately called \"inefficiency,\" use term \"efficiency\" compatibility literature. algorithm calculates change efficiency due vertex increase summed geodesic lengths (across whole network)–harmonic mean lengths–vertex removed. Note measure comparable graphs different sizes; therefore mainly useful find vertices (, perhaps, least) critical influence graph. output includes column vuln_prop ratio harmonic mean (: total) geodesic lengths removing vertex removing ( correcting paths ). example, ratio 1.5, efficiency (without paths ) decreases 50 score 1 means effect efficiency graph vertex removed graph. graph fully connected, geodesic disconnected vertices defined commonly reported infinite. Using infinite distances renders efficiency calculations largely useless, since makes summed geodesic lengths infinite well can even lead infinite reduction summed geodesic lengths disconnected vertex removed graph. Therefore, default function set distance disconnected vertex n + 1, n equal number vertices original graph (ie. \"size\" graph removing vertices). disconnected == \"size\". weighted graph used (weight argument specified appropriately), distance disconnected vertex set n*maximum_weight + 1. course, somewhat arbitrary choice. Alternatively, \"max\" sets \"maximum distance + 1\" (graph removing vertices). edge weight specified, used well. argument disconnected == \"infinite\" maintains Inf value geodesic lengths paths disconnected vertices. Alternatively, one can also provide numeric value disconnected. case, Inf values replaced number. vector length larger 1 specified disconnected, first value used .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_efficiency.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Vulnerability: efficiency — g_vuln_efficiency","text":"function inspired  swan_efficiency function. function robust lot useful (e.g., original function useless -fully connected graphs.) function yields SCORE swan_efficiency g_vuln_efficiency(g, method = \"sum\", weight = NULL, disconnected = \"infinite\").","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Vulnerability: paths — g_vuln_paths","title":"Vulnerability: paths — g_vuln_paths","text":"vulnerability network, terms vanishing path vertices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vulnerability: paths — g_vuln_paths","text":"","code":"g_vuln_paths(g, mode = c(\"all\", \"out\", \"in\"), weight = NULL, digits = 3)"},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vulnerability: paths — g_vuln_paths","text":"g graph, object class igraph, network, matrix mode Character constant, gives whether shortest paths vertices calculated directed graphs. shortest paths direction edges taken, paths go direction edge. , default, corresponding undirected graph used, ie. edge direction taken account. argument ignored undirected graphs. weight Possibly numeric vector giving edge weights. NULL–default–graph weight edge attribute, attribute used calculation distances. NA weights used (even graph weight attribute). digits number decimals vuln_prop.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vulnerability: paths — g_vuln_paths","text":"data.frame score per vertex","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vulnerability: paths — g_vuln_paths","text":"vertex removed network, vertices might able reach anymore. algorithm calculates number pairs vertices can longer reach without vertex network, able reach network. formally, compare number pairs vertices connecting path removing vertex . function returns change score vertex. ith value number pairs vertices become disconnected vertex removed network (leaving everything else ). output includes column vuln_prop ratio number disconnected pairs removing vertex removing ( correcting paths ). example, ratio 1.5, number disconnected pairs vertices increases 50 removing vertex (discarding paths ). score 1 means effect vertex-pair disconnectedness vertex removed graph. value Inf occurs vertices connected removed, removing became disconnected. makes proportion Infinite since number relative original number disconnected vertices, 0.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/g_vuln_paths.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Vulnerability: paths — g_vuln_paths","text":"function inspired  swan_connectivity.  However, function incorrect network fully connected. Moreover, correct ties vertex deleted. implementation snafun package corrects . addition, robust useful.","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for the existence of edge attributes in the graph — has","title":"Check for the existence of edge attributes in the graph — has","text":"Check existence edge attributes graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for the existence of edge attributes in the graph — has","text":"","code":"has_edge_attributes(x)  has_vertex_attributes(x)  has_vertex_attribute(x, attrname)  has_edge_attribute(x, attrname)  has_vertexnames(x)  has_loops(x)  has_isolates(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for the existence of edge attributes in the graph — has","text":"x graph class igraph network attrname name attribute check ","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for the existence of edge attributes in the graph — has","text":"logical","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check for the existence of edge attributes in the graph — has","text":"Simple utility function returns TRUE graph edge attributes FALSE otherwise.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Check for the existence of edge attributes in the graph — has","text":"has_edge_attributes(): Check whether graph edge attributes has_vertex_attributes(): Check whether graph vertex attributes (attribute called \"na\" count, internal attribute network package) has_vertex_attribute(): Check whether graph specific vertex attribute (attribute called \"na\" count, internal attribute network package) has_edge_attribute(): Check whether graph specific edge attribute has_vertexnames(): Check whether graph vertex names. function merely checks presence vertex attribute name (network class igraph) vertex.names (network class network). Note network package tends create vertex names default, even added separate attributes. case, vertices named integers running  1 number vertices. course, function can distinguish whether names researcher want use names, purely result default behavior network package (meaningful names per se). has_loops(): Check whether graph contains least one loop (ie. edge vertex ). Also works matrix. has_isolates(): Check whether graph contains least one isolate vertex. Returns TRUE FAlsE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/has.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for the existence of edge attributes in the graph — has","text":"","code":"data(florentine, package = \"snafun\") has_vertexnames(florentine$flobusiness)      # TRUE #> [1] TRUE  has_edge_attributes(florentine$flobusiness)  # FALSE #> [1] FALSE has_edge_attributes(florentine$flomarriage)  # TRUE #> [1] TRUE  has_loops(florentine$flobusiness) #> [1] FALSE g <- igraph::graph( c(1,1,2,2,3,3,4,5)) has_loops(g) #> [1] TRUE m <- matrix(c(1, 0, 0, 0, 0, 1, 0, 1, 1), byrow = TRUE, ncol = 3) has_loops(m)                                 # TRUE #> [1] TRUE diag(m) <- 0 has_loops(m)                                 # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the network bipartite? — is_bipartite","title":"Is the network bipartite? — is_bipartite","text":"Check network bipartite","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the network bipartite? — is_bipartite","text":"","code":"is_bipartite(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the network bipartite? — is_bipartite","text":"x graph x class network igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the network bipartite? — is_bipartite","text":"TRUE FALSE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the network bipartite? — is_bipartite","text":"function simply checks x bipartite network. possible checking whether bipartite attributes set x. Hence, network bipartite, researcher neglected include information graph x, result functions FALSE. course, : neglecting include bipartite attribute x bad practice.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_bipartite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is the network bipartite? — is_bipartite","text":"","code":"net <- igraph::sample_bipartite(10, 5, p =.1) is_bipartite(net)  # TRUE #> [1] TRUE  net <- igraph::erdos.renyi.game(10, p.or.m = .1, type = \"gnp\") is_bipartite(net)  # FALSE #> [1] FALSE  mat <- sna::rgraph(10, m = 1, tprob = .1) net <- network::as.network.matrix(mat) is_bipartite(net)  # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the network connected? — is_connected","title":"Is the network connected? — is_connected","text":"Check network connected","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the network connected? — is_connected","text":"","code":"is_connected(x, rule = c(\"weak\", \"strong\"))"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the network connected? — is_connected","text":"x graph type igraph network rule character, either \"strong\" \"weak\"","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the network connected? — is_connected","text":"logical","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the network connected? — is_connected","text":"rule determined graph connected can either \"weak\" \"strong\". \"weak\", vertex $$ connected $j$ iff exists semi-path $$ $j$ (.e., path weakly symmetrized graph). \"strong\", vertex $$ connected $j$ iff exists direct path $$ $j$  direct path $j$ $$. words: graph said \"strongly connected\" every pair vertices($$, $j$) graph contains path following directions edges. unweighted directed graph G, every pair vertices $$ $j$ path direction .e., bidirectional path. elements path matrix graph contain 1’s. graph \"weakly connected\" considering $undirected$ graph connected, e.e., every pair distinct vertices $$ $j$ exists undirected path (potentially running opposite direction edge) $$ $j$. strongly connected graph also weakly connected. Note rules distinct directed graphs ; x symmetric, rule effect. undirected graph get label \"strongly\" \"weakly\" connected, connected .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_connected.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is the network connected? — is_connected","text":"","code":"strong_i <- igraph::graph_from_literal(a --+ b --+ c --+ a) is_connected(strong_i, \"weak\")  # TRUE #> [1] TRUE is_connected(strong_i, \"strong\")  # TRUE #> [1] TRUE strong_n <- snafun::to_network(strong_i) is_connected(strong_n, \"weak\")  # TRUE #> [1] TRUE is_connected(strong_n, \"strong\")  # TRUE #> [1] TRUE  weak_i <- igraph::graph_from_literal(a --+ b +-- c) is_connected(weak_i, \"weak\")  # TRUE #> [1] TRUE is_connected(weak_i, \"strong\")  # FALSE #> [1] FALSE weak_n <- snafun::to_network(weak_i) is_connected(weak_n, \"weak\")  # TRUE #> [1] TRUE is_connected(weak_n, \"strong\")  # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the network directed? — is_directed","title":"Is the network directed? — is_directed","text":"Check network directed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the network directed? — is_directed","text":"","code":"is_directed(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the network directed? — is_directed","text":"x graph x","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the network directed? — is_directed","text":"logical, TRUE FALSE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the network directed? — is_directed","text":"function checks x directed network. x class igraph network, function checks appropriate attribute graph x. matrix function returns TRUE matrix symmetric. data.frame function returns TRUE reciprocity network exactly 0 1.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Is the network directed? — is_directed","text":"largely based similar functions excellent migraph package. methods licensed MIT license combination copyright James Hollway.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_directed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is the network directed? — is_directed","text":"","code":"data(florentine, package = \"snafun\") is_weighted(florentine$flobusiness)   # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the network signed? — is_signed","title":"Is the network signed? — is_signed","text":"Check network signed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the network signed? — is_signed","text":"","code":"is_signed(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the network signed? — is_signed","text":"x graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the network signed? — is_signed","text":"logical, TRUE FALSE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the network signed? — is_signed","text":"signed igraph network object \"sign\" attribute. matrix data.frame, signed network recognized presence positive negative ties, values integers. signed graph positive integer values recognized (pathologial anyway). Specifially, data.frame, check conducted third column, logical column hold signs.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Is the network signed? — is_signed","text":"functions excellent migraph package. methods licensed MIT license combination copyright James Hollway.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_signed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is the network signed? — is_signed","text":"","code":"data(florentine, package = \"snafun\") is_signed(florentine$flobusiness)   # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":null,"dir":"Reference","previous_headings":"","what":"Is something? — is_something","title":"Is something? — is_something","text":"Check network something specific.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is something? — is_something","text":"","code":"is_network(x)  is_igraph(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is something? — is_something","text":"x graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is something? — is_something","text":"logical, TRUE FALSE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is something? — is_something","text":"Check various \"identities\" input object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Is something? — is_something","text":"is_network(): Check whether graph class network is_igraph(): Check whether graph class igraph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_something.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is something? — is_something","text":"","code":"data(florentine, package = \"snafun\") is_network(florentine$flobusiness)   # FALSE #> [1] FALSE is_igraph(florentine$flobusiness)   # TRUE #> [1] TRUE data(emon, package = \"network\") is_network(emon$Cheyenne)   # TRUE #> [1] TRUE is_igraph(emon$Cheyenne)   # FALSE #> [1] FALSE"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the network weighted? — is_weighted","title":"Is the network weighted? — is_weighted","text":"Check network weighted","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the network weighted? — is_weighted","text":"","code":"is_weighted(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/is_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the network weighted? — is_weighted","text":"x graph x class network, igraph, matrix, data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the network weighted? — is_weighted","text":"TRUE FALSE","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/is_weighted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the network weighted? — is_weighted","text":"function checks x weighted network. x class igraphor network, function checks appropiate attribute graph x. matrix function returns TRUE elements 1. data.frame function returns TRUE contains numeric column called \"weight\", addition first two columns senders receivers.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/judge_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Judges network — judge_net","title":"Judges network — judge_net","text":"Network judges one Polish regional courts. Relation indicates judges ruled least one case together.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/judge_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Judges network — judge_net","text":"","code":"data(judge_net, package = \"snafun\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/judge_net.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Judges network — judge_net","text":"Object class igraph size 40, undirected, predefined layout.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/judge_net.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Judges network — judge_net","text":"calculation Michal Bojanowski, based SAOS. Originally published isnar package isnar.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/judge_net.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Judges network — judge_net","text":"Node attributes include gender code division.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/list_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"List the attributes in the graph object — list_attributes","title":"List the attributes in the graph object — list_attributes","text":"List attributes graph object using consistent API","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/list_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List the attributes in the graph object — list_attributes","text":"","code":"list_vertex_attributes(x)  list_edge_attributes(x)  list_graph_attributes(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/list_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List the attributes in the graph object — list_attributes","text":"x graph object class igraph network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/list_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List the attributes in the graph object — list_attributes","text":"names requested attributes ()","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/Madrid_bombing.html","id":null,"dir":"Reference","previous_headings":"","what":"Madrid Train Bombing 2004 (dataset) — Madrid_bombing","title":"Madrid Train Bombing 2004 (dataset) — Madrid_bombing","text":"time series treat specific attacks endpoints depict evolution relations individuals indirectly directly associated Madrid train bombing. http://en.wikipedia.org/wiki/2004_Madrid_train_bombings 1-mode stacked matrices 55 x 55 person person, data 20 time periods plus kinship data tie extinguished data. Codebook available http://doitapps.jjay.cuny.edu/jjatt/files/Relations_Codebook_Public_Version2.pdf","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/Madrid_bombing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Madrid Train Bombing 2004 (dataset) — Madrid_bombing","text":"","code":"data(Madrid_bombing, package = \"snafun\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/Madrid_bombing.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Madrid Train Bombing 2004 (dataset) — Madrid_bombing","text":"list igraph objects","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/Madrid_bombing.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Madrid Train Bombing 2004 (dataset) — Madrid_bombing","text":"Available Manchester (https://sites.google.com/site/ucinetsoftware/datasets/covert-networks) http://doitapps.jjay.cuny.edu/jjatt/data.php. Converted R format networkdata package David Schoch.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":null,"dir":"Reference","previous_headings":"","what":"Make an edgelist from row data — make_edgelist","title":"Make an edgelist from row data — make_edgelist","text":"Makes edge list row data.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make an edgelist from row data — make_edgelist","text":"","code":"make_edgelist(names = NULL, attribute = NULL)"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make an edgelist from row data — make_edgelist","text":"names data frame N columns first one survey respondents (edge origin), columns express destination edge attribute data frame dimensions data frame names, column corresponding attribute structure names data frame.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make an edgelist from row data — make_edgelist","text":"data frame edge list one edge attribute","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make an edgelist from row data — make_edgelist","text":"function processes row network data producing list edges. function returns data frame. argument `names` specified, function returns data frame two columns, indicating node link comes column one (respondents) node link directed column two (alters). argument `attribute` also specified, function returns data frame three columns. first two columns , third column contain information one edge attribute possible process one attribute time. needed, possible use function different attributes merge output data frame using `cbind()`. function takes data frames input first column input data frame needs express nodes originating edges. user provide values respondent-alter relationships edge attributes order.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_edgelist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make an edgelist from row data — make_edgelist","text":"","code":"if (FALSE) { # \\dontrun{ namedf <- data.frame(respondent = c('A', 'B', 'C'),                       alter1 = c('D', 'C', 'A'),                       alter2 = c('B', 'A', 'A') ) attributedf <- data.frame(attributeCol1 = 1:3, attributeCol2 = 4:6)  edgelist <-  make_edgelist(names =  namedf, attribute = attributedf) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"Create matrix based vertex attribute","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"","code":"make_matrix_from_vertex_attribute(   x,   name,   measure = c(\"absdiff\", \"diff\", \"sum\", \"max\", \"min\", \"mean\", \"sender\", \"receiver\",     \"equal\"),   diag = FALSE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"x input, vector object class igraph network name name attribute extracted. used x class igraph network measure character, currently choice \"absdiff\", \"diff\", \"sum\", \"max\", \"min\". default value \"absdiff\" diag FALSE (default), diagonal zero. anything else, diagonal filled (fits)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"function creates matrix basis vertex attribute object class igraph network. case, vertex attribute provided name argument extracted. Alternatively, x can numeric vector provided user. vector/attribute used construct valued matrix, can fed igraph network use. function hosts several options create valued matrix : absdiff absolute difference values two vertices diff difference returned, value vertex lower vertex index minus value vertex higher vertex index. value can negative. sum sum values vertices max highest value two vertices min highest value two vertices mean mean two vertices sender value sender's attribute entire row receiver value receiver's attribute entire column equal 1 vertices attribute, 0 otherwise options speak . sender option used model sender effect. example, tested whether sender's age drives edges, sender's age edge attribute every edge sender involved . Mathematically, means sender's age cells sender's row. Similarly, receiver option places receiver's attribute column. attribute 'age', makes edge attribute equal receiver's age, every edge vertex receiver. diag == FALSE (default), diagonal returned matrix contain zeroes. diag value, inserted diagonal. Using recycling rules, object fitting length accepted. diag == TRUE, measure also applied diagonal elements.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_matrix_from_vertex_attribute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a matrix from a vertex attribute — make_matrix_from_vertex_attribute","text":"","code":"make_matrix_from_vertex_attribute(1:5) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    2    3    4 #> [2,]    1    0    1    2    3 #> [3,]    2    1    0    1    2 #> [4,]    3    2    1    0    1 #> [5,]    4    3    2    1    0 make_matrix_from_vertex_attribute(1:5, measure = \"sum\", diag = 99) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   99    3    4    5    6 #> [2,]    3   99    5    6    7 #> [3,]    4    5   99    7    8 #> [4,]    5    6    7   99    9 #> [5,]    6    7    8    9   99 make_matrix_from_vertex_attribute(1:5, measure = \"max\", diag = NA) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA    2    3    4    5 #> [2,]    2   NA    3    4    5 #> [3,]    3    3   NA    4    5 #> [4,]    4    4    4   NA    5 #> [5,]    5    5    5    5   NA make_matrix_from_vertex_attribute(1:5, measure = \"sum\", diag = TRUE) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    2    3    4    5    6 #> [2,]    3    4    5    6    7 #> [3,]    4    5    6    7    8 #> [4,]    5    6    7    8    9 #> [5,]    6    7    8    9   10 make_matrix_from_vertex_attribute(1:5, measure = \"min\", diag = 11:15) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   11    1    1    1    1 #> [2,]    1   12    2    2    2 #> [3,]    1    2   13    3    3 #> [4,]    1    2    3   14    4 #> [5,]    1    2    3    4   15 make_matrix_from_vertex_attribute(1:5, measure = \"sender\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    1    1 #> [2,]    2    0    2    2    2 #> [3,]    3    3    0    3    3 #> [4,]    4    4    4    0    4 #> [5,]    5    5    5    5    0 make_matrix_from_vertex_attribute(1:5, measure = \"receiver\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    2    3    4    5 #> [2,]    1    0    3    4    5 #> [3,]    1    2    0    4    5 #> [4,]    1    2    3    0    5 #> [5,]    1    2    3    4    0 if (FALSE) { # \\dontrun{ data(florentine, package = \"SNA4DSData\") # absdiff, with zeroes on the diagonal make_matrix_from_vertex_attribute(florentine$floattrs$Wealth) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a mixing matrix — make_mixingmatrix","title":"Construct a mixing matrix — make_mixingmatrix","text":"Construct mixing matrix graph, based specific vertex attribute","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a mixing matrix — make_mixingmatrix","text":"","code":"make_mixingmatrix(x, attrname, by_edge = FALSE, loops = has_loops(x))"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a mixing matrix — make_mixingmatrix","text":"x graph class network igraph attrname character, name attribute name by_edge logical, TRUE full mixing matrix calculated loops logical, loops allowed? default, TRUE graph already least one loop.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a mixing matrix — make_mixingmatrix","text":"table (by_edge FALSE) list two tables (by_edge TRUE)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a mixing matrix — make_mixingmatrix","text":"network mixing matrix , traditionally, two-dimensional cross-classification edges values specific vertex attribute. important tool assessing network homophily seggregation often useful subsequent construction explanatory statistical models network. cell ($$, $j$) mixing matrix reports number edges graph sender value $$ vertex attribute receiver value $j$ vertex attribute. case undirected graph, edge counts twice, $j$ != $j$, since undirected edge MALE FEMALE means also undirected edge FEMALE MALE. argument by_edge set TRUE, list two mixing matrices returned: first contains traditional mixing matrix second contains mixing matrix edges occur graph. two matrices appropriately called \"edge_present\" \"no_edge_present\". mixing matrix includes row column margins. Note can somewhat misleading mixing matrix constructed undirected graph, -diagonal entries mixing matrix occur twice. Therefore, overall sum edges corrects hence equal grand total one expect somply adding row margins column margins. fact, case undirected graph,. correct grand total equal sum elements upper (lower) triangle + summed diagonal. argument loops can set TRUE edges vertex included. default include loops graph already includes loops . Otherwise, generally makes little sense. network package mixingmatrix function works network objects, specific functionality bipartite networks.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_mixingmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a mixing matrix — make_mixingmatrix","text":"","code":"data(emon, package = \"network\") is_directed(emon$LakePomona)   # TRUE #> [1] TRUE network::mixingmatrix(emon$LakePomona, \"Sponsorship\") #>          To #> From      City County Federal Private State Sum #>   City       2      9       3       9    10  33 #>   County     3     10       4       9    13  39 #>   Federal    0      3       0       2     4   9 #>   Private    3     11       4       5    11  34 #>   State      2     13       4       7     7  33 #>   Sum       10     46      15      32    45 148 g <- emon$LakePomona make_mixingmatrix(g, attrname = \"Sponsorship\") #>          to #> from      City County Federal Private State Sum #>   City       2      9       3       9    10  33 #>   County     3     10       4       9    13  39 #>   Federal    0      3       0       2     4   9 #>   Private    3     11       4       5    11  34 #>   State      2     13       4       7     7  33 #>   Sum       10     46      15      32    45 148 make_mixingmatrix(g, attrname = \"Sponsorship\", by_edge = TRUE) #> $edge_present #>          to #> from      City County Federal Private State Sum #>   City       2      9       3       9    10  33 #>   County     3     10       4       9    13  39 #>   Federal    0      3       0       2     4   9 #>   Private    3     11       4       5    11  34 #>   State      2     13       4       7     7  33 #>   Sum       10     46      15      32    45 148 #>  #> $no_edge_present #>          to #> from      City County Federal Private State Sum #>   City      10     11       5      11     6  43 #>   County    17     10       6      16     7  56 #>   Federal    8      7       2       8     4  29 #>   Private   17     14       6      15     9  61 #>   State     14      7       4      13     5  43 #>   Sum       66     49      23      63    31 232 #>  g <- snafun::to_igraph(emon$LakePomona) make_mixingmatrix(g, attrname = \"Sponsorship\") #>          to #> from      City County Federal Private State Sum #>   City       2      9       3       9    10  33 #>   County     3     10       4       9    13  39 #>   Federal    0      3       0       2     4   9 #>   Private    3     11       4       5    11  34 #>   State      2     13       4       7     7  33 #>   Sum       10     46      15      32    45 148 make_mixingmatrix(g, attrname = \"Sponsorship\", by_edge = TRUE) #> $edge_present #>          to #> from      City County Federal Private State Sum #>   City       2      9       3       9    10  33 #>   County     3     10       4       9    13  39 #>   Federal    0      3       0       2     4   9 #>   Private    3     11       4       5    11  34 #>   State      2     13       4       7     7  33 #>   Sum       10     46      15      32    45 148 #>  #> $no_edge_present #>          to #> from      City County Federal Private State Sum #>   City      10     11       5      11     6  43 #>   County    17     10       6      16     7  56 #>   Federal    8      7       2       8     4  29 #>   Private   17     14       6      15     9  61 #>   State     14      7       4      13     5  43 #>   Sum       66     49      23      63    31 232 #>   data(\"judge_net\", package = \"snafun\") is_directed(judge_net)   # FALSE #> [1] FALSE make_mixingmatrix(judge_net, attrname = \"color\") #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #>               from #> to             lightskyblue pink <NA> Sum #>   lightskyblue           21   43    2  66 #>   pink                   43   25    3  71 #>   <NA>                    2    3    0   5 #>   Sum                    66   71    5  94 make_mixingmatrix(judge_net, attrname = \"JudgeSex\") #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #>       from #> to      F  M <NA> Sum #>   F    25 43    3  71 #>   M    43 21    2  66 #>   <NA>  3  2    0   5 #>   Sum  71 66    5  94 g <- suppressWarnings(snafun::to_network(judge_net)) make_mixingmatrix(g, attrname = \"color\") #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #>               from #> to             lightskyblue pink <NA> Sum #>   lightskyblue           21   43    2  66 #>   pink                   43   25    3  71 #>   <NA>                    2    3    0   5 #>   Sum                    66   71    5  94 make_mixingmatrix(g, attrname = \"JudgeSex\") #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #>       from #> to      F  M <NA> Sum #>   F    25 43    3  71 #>   M    43 21    2  66 #>   <NA>  3  2    0   5 #>   Sum  71 66    5  94 make_mixingmatrix(judge_net, attrname = \"color\", by_edge = TRUE) #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #> $edge_present #>               from #> to             lightskyblue pink <NA> Sum #>   lightskyblue           21   43    2  66 #>   pink                   43   25    3  71 #>   <NA>                    2    3    0   5 #>   Sum                    66   71    5  94 #>  #> $no_edge_present #>               from #> to             lightskyblue pink <NA> Sum #>   lightskyblue           84  317   13 414 #>   pink                  317  251   21 589 #>   <NA>                   13   21    0  34 #>   Sum                   414  589   34 686 #>  make_mixingmatrix(judge_net, attrname = \"JudgeSex\", by_edge = TRUE) #>  #> Note:  Marginal totals can be misleading for undirected mixing matrices. #> $edge_present #>       from #> to      F  M <NA> Sum #>   F    25 43    3  71 #>   M    43 21    2  66 #>   <NA>  3  2    0   5 #>   Sum  71 66    5  94 #>  #> $no_edge_present #>       from #> to       F   M <NA> Sum #>   F    251 317   21 589 #>   M    317  84   13 414 #>   <NA>  21  13    0  34 #>   Sum  589 414   34 686 #>"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a node list from row data — make_nodelist","title":"Make a node list from row data — make_nodelist","text":"Makes node list row data.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a node list from row data — make_nodelist","text":"","code":"make_nodelist(names = NULL, attribute = NULL)"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a node list from row data — make_nodelist","text":"names data frame N columns first one survey respondents (edge origin), columns express destination edge attribute vector information node attribute provided order column one names data frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a node list from row data — make_nodelist","text":"vector nodes names data frame nodes names one node attribute #'","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a node list from row data — make_nodelist","text":"function processes row network data producing list nodes. function returns vector `nodes` argument specified data frame `attribute` argument specified . argument `names` specified, function returns vector complete list nodes named row data (respondents alters). arguments `names` `attribute` specified, function returns data frame complete list nodes named survey, column one, attributes nodes column two. attribute information alter unknown value reported missing data. possible process one attribute time. function takes data frames input argument `names` vectors argument `attribute`. user provide values names attributes order. attribute missing shown 0 numeric, FALSE categorical. NOTE: Double check attribute vector passing function. attribute vector shorter number respondent names function still run, output might incorrect.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_nodelist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a node list from row data — make_nodelist","text":"","code":"if (FALSE) { # \\dontrun{ namedf <- data.frame(respondent = c('A', 'B', 'C'),                       alter1 = c('D', 'C', 'A'),                       alter2 = c('B', 'A', 'A') ) attributeV <- c(1:3)  nodelist <-  make_nodelist(names =  namedf, attribute = attributeV) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Perturb a binary graph — make_perturbed_graph","title":"Perturb a binary graph — make_perturbed_graph","text":"Perturb binary graph probabilistically","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perturb a binary graph — make_perturbed_graph","text":"","code":"make_perturbed_graph(   x,   prob_tot = NULL,   prob_0_to_1 = 0,   prob_1_to_0 = 0,   combined = FALSE,   replace = FALSE,   diag = FALSE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perturb a binary graph — make_perturbed_graph","text":"x graph class igraph, network, matrix prob_tot probability edge change (1 0 0 1) prob_0_to_1 probability 0 edge change 1 prob_1_to_0 probability 0 edge change 1 combined logical, see details replace logical, whether draw cells changed replacement diag logical, diagonal (self-loops) allowed change?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perturb a binary graph — make_perturbed_graph","text":"perturbed graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perturb a binary graph — make_perturbed_graph","text":"Given binary (ie. non-weighted) graph, change proportion edges 0 1 1 0. several ways : prob_tot specified combined set FALSE, edges graph probability changing. case, prob_0_to 1 prob_1_to_0 ignored , hence, distinction made edges value 0 value 1. ignore choice prob_0_to 1 prob_1_to_0. prob_tot NULL, edges value 0 change 1 probability prob_0_to 1 edges value 1 change 0 probability prob_1_to 0. prob_tot specified combined set TRUE, first edges value 0 change 1 probability prob_0_to 1 edges value 1 change 0 probability prob_1_to 0. , edges resulting graph perturbated probability prob_tot (potentially reversing previous changes). replace argument allows edges drawn multiple times. means fewer edges change, since edge might change 0 1 multiple times (1 0). likely rarely useful. resulting graph class x.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_perturbed_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perturb a binary graph — make_perturbed_graph","text":"","code":"g <- snafun::create_random_graph(20, \"gnm\", m = 100) make_perturbed_graph(g, prob_tot = .3) #> IGRAPH bffd5ee D--- 20 152 --  #> + edges from bffd5ee: #>  [1]  1-> 5  1-> 7  1->11  1->16  1->17  1->18  2-> 1  2->12  2->15  2->18 #> [11]  2->19  3-> 2  3-> 6  3-> 8  3-> 9  3->11  3->13  3->14  3->20  4-> 8 #> [21]  4->10  4->11  4->14  4->17  4->19  5-> 1  5-> 2  5-> 8  5->10  5->15 #> [31]  6-> 1  6-> 3  6-> 5  6-> 8  6-> 9  6->10  6->13  6->14  6->19  6->20 #> [41]  7-> 2  7-> 3  7-> 4  7-> 6  7-> 8  7->16  7->20  8-> 2  8-> 3  8-> 4 #> [51]  8-> 7  8->12  8->13  8->14  8->16  8->20  9-> 2  9-> 3  9-> 5  9-> 6 #> [61]  9-> 7  9->12  9->13  9->17  9->18  9->20 10-> 7 10->13 10->15 10->18 #> [71] 11-> 3 11-> 5 11-> 6 11-> 9 11->10 11->14 11->17 11->18 12-> 1 12-> 3 #> [81] 12-> 4 12-> 5 12-> 6 12->14 12->17 13-> 2 13-> 5 13-> 9 13->10 13->12 #> + ... omitted several edges # prob_0_to_1 is ignored make_perturbed_graph(g, prob_tot = .3, prob_0_to_1 = 1) #> IGRAPH bffe576 D--- 20 154 --  #> + edges from bffe576: #>  [1]  1-> 2  1-> 9  1->12  1->13  1->17  1->19  1->20  2-> 1  2-> 3  2-> 6 #> [11]  2-> 8  2->10  2->18  2->19  2->20  3-> 2  3-> 6  3->10  3->13  3->14 #> [21]  3->17  3->18  3->19  3->20  4-> 1  4-> 3  4->15  4->16  4->19  4->20 #> [31]  5-> 1  5-> 4  5-> 6  5->13  5->14  5->15  5->17  5->18  5->19  6-> 3 #> [41]  6-> 7  6-> 8  6->10  6->13  6->20  7-> 3  7-> 5  7-> 8  7-> 9  7->10 #> [51]  7->11  7->12  7->15  7->17  7->19  8-> 2  8-> 3  8-> 4  8-> 6  8->12 #> [61]  8->14  8->15  8->17  8->18  8->19  8->20  9-> 4  9-> 5  9-> 6  9->12 #> [71]  9->13  9->16  9->18  9->20 10-> 2 10-> 7 10-> 9 10->13 10->15 10->16 #> [81] 10->19 11-> 3 11-> 6 11-> 9 11->10 12-> 2 12-> 5 12-> 9 12->13 12->17 #> + ... omitted several edges # prob_0_to_1 is used first, then prob_tot make_perturbed_graph(g, prob_tot = .3, prob_0_to_1 = 1, combined = TRUE) #> IGRAPH bfff694 D--- 20 266 --  #> + edges from bfff694: #>   [1] 1-> 2 1-> 3 1-> 4 1-> 5 1-> 6 1-> 7 1-> 8 1-> 9 1->12 1->13 1->15 1->16 #>  [13] 1->17 1->19 1->20 2-> 1 2-> 3 2-> 7 2-> 9 2->12 2->13 2->14 2->16 2->17 #>  [25] 2->20 3-> 2 3-> 4 3-> 5 3-> 6 3-> 7 3-> 9 3->12 3->13 3->14 3->16 3->17 #>  [37] 3->18 3->19 3->20 4-> 2 4-> 3 4-> 5 4-> 6 4-> 7 4-> 8 4-> 9 4->11 4->13 #>  [49] 4->14 4->15 4->17 4->19 4->20 5-> 2 5-> 7 5-> 8 5->12 5->13 5->14 5->16 #>  [61] 5->17 5->18 5->20 6-> 2 6-> 3 6-> 4 6-> 5 6-> 7 6->10 6->11 6->12 6->13 #>  [73] 6->14 6->15 6->16 6->17 6->18 6->19 6->20 7-> 1 7-> 2 7-> 4 7-> 6 7-> 8 #>  [85] 7-> 9 7->10 7->11 7->12 7->13 7->14 7->15 7->16 7->17 7->18 7->19 8-> 1 #>  [97] 8-> 2 8-> 3 8-> 4 8-> 6 8-> 7 8->11 8->13 8->17 8->18 8->20 9-> 2 9-> 6 #> + ... omitted several edges make_perturbed_graph(snafun::to_matrix(g), prob_tot = .3, prob_0_to_1 = 1) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    1    0    0    0    0    0    1    0     0     0     0     1 #>  [2,]    0    0    0    0    1    1    0    1    0     1     0     1     0 #>  [3,]    0    0    0    1    1    0    0    0    1     0     0     0     0 #>  [4,]    0    1    0    0    1    0    0    0    0     0     1     0     0 #>  [5,]    1    1    0    0    0    0    0    0    0     0     1     1     1 #>  [6,]    0    1    0    1    0    0    0    1    0     0     1     0     0 #>  [7,]    1    1    1    0    0    0    0    1    0     1     1     0     0 #>  [8,]    0    1    0    0    0    0    0    0    0     0     0     0     0 #>  [9,]    0    0    0    1    1    0    0    0    0     0     0     1     0 #> [10,]    0    1    0    0    0    0    0    0    1     0     0     0     1 #> [11,]    0    0    1    0    1    0    1    1    0     1     0     0     0 #> [12,]    0    0    0    0    1    0    1    1    1     1     0     0     0 #> [13,]    0    1    1    0    1    0    0    0    0     0     0     1     0 #> [14,]    1    1    1    1    0    1    0    0    1     0     1     0     1 #> [15,]    0    1    1    0    0    0    0    1    0     0     0     0     0 #> [16,]    0    0    1    1    0    1    0    0    0     0     1     0     1 #> [17,]    1    0    1    1    0    0    0    1    1     0     1     0     0 #> [18,]    0    0    0    1    0    1    1    0    0     1     1     0     0 #> [19,]    0    1    0    1    0    1    0    0    1     1     1     0     0 #> [20,]    0    0    0    0    1    1    0    0    0     0     0     0     0 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] #>  [1,]     1     0     1     0     0     1     0 #>  [2,]     1     0     1     0     1     1     0 #>  [3,]     0     0     1     0     1     0     0 #>  [4,]     0     0     1     0     0     0     0 #>  [5,]     1     1     1     1     1     1     0 #>  [6,]     0     0     1     0     1     1     1 #>  [7,]     0     0     1     0     0     1     0 #>  [8,]     1     0     0     1     0     1     0 #>  [9,]     0     0     0     0     0     0     0 #> [10,]     1     1     0     0     0     1     0 #> [11,]     1     0     0     1     0     0     0 #> [12,]     1     0     1     0     1     0     0 #> [13,]     1     0     1     0     1     1     1 #> [14,]     0     1     0     1     0     0     1 #> [15,]     0     0     1     0     1     1     0 #> [16,]     1     1     0     0     1     1     0 #> [17,]     1     0     0     0     1     1     1 #> [18,]     0     1     0     0     0     0     1 #> [19,]     0     1     0     1     1     0     0 #> [20,]     0     0     1     1     0     0     0 make_perturbed_graph(snafun::to_network(g), prob_tot = .3, prob_0_to_1 = 1) #>  Network attributes: #>   vertices = 20  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 160  #>     missing edges= 0  #>     non-missing edges= 160  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":null,"dir":"Reference","previous_headings":"","what":"Union of graphs — make_union","title":"Union of graphs — make_union","text":"union two graphs created. graphs may identical overlapping vertex sets.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Union of graphs — make_union","text":"","code":"make_union(..., byname = \"auto\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Union of graphs — make_union","text":"... Graph objects lists graph objects. Allowed graph classes igraph, network, matrix. byname logical scalar, character scalar \"auto\". Whether perform operation based symbolic vertex names. \"auto\", means TRUE graphs named FALSE otherwise. warning generated \"auto\" () graphs named.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Union of graphs — make_union","text":"graph object class igraph, network, matrix.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Union of graphs — make_union","text":"make_union() creates union two graphs. graphs combined can class igraph, network, matrix. Edges included least one graph part new graph. byname argument TRUE (\"auto\" graphs named), operation performed symbolic vertex names instead internal numeric vertex ids. make_union() keeps attributes graphs. graph, vertex edge attributes copied result. attribute present multiple graphs result name clash, attribute renamed adding suffixes: _1, _2, etc. name vertex attribute treated specially operation performed based symbolic vertex names. case name must present graphs, renamed result graph. error generated input graphs directed others undirected. actual union performed union function, also basis documentation function. make_union() mainly adds opportunity combine graphs different classes, just class igraph. fact, intrepid can even combine graphs different types together (although rarely useful). output graph class first graph passed function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/make_union.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Union of graphs — make_union","text":"","code":"net1 <- snafun::create_manual_graph(   D - A:B:F:G, A - C - F - A, B - E - G - B, A - B, F - G,   H - F:G, H - I - J ) net2 <- snafun::create_manual_graph(D - A:F:Y, B - A - X - F - H - Z, F - Y) net1_net2 <- make_union(net1, net2) #> Error in eval(kall[[1]]): object 'net1' not found if (FALSE) { # \\dontrun{   opar <- par()   par(\"mfrow\")   snafun::plot(net1)   snafun::plot(net2)   snafun::plot(net1_net2)   snafun::plot(igraph::union(net1, net2))   par(opar) } # }  make_union(snafun::to_network(net1), net2) #> Error in eval(kall[[1]]): object 'net1' not found make_union(net1, snafun::to_network(net2)) #> Error in eval(kall[[1]]): object 'net1' not found make_union(snafun::to_matrix(net1), net2) #> Error in eval(kall[[1]]): object 'net1' not found make_union(net1, snafun::to_matrix(net2)) #> Error in eval(kall[[1]]): object 'net1' not found  g <- snafun::create_manual_graph(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 4-6, 4-7, 5-6, 6-7) # Obtaining subgraphs h <- snafun::extract_subgraph(g, v_to_keep = 1:5) # subgraph only contains vertices 1 to 5  k <- snafun::create_manual_graph(4-6, 4-7, 5-6, 6-7) # create a new graph \"k\" h_k <- make_union(h,k) # combine \"h\" and \"k\" graphs  #> Error in eval(kall[[1]]): object 'h' not found if (FALSE) { # \\dontrun{   # Plotting the graphs    opar <- par()   par(mfrow=c(1, 3), mar = c(0,0,0,1))   set.seed(689)   snafun::plot(h)   snafun::plot(k)   snafun::plot(h_k)   par(opar) } # }  # more than two graphs # Note: the vertices end up in different orders, but the graphs are the same net3 <- snafun::create_manual_graph(H-I:K, I-E, X-Q-Z) snafun::make_union(net1, net2, net3) #> Error in eval(kall[[1]]): object 'net1' not found snafun::make_union(net1, net3, net2) #> Error in eval(kall[[1]]): object 'net1' not found snafun::make_union(net3, net2, net1) #> Error in eval(kall[[1]]): object 'net3' not found"},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge community membership — merge_membership","title":"Merge community membership — merge_membership","text":"Merge communities together nicer plotting.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge community membership — merge_membership","text":"","code":"merge_membership(coms, merges)"},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge community membership — merge_membership","text":"coms object class communities one appropriate igraph cluster / communities functions. merges list merged performed (see 'details' section)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge community membership — merge_membership","text":"new object class communities","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge community membership — merge_membership","text":"Community detection algorithms, cluster_edge_betweenness, cluster_fast_greedy, cluster_louvain, cluster_leiden, cluster_walktrap, et cetera, sometimes yield bunch small communities, addition larger, meaningful communities. always case isolates, might get community . , can useful merge () small communities together informative plotting. input function output one algorithms : object class communities. output also class communities can thus fed igraph's plot function. merges argument specifies communities merged. list, element contains numbers communities (specified coms object) need merged new community. list can contain multiple elements, become new community. See examples , well, examples . clarity, new communities numbered n + 1, 'n' number communities coms. NOTE: useful plotting!! thing function change membership vertices new membership structure. However, leaves modularity values intact also change 'merges' element coms object. Hence, running modularity output function return modularity original community memberships, new merged ones. However, easy calculate modularity new communities: see example section . Applying sizes works fine output function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/merge_membership.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge community membership — merge_membership","text":"","code":"if (FALSE) { # \\dontrun{ data(judge_net, package = \"SNA4DSData\") # original plot, with 5 communities coms <- igraph::cluster_fast_greedy(judge_net) plot(coms, judge_net) igraph::sizes(coms) # for illustration of the function, let's join node 40 with community 2 # it is best to merge into a new object, so the original result is not lost com2 <- merge_membership(coms, merges = list(c(2, 5))) plot(com2, judge_net) igraph::sizes(com2)  # Compute modularity for the new grouping # (Note: it is OK that the communities are not numbered consecutively) igraph::modularity(judge_net, com2$membership) # igraph::cluster_fast_greedy uses the edge weight by default. # To include that here as well, use: igraph::modularity(judge_net, com2$membership,         weights = igraph::E(judge_net)$weight) # Note: \\code{igraph::modularity} is only intended for undirected  # graphs with non-negative weights. In case of negative weights,  # use \\code{wsyn::modularity}.  # In case of directed graphs, I currently am not aware of a good  # implementation of modularity. } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the graph object — plot","title":"Plot the graph object — plot","text":"Plot graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the graph object — plot","text":"","code":"# S3 method for class 'igraph' plot(x, ...)  # S3 method for class 'network' plot(x, ...)"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the graph object — plot","text":"x graph object class network igraph ... Additional arguments.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the graph object — plot","text":"nothing, object merely plotted","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the graph object — plot","text":"Plots graph object class network igraph exactly plotted network igraph packages, respectively. function wraps plot.network plot.igraph. Whatever set ... passed onto original functions. See respective help pages (plot.network, plot.igraph, igraph.plotting) want use settings deviate default settings packages (almost always better using defaults). function plots objects just plotted packages attached, now need attached.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the graph object — plot","text":"","code":"g_i <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"igraph\") g_n <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"network\") plot(g_i)  plot(g_i, vertex.size = 12, vertex.color = \"green\", edge.width = 5, edge.curved = TRUE)  plot(g_n)  plot(g_n, vertex.cex = 3, vertex.col = \"green\", edge.lwd = 10,     edge.col = \"darkgrey\", usecurve = TRUE, edge.curve = .05,     arrowhead.cex = 3, displaylabels = TRUE, label.pos = 5)"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot one or more centrality scores — plot_centralities","title":"Plot one or more centrality scores — plot_centralities","text":"Plot one centrality scores vertices network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot one or more centrality scores — plot_centralities","text":"","code":"plot_centralities(   net,   measures = c(\"betweenness\", \"closeness\", \"degree\", \"eccentricity\"),   directed = TRUE,   mode = c(\"all\", \"out\", \"in\"),   k = 3,   rescaled = FALSE,   ... )"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot one or more centrality scores — plot_centralities","text":"net network class igraph network measures character vector one centrality measures directed logical, direction taken account? argument optional, chosen directionality network used. mode Character. default \"\". k k parameter \"geokpath\" measure. default 3. rescaled Logical scalar, whether rescale centrality scores add 1. ... arguments passed plot.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot one or more centrality scores — plot_centralities","text":"plot","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot one or more centrality scores — plot_centralities","text":"function creates grid plots containing values set centrality scores, selected user. function calculate requested scores plot . large network used many complex measures requested, calculations can take time. plotting fast. Since function calculates centrality scores , choice currently limited centralities implemented package. moment, \"betweenness\", \"closeness\", \"degree\", \"eccentricity\", \"eigenvector\", \"geokpath\", \"harmonic\", \"shapley\", \"stress\". default plot \"betweenness\", \"closeness\", \"degree\", \"eccentricity\". various arguments relate measures. mode, directed, rescaled arguments appled chosen measures function takes igraph object network object input.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_centralities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot one or more centrality scores — plot_centralities","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::erdos.renyi.game(20, 1/20) plot_centralities(g, measures = c(\"degree\", \"betweenness\")) # note that closeness is not well-defined for disconnected graphs plot_centralities(g)  data(florentine, package = \"snafun\") business <- florentine$flobusiness plot_centralities(business) plot_centralities(business, rescaled = TRUE) plot_centralities(business, measures = c(\"betweenness\", \"closeness\", \"degree\",     \"eccentricity\", \"eigenvector\", \"geokpath\", \"harmonic\", \"stress\")) bus_n <- snafun::to_network(business) plot_centralities(bus_n, c(\"degree\", \"betweenness\"), mode = \"out\", use_vertexnames = TRUE) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_comm_dendrogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a dendrogram of the community structure — plot_comm_dendrogram","title":"Plot a dendrogram of the community structure — plot_comm_dendrogram","text":"Plot hierarchical cluster analysis communities object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_comm_dendrogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a dendrogram of the community structure — plot_comm_dendrogram","text":"","code":"plot_comm_dendrogram(   x,   labels = NULL,   hang = 0.1,   axes = TRUE,   frame_plot = FALSE,   ann = TRUE,   main = \"Communities dendrogram\",   sub = \"\",   xlab = \"\",   ylab = \"\",   ... )"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_comm_dendrogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a dendrogram of the community structure — plot_comm_dendrogram","text":"x communities object labels character vector labels leaves tree. default row names row numbers original data used. labels = FALSE labels plotted. hang fraction plot height labels hang rest plot. negative value cause labels hang 0. axes, frame_plot, ann logical flags plot.default. main, sub, xlab, ylab character strings title. ... graphical arguments. E.g., cex controls size labels (plotted) way text.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_comm_dendrogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a dendrogram of the community structure — plot_comm_dendrogram","text":"nothing, plot shown","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_comm_dendrogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a dendrogram of the community structure — plot_comm_dendrogram","text":"Plot result one community detection algorithms nice dendrogram. Except x, arguments used plot function. works results extract_comm_walktrap, extract_comm_fastgreedy, extract_comm_girvan. (currently) work results extract_comm_louvain.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_nam.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics for the network autorrelation model — plot_nam","title":"Plot diagnostics for the network autorrelation model — plot_nam","text":"Plot diagnostics network autorrelation model","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_nam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics for the network autorrelation model — plot_nam","text":"","code":"plot_nam(x, ...)"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_nam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics for the network autorrelation model — plot_nam","text":"x output stat_nam ... ignored","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_nam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot diagnostics for the network autorrelation model — plot_nam","text":"nothing returned, plots displayed console","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_nam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot diagnostics for the network autorrelation model — plot_nam","text":"Plots diagnostics output stat_nam.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_network_slices.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot network slices — plot_network_slices","title":"Plot network slices — plot_network_slices","text":"Plot slices networkDynamic network","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_network_slices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot network slices — plot_network_slices","text":"","code":"plot_network_slices(x, number = 9, start = NULL, end = NULL, digits = 3)"},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_network_slices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot network slices — plot_network_slices","text":"x object class networkDynamic number number intervals start end start start time calculation end end time calculation digits number decimals, used show time slices plot","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_network_slices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot network slices — plot_network_slices","text":"plot","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/plot_network_slices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot network slices — plot_network_slices","text":"function variation filmstrip. function odd behavior plotting edges occur specific times, rather intervals. current function plots edges occur within time intervals. function splits time interval starting time (start) end time (end), number equal-sized intervals. plots include edges occur interval. default, overall interval covers period first edges starts last one ends. interval left-closed right-open. means can happen last edge included, starts ends last time point. can solved setting end time (little) higher actual end time.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the graph object — print","title":"Print the graph object — print","text":"Print graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the graph object — print","text":"","code":"# S3 method for class 'igraph' print(x, ...)  # S3 method for class 'network' print(x, na.omit = FALSE, ...)"},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the graph object — print","text":"x graph object class network igraph ... Additional agruments. na.omit logical; omit summarization missing attributes network object?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print the graph object — print","text":"nothing, object merely printed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print the graph object — print","text":"Prints graph object class network igraph exactly printed network igraph packages, respectively. function wraps print.network print.igraph. Whatever set ... passed onto original functions. See respective help pages want use settings deviate default settings packages. function prints objects just printed packages attached, now need attached.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print the graph object — print","text":"","code":"g_i <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"igraph\") g_n <- snafun::create_random_graph(10, \"gnm\", m = 20, graph = \"network\") print(g_i) #> IGRAPH c4bd602 D--- 10 20 -- Erdos-Renyi (gnm) graph #> + attr: name (g/c), type (g/c), loops (g/l), m (g/n) #> + edges from c4bd602: #>  [1]  1-> 8  2-> 3  2-> 8  3-> 5  3-> 7  4-> 1  4-> 2  4-> 7  5-> 6  6-> 1 #> [11]  6-> 3  6-> 7  7-> 2  7-> 3  8-> 2  8-> 6  9-> 1  9-> 7  9->10 10-> 1 print(g_n) #>  Network attributes: #>   vertices = 10  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   bipartite = FALSE  #>   total edges= 20  #>     missing edges= 0  #>     non-missing edges= 20  #>  #>  Vertex attribute names:  #>     vertex.names  #>  #> No edge attributes"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove parts of the graph — remove","title":"Remove parts of the graph — remove","text":"Remove parts graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove parts of the graph — remove","text":"","code":"remove_edge_attribute(x, attr_name)  remove_edge_weight(x)  remove_vertex_attribute(x, attr_name)  remove_graph_attribute(x, attr_name)  remove_vertex_names(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove parts of the graph — remove","text":"x input graph (class igraph network) attr_name name attribute removed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove parts of the graph — remove","text":"graph, without removed elements","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Remove parts of the graph — remove","text":"remove_edge_attribute(): remove edge attribute graph remove_edge_weight(): remove edge weight attribute graph. x matrix, function dichotomize turning every non-zero cell 1. remove_vertex_attribute(): remove vertex attribute graph remove_graph_attribute(): remove graph attribute graph remove_vertex_names(): remove vertex names graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove parts of the graph — remove","text":"","code":"data(emon, package = \"network\") texas <- emon$Texas remove_edge_attribute(texas, \"Frequency\") #>  Network attributes: #>   vertices = 25  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   total edges= 186  #>     missing edges= 0  #>     non-missing edges= 186  #>  #>  Vertex attribute names:  #>     Command.Rank.Score Decision.Rank.Score Formalization Location Paid.Staff Sponsorship Volunteer.Staff vertex.names  #>  #> No edge attributes remove_vertex_attribute(texas, \"Formalization\") #>  Network attributes: #>   vertices = 25  #>   directed = TRUE  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   total edges= 186  #>     missing edges= 0  #>     non-missing edges= 186  #>  #>  Vertex attribute names:  #>     Command.Rank.Score Decision.Rank.Score Location Paid.Staff Sponsorship Volunteer.Staff vertex.names  #>  #>  Edge attribute names:  #>     Frequency  remove_graph_attribute(texas, \"directed\") #>  Network attributes: #>   vertices = 25  #>   hyper = FALSE  #>   loops = FALSE  #>   multiple = FALSE  #>   total edges= 186  #>     missing edges= 0  #>     non-missing edges= 186  #>  #>  Vertex attribute names:  #>     Command.Rank.Score Decision.Rank.Score Formalization Location Paid.Staff Sponsorship Volunteer.Staff vertex.names  #>  #>  Edge attribute names:  #>     Frequency   texas_i <- to_igraph(texas) remove_edge_attribute(texas_i, \"Frequency\") #> IGRAPH c531a61 DN-- 25 186 --  #> + attr: name (v/c), vertex.names (v/c), Sponsorship (v/c), Paid.Staff #> | (v/n), Volunteer.Staff (v/n), Location (v/c), Formalization (v/n), #> | Decision.Rank.Score (v/n), Command.Rank.Score (v/n) #> + edges from c531a61 (vertex names): #> [1] US.Army.MAST..Ft..Sam.Houston.         ->Texas.Highway.Patrol           #> [2] US.Army.MAST..Ft..Sam.Houston.         ->Bandera.County.Sheriffs.Office #> [3] Division.of.Disaster.Emergency.Services->US.Army.MAST..Ft..Sam.Houston. #> [4] Division.of.Disaster.Emergency.Services->Texas.Highway.Patrol           #> [5] Division.of.Disaster.Emergency.Services->Texas.State.Parks.and.Wildlife #> [6] Division.of.Disaster.Emergency.Services->Texas.State.Highway.Department #> + ... omitted several edges remove_vertex_attribute(texas_i, \"Formalization\") #> IGRAPH c531a61 DN-- 25 186 --  #> + attr: name (v/c), vertex.names (v/c), Sponsorship (v/c), Paid.Staff #> | (v/n), Volunteer.Staff (v/n), Location (v/c), Decision.Rank.Score #> | (v/n), Command.Rank.Score (v/n), Frequency (e/n) #> + edges from c531a61 (vertex names): #> [1] US.Army.MAST..Ft..Sam.Houston.         ->Texas.Highway.Patrol           #> [2] US.Army.MAST..Ft..Sam.Houston.         ->Bandera.County.Sheriffs.Office #> [3] Division.of.Disaster.Emergency.Services->US.Army.MAST..Ft..Sam.Houston. #> [4] Division.of.Disaster.Emergency.Services->Texas.Highway.Patrol           #> [5] Division.of.Disaster.Emergency.Services->Texas.State.Parks.and.Wildlife #> [6] Division.of.Disaster.Emergency.Services->Texas.State.Highway.Department #> + ... omitted several edges"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_isolates.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove all isolates from the graph — remove_isolates","title":"Remove all isolates from the graph — remove_isolates","text":"Remove isolates graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_isolates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove all isolates from the graph — remove_isolates","text":"","code":"remove_isolates(x, loops = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_isolates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove all isolates from the graph — remove_isolates","text":"x graph class igraph network loops self-loops count deciding vertex isolate? See  extract_isolates details.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_isolates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove all isolates from the graph — remove_isolates","text":"graph isolates () removed","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_isolates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove all isolates from the graph — remove_isolates","text":"Removes isolates object class igraph network. First, algorithm identifies isolates, using extract_isolates function. , identified isolates removed new, smaller, graph returned. Obviously, x contain isolates, x returned unaltered.","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove loops — remove_loops","title":"Remove loops — remove_loops","text":"Remove loops graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove loops — remove_loops","text":"","code":"remove_loops(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove loops — remove_loops","text":"x graph class igraph, network, matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove loops — remove_loops","text":"graph class input","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove loops — remove_loops","text":"Remove loops (ie. tie vertex ) graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_loops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove loops — remove_loops","text":"","code":"x <- matrix(c(1, 1, 0, 0, 0, 1, 1, 0, 1), ncol = 3, byrow = TRUE) remove_loops(x) #>      [,1] [,2] [,3] #> [1,]    0    1    0 #> [2,]    0    0    1 #> [3,]    1    0    0 g_n <- snafun::to_network(x) snafun::to_matrix(g_n) #>   1 2 3 #> 1 1 1 0 #> 2 0 0 1 #> 3 1 0 1 remove_loops(g_n) |> snafun::to_matrix() #>   1 2 3 #> 1 0 1 0 #> 2 0 0 1 #> 3 1 0 0 remove_loops(snafun::to_igraph(x)) |> snafun::to_matrix() #>      [,1] [,2] [,3] #> [1,]    0    1    0 #> [2,]    0    0    1 #> [3,]    1    0    0"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_vertices.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove vertices — remove_vertices","title":"Remove vertices — remove_vertices","text":"Remove specific vertices graph","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_vertices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove vertices — remove_vertices","text":"","code":"remove_vertices(x, vertices)"},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_vertices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove vertices — remove_vertices","text":"x graph object class network igraph vertices vector either vertex names vertex id's.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_vertices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove vertices — remove_vertices","text":"graph without removed vertices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/remove_vertices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove vertices — remove_vertices","text":"Removes specific vertices graph (potentially bipartite) class network igraph. vertices removed can either id's names (exist graph object). algorithm first check vertices coincide vertex names present object (exist) , match, vertices removed according names. match, vertex names graph object, vertices assumed refer vertex id's.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/save_internal_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Save internal data — save_internal_data","title":"Save internal data — save_internal_data","text":"Save add internal data","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/save_internal_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save internal data — save_internal_data","text":"","code":"save_internal_data(   ...,   overwrite_vars = FALSE,   overwrite = FALSE,   compress = \"bzip2\",   version = 2 )"},{"path":"https://snanalyst.github.io/SNAfun/reference/save_internal_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save internal data — save_internal_data","text":"... names objects saved (symbols character strings). overwrite_vars logical, OK replace/overwrite existing objects new values? overwrite default function overwrite existing files. really want , set TRUE. compress Choose type compression used save(). one \"gzip\", \"bzip2\", \"xz\". version serialization format version use. default, 2, default format R 1.4.0 3.5.3. Version 3 became default R 3.6.0 can read R versions 3.5.0 higher.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/save_internal_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save internal data — save_internal_data","text":"nothing","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/save_internal_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save internal data — save_internal_data","text":"Saves internal data. arguments whether existing objects can safely overwritten whether data object can overwritten. NOTE: experimental, warranty doorstep best.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/snafun.html","id":null,"dir":"Reference","previous_headings":"","what":"snafun — snafun","title":"snafun — snafun","text":"Package supporting SNA4DS course","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/snafun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"snafun — snafun","text":"Functions, useful SNA4DS course. series functions provide (fairly) consistent API deal network igraph graph objects. reduces need (well, ) constantly switch network, sna, igraph packages, typical real life network analysis projects. switch still needed, snafun makes much less painful , yes, even fun. short: SNA FUN!","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/snafun.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"snafun — snafun","text":"Maintainer: Roger Leenders SNA4DS@jads.nl Authors: Claudia Zucca SNA4DS@jads.nl","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/soccer98.html","id":null,"dir":"Reference","previous_headings":"","what":"Soccer98 network — soccer98","title":"Soccer98 network — soccer98","text":"network based 32 soccer teams participated World Championship soccer Paris, 1998. Players national team often contracts countries. constitutes players market national teams \"export\" players countries. Members 32 teams contracts 36 countries.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/soccer98.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Soccer98 network — soccer98","text":"","code":"data(soccer98, package = \"snafun\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/soccer98.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Soccer98 network — soccer98","text":"Object class network size 36, directed, weighted, named.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/soccer98.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Soccer98 network — soccer98","text":"Data collected Lothar Krempel, October 5, 1999. Transformed Pajek format V. Batagelj, February 9, 2001. Raw data available Pajek datasets.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/soccer98.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Soccer98 network — soccer98","text":"vertices network 36 countries players national teams play . senders countries export players, receivers countries import players. edge weights *, j* represent number players nationality ** play country *j* time World Championship. exist countries exporters: Yugoslavia, Chile, Cameroon, Nigeria, ... countries importers: Spain, France, Turkey, Greece, GBR...","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"Estimates intensity effects using odds ratio probabilities","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"","code":"stat_ef_int(m, type = \"odds\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"m model object type Prints either Odds ratios Probabilities (\"odds\", \"prob\")","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"data.frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"function processes output Exponential Random Graph logistic models model estimates intensity effects using either Odds ratios Probabilities function returns data frame four colums: - Estimates - Either Odds ratios Probabilities - Standard Errors - P-values","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_ef_int.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the intensity of effects using odds ratio and probabilities — stat_ef_int","text":"","code":"if (FALSE) { # \\dontrun{ data(florentine, package = \"snafun\") fflom <- florentine$flomarriage flom <- to_network(fflom) m <- ergm::ergm(flom ~ edges + nodecov(\"Wealth\"))  stat_ef_int(m, \"prob\") } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":null,"dir":"Reference","previous_headings":"","what":"Network autocorrelation model — stat_nam","title":"Network autocorrelation model — stat_nam","text":"Run network autocorrelation model","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Network autocorrelation model — stat_nam","text":"","code":"stat_nam(   formula,   data = list(),   W,   W2 = NULL,   model = c(\"lag\", \"error\", \"combined\"),   na.action,   Durbin = FALSE,   quiet = TRUE,   zero.policy = TRUE,   check_vars = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Network autocorrelation model — stat_nam","text":"formula symbolic description model fit. data optional data frame containing variables model. default variables taken environment function called. W Spatial weight matrix lagged model error model. can matrix graph class network igraph. W2 Spatial weight matrix error, case combined model (otherwise, discarded). can matrix graph class network igraph model character, either lag, error, combined na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Durbin default FALSE (spatial lag model); TRUE, full spatial Durbin model; formula object, subset explanatory variables lag quiet default NULL, use !verbose global option value; FALSE, reports function values optimization. zero.policy TRUE, default, assign zero lagged value vertices without neighbours, FALSE assign NA - causing spatialreg::lagsarlm() terminate error check_vars TRUE, default, check performed whether variables right hand side formula non-constant. Note function add intercept default, constants wanted needed rhs formula.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Network autocorrelation model — stat_nam","text":"object class Sarlm","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Network autocorrelation model — stat_nam","text":"function can run lagged network autocorrelation model, error/disturbances model, combined model. particular, model = \"lag\" provides Maximum likelihood estimation spatial simultaneous autoregressive lag models form: $$y = \\rho W y + X \\beta + \\varepsilon$$ \\(\\rho\\) found optimize() first, \\(\\beta\\) parameters generalized least squares subsequently (one-dimensional search using optim performs badly platforms). one sparse matrix methods, larger numbers observations can handled. model = \"error\", Maximum likelihood estimation performed spatial simultaneous autoregressive error models form: $$y = X \\beta + u, u = \\lambda W u + \\varepsilon$$ \\(\\lambda\\) found optimize() first, \\(\\beta\\) parameters generalized least squares subsequently. one sparse matrix methods, larger numbers observations can handled. model = \"combined\", Maximum likelihood estimation performed spatial simultaneous autoregressive “SAC/SARAR” models form: $$y = \\rho W1 y + X \\beta + u, u = \\lambda W2 u + \\varepsilon$$ \\(\\rho\\) \\(\\lambda\\) found nlminb optim() first, \\(\\beta\\) parameters generalized least squares subsequently. actual fitting model performed lagsarlm, errorsarlm, sacsarlm functions handling weight matrix mat2listw function. function wraps functions sets defaults may useful network analysis, necessarily always ideal spatial analysis. Also, functions spatialreg package flexible exposed wrapper. , fitting full model, refer functions directly. note, though, functions handle weight matrix way uncommon network analyst, wrapper function makes accessing models lot straightforward. Also note original functions allow graphs class network igraph utilized weight matrices, another benefit function make possible. useful summary function implemented within spatialreg package.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Network autocorrelation model — stat_nam","text":"","code":"# Simulate data for the lagged model aantal_vars <- 10 nobs <- 50 rho = .3 coefs <- rnorm(aantal_vars) x <- rnorm(nobs*aantal_vars, sd = 8) x <- matrix(x, ncol = aantal_vars) colnames(x) <- LETTERS[1:ncol(x)] w <- sample(c(0, 1), nobs*nobs, replace = TRUE, prob = c(.8, .2)) w <- matrix(w, ncol = nobs) diag(w) <- 0 w <- w/rowSums(w)    # redundant eps <- rnorm(nobs, sd = 5) ie <- matrix(0, ncol = nobs, nrow = nobs) diag(ie) <- 1 y <- solve(ie - rho*w) %*% (x %*% coefs + eps) ix <- data.frame(y, x) mod <- stat_nam(y ~ ., data = ix, W = w) stat_nam_summary(mod) #>  #> Call:spatialreg::lagsarlm(formula = formula, data = data, listw = W,  #>     na.action = na.action, Durbin = Durbin, quiet = quiet, zero.policy = zero.policy) #>  #> Residuals: #>    Min     1Q Median     3Q    Max  #> -9.440 -3.157  0.508  2.369 10.319  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  -0.5578     0.9157   -0.61   0.5424     #> A            -2.1712     0.0766  -28.35  < 2e-16 *** #> B             0.9836     0.0997    9.86  < 2e-16 *** #> C             0.2250     0.0700    3.22   0.0013 **  #> D             1.3618     0.0822   16.58  < 2e-16 *** #> E            -1.1529     0.0724  -15.93  < 2e-16 *** #> F             0.1819     0.0908    2.00   0.0450 *   #> G             1.2718     0.0821   15.48  < 2e-16 *** #> H             1.1002     0.0851   12.93  < 2e-16 *** #> I             0.4845     0.0841    5.76  8.4e-09 *** #> J             0.7199     0.1041    6.92  4.6e-12 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Rho: 0.436, LR test value: 31.7, p-value: 1.77e-08 #> Asymptotic standard error: 0.0647 #>     z-value: 6.74, p-value: 1.63e-11 #> Wald statistic: 45.4, p-value: 1.63e-11 #>  #> Log likelihood: -141.4428 for lag model #> ML residual variance (sigma squared): 16.7, (sigma: 4.08) #> Nagelkerke pseudo-R-squared: 0.98  #> Number of observations: 50  #> Number of parameters estimated: 13  #> AIC: 309, (AIC for lm: 339) #> LM test for residual autocorrelation #> test value: 1.2, p-value: 0.273 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) A     B     C     D     E     F     G     #> rho         -0.01                                                             #> (Intercept)  0.01 -0.68                                                       #> A            0.00 -0.19  0.21                                                 #> B            0.00  0.03  0.16       -0.22                                     #> C            0.00  0.09 -0.06        0.00  0.11                               #> D            0.00 -0.26  0.10        0.06 -0.31  0.19                         #> E            0.00 -0.09 -0.05        0.06 -0.32 -0.24 -0.03                   #> F            0.00  0.04 -0.10        0.11 -0.16 -0.09  0.07  0.07             #> G            0.00 -0.17  0.11        0.04  0.21  0.12 -0.01 -0.10 -0.38       #> H            0.00  0.06 -0.21        0.11 -0.09  0.16  0.25 -0.02 -0.23  0.20 #> I            0.00 -0.06  0.10        0.32 -0.17 -0.30 -0.10  0.17  0.15 -0.18 #> J            0.00 -0.10  0.31       -0.12  0.30  0.24  0.09 -0.29 -0.32  0.16 #>             H     I     #> rho                     #> (Intercept)             #> A                       #> B                       #> C                       #> D                       #> E                       #> F                       #> G                       #> H                       #> I           -0.04       #> J            0.05 -0.10 #>  stat_nam_summary(mod, correlation = TRUE) #>  #> Call:spatialreg::lagsarlm(formula = formula, data = data, listw = W,  #>     na.action = na.action, Durbin = Durbin, quiet = quiet, zero.policy = zero.policy) #>  #> Residuals: #>    Min     1Q Median     3Q    Max  #> -9.440 -3.157  0.508  2.369 10.319  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  -0.5578     0.9157   -0.61   0.5424     #> A            -2.1712     0.0766  -28.35  < 2e-16 *** #> B             0.9836     0.0997    9.86  < 2e-16 *** #> C             0.2250     0.0700    3.22   0.0013 **  #> D             1.3618     0.0822   16.58  < 2e-16 *** #> E            -1.1529     0.0724  -15.93  < 2e-16 *** #> F             0.1819     0.0908    2.00   0.0450 *   #> G             1.2718     0.0821   15.48  < 2e-16 *** #> H             1.1002     0.0851   12.93  < 2e-16 *** #> I             0.4845     0.0841    5.76  8.4e-09 *** #> J             0.7199     0.1041    6.92  4.6e-12 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Rho: 0.436, LR test value: 31.7, p-value: 1.77e-08 #> Asymptotic standard error: 0.0647 #>     z-value: 6.74, p-value: 1.63e-11 #> Wald statistic: 45.4, p-value: 1.63e-11 #>  #> Log likelihood: -141.4428 for lag model #> ML residual variance (sigma squared): 16.7, (sigma: 4.08) #> Nagelkerke pseudo-R-squared: 0.98  #> Number of observations: 50  #> Number of parameters estimated: 13  #> AIC: 309, (AIC for lm: 339) #> LM test for residual autocorrelation #> test value: 1.2, p-value: 0.273 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) A     B     C     D     E     F     G     #> rho         -0.01                                                             #> (Intercept)  0.01 -0.68                                                       #> A            0.00 -0.19  0.21                                                 #> B            0.00  0.03  0.16       -0.22                                     #> C            0.00  0.09 -0.06        0.00  0.11                               #> D            0.00 -0.26  0.10        0.06 -0.31  0.19                         #> E            0.00 -0.09 -0.05        0.06 -0.32 -0.24 -0.03                   #> F            0.00  0.04 -0.10        0.11 -0.16 -0.09  0.07  0.07             #> G            0.00 -0.17  0.11        0.04  0.21  0.12 -0.01 -0.10 -0.38       #> H            0.00  0.06 -0.21        0.11 -0.09  0.16  0.25 -0.02 -0.23  0.20 #> I            0.00 -0.06  0.10        0.32 -0.17 -0.30 -0.10  0.17  0.15 -0.18 #> J            0.00 -0.10  0.31       -0.12  0.30  0.24  0.09 -0.29 -0.32  0.16 #>             H     I     #> rho                     #> (Intercept)             #> A                       #> B                       #> C                       #> D                       #> E                       #> F                       #> G                       #> H                       #> I           -0.04       #> J            0.05 -0.10 #>  plot_nam(mod)   #### Now a full combined model #Draw the AR matrix w1 <- snafun::create_random_graph(100, strategy = \"gnp\", p = .2) #Draw the MA matrix w2 <- snafun::create_random_graph(100, strategy = \"gnp\", p = .2) x <- matrix(rnorm(100*5),100,5) #Draw some covariates r1 <- 0.2                       #Set the model parameters r2 <- 0.1 sigma <- 0.1 beta <- rnorm(6) #Assemble y from its components: nu <- rnorm(100, 0, sigma)          #Draw the disturbances # only for the simulation, row-standardized weights are needed ww1 <- snafun::to_matrix(w1) ww1 <- ww1/rowSums(ww1) ww2 <- snafun::to_matrix(w2) ww2 <- ww2/rowSums(ww2) xx <- cbind(1, x) e <- qr.solve(diag(100) - r2 * ww2, nu) #Draw the effective errors y <- qr.solve(diag(100) - r1 * ww1, xx %*% beta + e)  #Compute y ix <- data.frame(y, x) mod <- stat_nam(y ~ ., data = ix, W = w1, W2 = w2, model = \"combined\") #> You supplied a weight matrix that was not row-normalized #>       this is still automatically done for this analysis. #> You supplied a weight matrix (W2) that was not row-normalized #>       this is still automatically done for this analysis. stat_nam_summary(mod) #>  #> Call:spatialreg::sacsarlm(formula = formula, data = data, listw = W,  #>     listw2 = W2, na.action = na.action, Durbin = Durbin, quiet = quiet,  #>     zero.policy = zero.policy) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.24989 -0.04861 -0.00287  0.06217  0.24593  #>  #> Type: sac  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  1.38425    0.07956    17.4   <2e-16 *** #> X1           0.45165    0.01004    45.0   <2e-16 *** #> X2          -0.01342    0.01029    -1.3     0.19     #> X3           0.93080    0.00934    99.7   <2e-16 *** #> X4           0.74419    0.00858    86.7   <2e-16 *** #> X5          -0.17749    0.01064   -16.7   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Rho: 0.298 #> Asymptotic standard error: 0.0396 #>     z-value: 7.51, p-value: 5.8e-14 #> Lambda: 0.395 #> Asymptotic standard error: 0.322 #>     z-value: 1.23, p-value: 0.219 #>  #> LR test value: 43.6, p-value: 3.46e-10 #>  #> Log likelihood: 96.6368 for sac model #> ML residual variance (sigma squared): 0.00845, (sigma: 0.0919) #> Nagelkerke pseudo-R-squared: 0.994  #> Number of observations: 100  #> Number of parameters estimated: 9  #> AIC: -175, (AIC for lm: -136) #>  #>  Correlation of coefficients  #>             sigma rho   lambda (Intercept) X1    X2    X3    X4    #> rho          0.00                                                  #> lambda      -0.03 -0.06                                            #> (Intercept)  0.00 -0.98  0.06                                      #> X1           0.00 -0.05  0.00   0.05                               #> X2           0.00 -0.05  0.00   0.03        0.09                   #> X3           0.00  0.04  0.00  -0.04        0.12  0.07             #> X4           0.00  0.09 -0.01  -0.08       -0.08  0.00  0.08       #> X5           0.00  0.21 -0.01  -0.20       -0.08 -0.11 -0.02  0.02 #>  stat_nam_summary(mod, correlation = TRUE) #>  #> Call:spatialreg::sacsarlm(formula = formula, data = data, listw = W,  #>     listw2 = W2, na.action = na.action, Durbin = Durbin, quiet = quiet,  #>     zero.policy = zero.policy) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.24989 -0.04861 -0.00287  0.06217  0.24593  #>  #> Type: sac  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  1.38425    0.07956    17.4   <2e-16 *** #> X1           0.45165    0.01004    45.0   <2e-16 *** #> X2          -0.01342    0.01029    -1.3     0.19     #> X3           0.93080    0.00934    99.7   <2e-16 *** #> X4           0.74419    0.00858    86.7   <2e-16 *** #> X5          -0.17749    0.01064   -16.7   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Rho: 0.298 #> Asymptotic standard error: 0.0396 #>     z-value: 7.51, p-value: 5.8e-14 #> Lambda: 0.395 #> Asymptotic standard error: 0.322 #>     z-value: 1.23, p-value: 0.219 #>  #> LR test value: 43.6, p-value: 3.46e-10 #>  #> Log likelihood: 96.6368 for sac model #> ML residual variance (sigma squared): 0.00845, (sigma: 0.0919) #> Nagelkerke pseudo-R-squared: 0.994  #> Number of observations: 100  #> Number of parameters estimated: 9  #> AIC: -175, (AIC for lm: -136) #>  #>  Correlation of coefficients  #>             sigma rho   lambda (Intercept) X1    X2    X3    X4    #> rho          0.00                                                  #> lambda      -0.03 -0.06                                            #> (Intercept)  0.00 -0.98  0.06                                      #> X1           0.00 -0.05  0.00   0.05                               #> X2           0.00 -0.05  0.00   0.03        0.09                   #> X3           0.00  0.04  0.00  -0.04        0.12  0.07             #> X4           0.00  0.09 -0.01  -0.08       -0.08  0.00  0.08       #> X5           0.00  0.21 -0.01  -0.20       -0.08 -0.11 -0.02  0.02 #>  plot_nam(mod)   # fit the disturbances model mod <- stat_nam(y ~ ., data = ix, W = w2, model = \"error\") #> You supplied a weight matrix that was not row-normalized #>       this is still automatically done for this analysis. stat_nam_summary(mod) #>  #> Call:spatialreg::errorsarlm(formula = formula, data = data, listw = W,  #>     na.action = na.action, Durbin = Durbin, quiet = quiet, zero.policy = zero.policy) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -0.3184 -0.0771  0.0101  0.0683  0.2580  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  1.96935    0.00909   216.7   <2e-16 *** #> X1           0.45301    0.01273    35.6   <2e-16 *** #> X2          -0.00642    0.01291    -0.5     0.62     #> X3           0.92395    0.01169    79.0   <2e-16 *** #> X4           0.73839    0.01082    68.2   <2e-16 *** #> X5          -0.19410    0.01325   -14.6   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Lambda: -0.272, LR test value: 0.322, p-value: 0.57 #> Asymptotic standard error: 0.427 #>     z-value: -0.637, p-value: 0.524 #> Wald statistic: 0.406, p-value: 0.524 #>  #> Log likelihood: 75.01227 for error model #> ML residual variance (sigma squared): 0.0131, (sigma: 0.114) #> Nagelkerke pseudo-R-squared: 0.991  #> Number of observations: 100  #> Number of parameters estimated: 8  #> AIC: -134, (AIC for lm: -136) #>  #>  Correlation of coefficients  #>             sigma lambda (Intercept) X1    X2    X3    X4    #> lambda       0.01                                            #> (Intercept)  0.00  0.00                                      #> X1           0.00  0.00  -0.03                               #> X2           0.00  0.00  -0.13        0.09                   #> X3           0.00  0.00  -0.04        0.13  0.08             #> X4           0.00  0.00   0.05       -0.07  0.01  0.08       #> X5           0.00  0.00   0.05       -0.09 -0.12 -0.03 -0.02 #>  stat_nam_summary(mod, correlation = TRUE) #>  #> Call:spatialreg::errorsarlm(formula = formula, data = data, listw = W,  #>     na.action = na.action, Durbin = Durbin, quiet = quiet, zero.policy = zero.policy) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -0.3184 -0.0771  0.0101  0.0683  0.2580  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  1.96935    0.00909   216.7   <2e-16 *** #> X1           0.45301    0.01273    35.6   <2e-16 *** #> X2          -0.00642    0.01291    -0.5     0.62     #> X3           0.92395    0.01169    79.0   <2e-16 *** #> X4           0.73839    0.01082    68.2   <2e-16 *** #> X5          -0.19410    0.01325   -14.6   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Lambda: -0.272, LR test value: 0.322, p-value: 0.57 #> Asymptotic standard error: 0.427 #>     z-value: -0.637, p-value: 0.524 #> Wald statistic: 0.406, p-value: 0.524 #>  #> Log likelihood: 75.01227 for error model #> ML residual variance (sigma squared): 0.0131, (sigma: 0.114) #> Nagelkerke pseudo-R-squared: 0.991  #> Number of observations: 100  #> Number of parameters estimated: 8  #> AIC: -134, (AIC for lm: -136) #>  #>  Correlation of coefficients  #>             sigma lambda (Intercept) X1    X2    X3    X4    #> lambda       0.01                                            #> (Intercept)  0.00  0.00                                      #> X1           0.00  0.00  -0.03                               #> X2           0.00  0.00  -0.13        0.09                   #> X3           0.00  0.00  -0.04        0.13  0.08             #> X4           0.00  0.00   0.05       -0.07  0.01  0.08       #> X5           0.00  0.00   0.05       -0.09 -0.12 -0.03 -0.02 #>  plot_nam(mod)   if (FALSE) { # \\dontrun{ # Model from Doreian (1980) data(huk, package = \"SNA4DSData\") x <- as.matrix(cbind(Intcpt = 1, hukYX[, -1])) lnam1 <- sna::lnam(y = hukYX$y, x = x, W1 = hukW) lnam2 <- sna::lnam(y = hukYX$y, x = x, W2 = hukW) lnam3 <- sna::lnam(y = hukYX$y, x = x, W = hukW, W2 = hukW)  # For comparison, the models with a row standardized W  lnam1 <- sna::lnam(y = hukYX$y, x = x, W1 = hukWstd) lnam2 <- sna::lnam(y = hukYX$y, x = x, W2 = hukWstd) lnam3 <- sna::lnam(y = hukYX$y, x = x, W = hukWstd, W2 = hukWstd)  # Same model with our function nam1 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, model = \"lag\") nam2 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, model = \"error\") nam3 <- snafun::stat_nam(y ~ ., data = hukYX, W = hukWstd, W2 = hukWstd, model = \"combined\") } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Network autocorrelation results — stat_nam_summary","title":"Network autocorrelation results — stat_nam_summary","text":"Extract summary network autocorrelation model analysis","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Network autocorrelation results — stat_nam_summary","text":"","code":"stat_nam_summary(   x,   correlation = TRUE,   R2 = TRUE,   digits = 3,   signif.stars = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Network autocorrelation results — stat_nam_summary","text":"x output object stat_nam correlation logical; TRUE (default), correlation matrix estimated parameters including sigma returned printed R2 logical; TRUE (default), Nagelkerke pseudo R-squared reported digits number significant digits use printing signif.stars ;ogical; TRUE (default), \"significance stars\" printed coefficient","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Network autocorrelation results — stat_nam_summary","text":"prints summary console invisibly returns summary object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_nam_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Network autocorrelation results — stat_nam_summary","text":"function wraps functions spatialreg package summarize results analysis stat_nam function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"Plots Goodness fit output model class ergm btergm","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"","code":"stat_plot_gof(   gof,   median_include = TRUE,   median_col = \"black\",   median_lwd = 2,   median_lty = \"solid\",   mean_include = TRUE,   mean_col = \"black\",   mean_lwd = 1,   mean_lty = \"dashed\",   ... )"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"gof gof model object fitted ergm btergm model median_include logical, median included? Default TRUE median_col character, name color plot median . median_lwd number, width line median. median_lty line type used plot median. Line types can either specified integer (0 = blank, 1 = solid (default), 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash) one character strings \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\", \"blank\" uses ‘invisible lines’ (.e., draw ). mean_include logical, mean included? Default TRUE. Ignored gof gof ergm. mean_col character, name color plot mean . mean_lwd number, width line mean. mean_lty line type used plot medn. Default \"dashed\". ... additional arguments. , gof ergm gof object, passed boxplot function (really somewhat potentially useful set color border argument). btergm gof, passed plot.gof function btergm package.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"Plots displaying Goodness Fit","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"function plots goodness--fit unipartite Exponential Random Graphs Models BTERGM models. process bipartite ERGMs model objects types Exponential random graph models object. graphical arguments function used btergm gof object passed, since ergm gof object support setting graphical arguments (exception ... argument).","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the Goodness of fit of a (bt)ergm result — stat_plot_gof","text":"","code":"if (FALSE) { # \\dontrun{ ### ergm model data(florentine, package = \"snafun\") flom <- to_network(florentine$flomarriage) m_ergm <- ergm::ergm(flom ~ edges + nodecov(\"Wealth\")) gof_ergm <- ergm::gof(m_ergm) stat_plot_gof(gof_ergm)  ### btergm model data(alliances, package = \"SNA4DSData\") m_btergm <- btergm::btergm(allianceNets ~ edges +    gwesp(0, fixed = TRUE) +   edgecov(lastYearsSharedPartners) +    edgecov(militaryDisputes) +    nodecov(\"polity\") +   nodecov(\"Composite_Index_National_Capability\") +    absdiff(\"polity\") +    absdiff(\"Composite_Index_National_Capability\") +   edgecov(sharedBorder),    R = 10, # number of bootstraps   parallel = \"snow\", ncpus = 16  # optional line )  # gof with on;y 10 simulations to keep time for the example low gof_btergm <- btergm:::gof.btergm(m_btergm, nsim = 10) stat_plot_gof(gof_btergm) stat_plot_gof(gof_btergm, median_include = FALSE) stat_plot_gof(gof_btergm, mean_col = \"green\", mean_lwd = 4, mean_lty = \"dotted\") stat_plot_gof(gof_btergm, mean_include = FALSE, median_col = \"orange\") stat_plot_gof(gof_btergm, mean_include = FALSE, median_include = FALSE) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":null,"dir":"Reference","previous_headings":"","what":"gof and plot (btergm style) — stat_plot_gof_as_btergm","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"Determine gof plot gof, using btergm approach","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"","code":"stat_plot_gof_as_btergm(   m,   ...,   btergm_statistics = c(btergm::esp, btergm::geodesic, btergm::deg, btergm::rocpr),   silent = FALSE,   verbose = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"m fitted ergm btergm model ... optional arguments, see description btergm_statistics vector statistics used gof silent logical, TRUE fewer messages printed calculation gof (function often still print output) verbose logical, FALSE, printing details gof function suppressed (warnings may still appear errors always shown)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"goodness fit silently returned","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"fitted ergm btergm, function calculates goodness fit (gof) plots . done using btergm engine, also works fitted ergm models. calculating gof, btergm provides option check fit model range statistics. See gof-statistics overview available statistics check . Note partly overlap statistics available ergm package, exactly. statistic required inluded btergm package use gof function (\"nodecov\"), need use ergm package can use function. ... argument allows one pass arguments gof function, target, formula, parallel, ncpus. See help gof options. Many messages returned whole process can suppressed setting silent = TRUE verbose = FALSE. NOTE: goodness fit silently returned. plot always plotted. NOTE: ergm btergm packages made separate research groups. result, objects functions 100 percent compatible. applying function ergm-model returns weird errors, better calculate gof using ergm package plot (using stat_plot_gof using ergm package functions). NOTE2: gof statistics models determined inside plotting functions (can used plotting), can take time run. useful gof results calculated function, also returned inspection.","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/stat_plot_gof_as_btergm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gof and plot (btergm style) — stat_plot_gof_as_btergm","text":"","code":"if (FALSE) { # \\dontrun{ ### ergm model data(florentine, package = \"snafun\") flom <- to_network(florentine$flomarriage) m_ergm <- ergm::ergm(flom ~ edges + nodecov(\"Wealth\")) gof_ergm <- stat_plot_gof_as_btergm(m_ergm) gof_ergm <- stat_plot_gof_as_btergm(m_ergm,          btergm_statistics = c(btergm::esp, btergm::dsp, btergm::deg)) gof_ergm  ### btergm model data(alliances, package = \"SNA4DSData\") m_btergm <- btergm::btergm(allianceNets ~ edges +    gwesp(0, fixed = TRUE) +   edgecov(lastYearsSharedPartners) +    edgecov(militaryDisputes) +    nodecov(\"polity\") +   nodecov(\"Composite_Index_National_Capability\") +    absdiff(\"polity\") +    absdiff(\"Composite_Index_National_Capability\") +   edgecov(sharedBorder),    R = 100, # number of bootstraps, perhaps set lower to just try the example   parallel = \"snow\", ncpus = 16  # optional line )  # gof with only 10 simulations to keep time for the example low gof_btergm <- stat_plot_gof_as_btergm(m_btergm, nsim = 10) gof_btergm <- stat_plot_gof_as_btergm(m_btergm,    parallel = \"snow\", ncpus = 12) gof_btergm gof_btergm <- stat_plot_gof_as_btergm(m_btergm,    parallel = \"snow\", ncpus = 12, silent = TRUE) gof_btergm <- stat_plot_gof_as_btergm(m_btergm,    parallel = \"snow\", ncpus = 12, verbose = FALSE, silent = TRUE) } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Dichotomize a matrix — to_binary_matrix","title":"Dichotomize a matrix — to_binary_matrix","text":"Make binary matrix weighted matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dichotomize a matrix — to_binary_matrix","text":"","code":"to_binary_matrix(mat, min)"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dichotomize a matrix — to_binary_matrix","text":"mat numeric matrix min threshold. values mat least minimum value become 1, values smaller minimum become 0.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dichotomize a matrix — to_binary_matrix","text":"dichotomized matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dichotomize a matrix — to_binary_matrix","text":"cell value smaller minimum value, cell becomes 0. cell value least minimum value, becomes 1. procedure work matrix, necessarily square one.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_binary_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dichotomize a matrix — to_binary_matrix","text":"","code":"M <- matrix(round(runif(20),1), ncol = 4) to_binary_matrix(M, min = .45) #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    1    0 #> [2,]    1    1    1    1 #> [3,]    0    0    0    0 #> [4,]    0    1    0    0 #> [5,]    0    1    1    1"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":null,"dir":"Reference","previous_headings":"","what":"Make edgelist — to_edgelist","title":"Make edgelist — to_edgelist","text":"Make edgelist set input objects. function anything igraph network/sna also already . usefulness function consistent API.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make edgelist — to_edgelist","text":"","code":"to_edgelist(x, named = TRUE, sort = \"from\")"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make edgelist — to_edgelist","text":"x input object named logical, vertex names returned (exist) (TRUE) (FALSE) sort character, name column sort . Defaults \"\".","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make edgelist — to_edgelist","text":"data frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make edgelist — to_edgelist","text":"Currently, input can matrix, igraph object network object.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_edgelist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make edgelist — to_edgelist","text":"","code":"## from an igraph object g_i <- igraph::sample_gnp(10, 2/10) to_edgelist(g_i) #>   from to #> 1    1  4 #> 2    2  4 #> 3    2  5 #> 6    2 10 #> 4    3  6 #> 7    3 10 #> 8    4 10 #> 5    5  6 #> 9    9 10  # add vertex names g1_i <- g_i igraph::V(g1_i)$name <- LETTERS[seq_len(igraph::gorder(g1_i))] to_edgelist(g1_i) #>   from to #> 1    A  D #> 2    B  D #> 3    B  E #> 6    B  J #> 4    C  F #> 7    C  J #> 8    D  J #> 5    E  F #> 9    I  J # add weights igraph::E(g1_i)$weight <- seq_len(igraph::ecount(g1_i)) to_edgelist(g1_i) #>   from to weight #> 1    A  D      1 #> 2    B  D      2 #> 3    B  E      3 #> 6    B  J      6 #> 4    C  F      4 #> 7    C  J      7 #> 8    D  J      8 #> 5    E  F      5 #> 9    I  J      9 # add further edge attribute g2_i <- g1_i |>      igraph::set_edge_attr(\"color\", value = \"red\") to_edgelist(g2_i) #>   from to weight color #> 1    A  D      1   red #> 2    B  D      2   red #> 3    B  E      3   red #> 6    B  J      6   red #> 4    C  F      4   red #> 7    C  J      7   red #> 8    D  J      8   red #> 5    E  F      5   red #> 9    I  J      9   red  ## from a matrix g_n <- sapply(runif(10, 0, 1), rep, 10) g_n <- sna::rgraph(10, tprob = g_n) to_edgelist(g_n) #>    from to #> 1     1  7 #> 2     1  9 #> 3     2  7 #> 4     3  2 #> 5     3  9 #> 6     4  2 #> 7     4  9 #> 8     5  2 #> 9     5  4 #> 10    5  9 #> 11    6  2 #> 12    6  3 #> 13    6  4 #> 14    7  3 #> 15    7  4 #> 16    7  9 #> 17    8  2 #> 18    8  3 #> 19    8  7 #> 20    8  9 #> 21    9  2 #> 22    9  7 #> 23    9  8 #> 24    9 10 #> 25   10  1 #> 26   10  2 #> 27   10  9 g_b <- igraph::make_bipartite_graph(c(rep(0, 5), rep(1, 3)), c(1,6,2,7,3,6,3,7,4,8,5,8)) to_edgelist(g_b) #>   from to #> 1    1  6 #> 2    2  7 #> 3    3  6 #> 4    3  7 #> 5    4  8 #> 6    5  8  ## from a network object g2_n <- network::as.network.matrix(g_n) to_edgelist(g2_n) #>    from to #> 15    1  7 #> 20    1  9 #> 16    2  7 #> 2     3  2 #> 21    3  9 #> 3     4  2 #> 22    4  9 #> 4     5  2 #> 12    5  4 #> 23    5  9 #> 5     6  2 #> 9     6  3 #> 13    6  4 #> 10    7  3 #> 14    7  4 #> 24    7  9 #> 6     8  2 #> 11    8  3 #> 17    8  7 #> 25    8  9 #> 7     9  2 #> 18    9  7 #> 19    9  8 #> 27    9 10 #> 1    10  1 #> 8    10  2 #> 26   10  9"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Make igraph object — to_igraph","title":"Make igraph object — to_igraph","text":"Make igraph object various input types.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make igraph object — to_igraph","text":"","code":"to_igraph(x, bipartite = FALSE, vertices = NULL)"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make igraph object — to_igraph","text":"x input object bipartite logical, whether adjacency matrix represents bipartite network. Forces creation bipartite igraph x. argument used matrix converted igraph object ignored otherwise. vertices data frame vertex metadata, NULL. See details .","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make igraph object — to_igraph","text":"following inputs supported: network object network object created network package matrix base R type matrix. matrix used input, function number rows equal number columns. , function assumes matrix refers bipartite network. assumption can overridden bipartite argument. data.frame data.frame contains edge list. data.frame requires first column contain senders second column contains receivers. additional columns, considered edge attributes. NOTE: created igraph object considered directed, depending structure input. undirected network required, run .undirected output function. matrix used input, function number rows equal number columns. , function assumes matrix refers bipartite network. assumption can overridden bipartite argument. vertices argument used x data.frame ignored otherwise. vertices NULL, first two columns x used symbolic edge list additional columns edge attributes. names attributes taken names columns. vertices NULL, must data frame giving vertex metadata. first column vertices assumed contain symbolic vertex names, added graphs ‘name’ vertex attribute. columns added additional vertex attributes. vertices NULL symbolic edge list given x checked contain vertex names listed vertices. See graph_from_data_frame underlying function.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Make igraph object — to_igraph","text":"functions largely based upon as_igraph functions migraph package. versions snafun package require tidyverse dependencies migraph deal tidygraph.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make igraph object — to_igraph","text":"","code":"# from a matrix g <- igraph::sample_gnp(10, 2/10) mat <- igraph::as_adjacency_matrix(g, sparse = FALSE) to_igraph(mat) #> IGRAPH ced8bb4 U--- 10 8 --  #> + edges from ced8bb4: #> [1] 1--6 1--8 2--3 2--6 3--4 3--7 5--6 8--9  g <- igraph::make_ring(10) igraph::E(g)$weight <- seq_len(igraph::ecount(g)) mat <- igraph::as_adjacency_matrix(g, sparse = FALSE, attr = \"weight\") to_igraph(mat) #> IGRAPH cedd178 U-W- 10 10 --  #> + attr: weight (e/n) #> + edges from cedd178: #>  [1] 1-- 2 1--10 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10  # bipartite network, even nodes are one type, odd vertices another type g <- igraph::make_bipartite_graph( rep(0:1,length=10), c(1:10)) mat <- igraph::as_adjacency_matrix(g, sparse = FALSE) to_igraph(mat)  # same network, but not officially bipartite #> IGRAPH cee15de U--- 10 5 --  #> + edges from cee15de: #> [1] 1-- 2 3-- 4 5-- 6 7-- 8 9--10 mat <- igraph::as_biadjacency_matrix(g, sparse = FALSE) to_igraph(mat, bipartite = TRUE) #> IGRAPH cee573d UN-B 10 5 --  #> + attr: type (v/l), name (v/c) #> + edges from cee573d (vertex names): #> [1] 1--2  3--4  5--6  7--8  9--10  relations <- data.frame(from = c(\"Bob\", \"Cecil\", \"Cecil\", \"David\",      \"David\", \"Esmeralda\"),      to = c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"),     same.dept = c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE),      friendship = c(4, 5, 5, 2, 1, 1), advice = c(4, 5, 5, 4, 2, 3)) to_igraph(relations) #> IGRAPH cee81c6 DN-- 5 6 --  #> + attr: name (v/c), same.dept (e/l), friendship (e/n), advice (e/n) #> + edges from cee81c6 (vertex names): #> [1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice #> [5] David    ->Bob   Esmeralda->Alice  if (FALSE) { # \\dontrun{ aa <- data.frame(from = c(1,1,2,2,3,3,4,4),      to = c(11, 12, 13, 14, 15, 16, 17, 18)) to_igraph(aa)  # message is given if this should ne bipartite to_igraph(aa, bipartite = TRUE)   } # }"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a matrix from a graph — to_matrix","title":"Make a matrix from a graph — to_matrix","text":"Make matrix various input graph types.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a matrix from a graph — to_matrix","text":"","code":"to_matrix(x)"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a matrix from a graph — to_matrix","text":"x graph object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a matrix from a graph — to_matrix","text":"matrix object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a matrix from a graph — to_matrix","text":"Create appropriate matrix various inputs: igraph bipartite network turned incidence matrix, network becomes adjacency matrix. original graph weighted (ie. edge attribute called 'weight'), resulting matrix weighted well. network bipartite network turned incidence matrix, network becomes adjacency matrix (non-sparse). original graph weighted (ie. edge attribute called 'weight'), resulting matrix weighted well. data.frame first two columns taken , respectively, denoting '' ''. exists, third column used values cells matrix. two columns edgelist, matrix weighted case edge occurs multiple times. graph assumed directed, one needs symmetrize matrix afterwards graph undirected. case senders receivers overlap edgelist, graph assumed bipartite incidence matrix (potentially weighted) returned","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a matrix from a graph — to_matrix","text":"","code":"actors <- data.frame(name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\", \"Esmeralda\"),     age=c(48,33,45,34,21),    gender=c(\"F\",\"M\",\"F\",\"M\",\"F\")) relations <- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\",     \"David\", \"Esmeralda\"),    to = c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"),     same.dept = c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE),     friendship = c(4, 5, 5, 2, 1, 1),     advice = c(4, 5, 5, 4, 2, 3))"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Make network object — to_network","title":"Make network object — to_network","text":"Make network object various input types.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make network object — to_network","text":"","code":"to_network(x, bipartite = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make network object — to_network","text":"x graph data object bipartite logical, x considered bipartite? overrides function's default choices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make network object — to_network","text":"network object","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_network.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make network object — to_network","text":"following inputs supported: network object network object igraph object igraph object matrix base R type matrix. matrix used input, function number rows equal number columns. , function assumes matrix refers bipartite network. assumption can overridden bipartite argument. data.frame data.frame contains edge list. data.frame requires first column contain senders second column contains receivers. additional columns, considered edge attributes. NOTE: created network object considered directed. undirected network required, run .undirected output function. argument bipartite used tell function whether input represents bipartite network . , set bipartite TRUE function attempt convert input bipartite network. However, argument intended convert bipartite network unipartite network conversion! NOTE: far know, function function correctly deals vertex attributes lists conversion igraph (allows lists) network (can deal lists attributes).","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetrize an adjacency matrix — to_symmetric_matrix","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"Symmetrize adjacency matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"","code":"to_symmetric_matrix(   g,   rule = c(\"weak\", \"mutual\", \"out\", \"in\", \"average\", \"max\", \"min\"),   na.rm = TRUE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"g input matrix rule character, rule follow deciding symmetrize na.rm logical, missing values cells ignored? used rules \"average\", \"max\", \"min\". rules \"\" \"\", NA copied cell copied rule. \"weak\", NA copied either ->j j->edges 1. \"mutual\", NA copied either ->j j->edges 1.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"symmatrized matrix","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"Turn (adjacency) matrix symmetric one, according several potential rules. diagonal matrix remains unaffected. Rule : g made symmetric copying upper triangle onto lower triangle. Rule : g made symmetric copying lower triangle onto upper triangle. Rule weak: every edge assumed reciprocated. Hence, edge $$ $j$ also becomes edge $j$ $$, Mathematically: <->j iff ->j <-j (rule) Rule mutual: every edge maintained already reciprocated g. Hence, edge $$ $j$ exist also $j$ $$, edges maintained resulting matrix. Otherwise (unreciprocated edges null dyads), resulting matrix neither contain edge $$ $j$ $j$ $$. Mathematically: <->j iff ->j <-j (rule) Rule average: values edges ($$, $j$) ($j$, $$) averaged assigned edges resulting matrix. typically result non-binary matrix. Rule max: edges ($$, $j$) ($j$, $$) assigned highest value two edges. input matrix g binary, yield result rule weak. Rule min: edges ($$, $j$) ($j$, $$) assigned lowest value two edges. input matrix g binary, yield result rule mutual.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/to_symmetric_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symmetrize an adjacency matrix — to_symmetric_matrix","text":"","code":"m <- matrix(c(0,1,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0), byrow = TRUE, ncol = 5)#'  m #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    0    1 #> [2,]    0    0    1    0    0 #> [3,]    0    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"out\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    0    1 #> [2,]    1    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    0    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"in\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    1    1 #> [2,]    0    0    1    0    0 #> [3,]    0    1    0    1    0 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"weak\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    1    1 #> [2,]    1    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"mutual\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    1 #> [2,]    0    0    1    0    0 #> [3,]    0    1    0    1    0 #> [4,]    0    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"average\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.0  0.5  0.5  0.5  1.0 #> [2,]  0.5  0.0  1.0  0.0  0.0 #> [3,]  0.5  1.0  0.0  1.0  0.5 #> [4,]  0.5  0.0  1.0  0.0  1.0 #> [5,]  1.0  0.0  0.5  1.0  0.0 to_symmetric_matrix(m, \"max\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    1    1 #> [2,]    1    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"min\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    1    0    1 #> [2,]    0    0    1    0    0 #> [3,]    0    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0 m[1, 2] <- m[3, 1] <- NA m #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0   NA    1    0    1 #> [2,]    0    0    1    0    0 #> [3,]   NA    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"out\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0   NA    1    0    1 #> [2,]   NA    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    0    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"in\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0   NA    1    1 #> [2,]    0    0    1    0    0 #> [3,]   NA    1    0    1    0 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"weak\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0   NA    1    1    1 #> [2,]   NA    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"mutual\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0   NA    0    1 #> [2,]    0    0    1    0    0 #> [3,]   NA    1    0    1    0 #> [4,]    0    0    1    0    1 #> [5,]    1    0    0    1    0 to_symmetric_matrix(m, \"average\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.0    0  1.0  0.5  1.0 #> [2,]  0.0    0  1.0  0.0  0.0 #> [3,]  1.0    1  0.0  1.0  0.5 #> [4,]  0.5    0  1.0  0.0  1.0 #> [5,]  1.0    0  0.5  1.0  0.0 to_symmetric_matrix(m, \"max\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    1    1    1 #> [2,]    0    0    1    0    0 #> [3,]    1    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    1    1    0 to_symmetric_matrix(m, \"min\") #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0   NA    1    0    1 #> [2,]    0    0    1    0    0 #> [3,]   NA    1    0    1    1 #> [4,]    1    0    1    0    1 #> [5,]    1    0    0    1    0"},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":null,"dir":"Reference","previous_headings":"","what":"Vertex level indices — vli","title":"Vertex level indices — vli","text":"Vertex level indices","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vertex level indices — vli","text":"","code":"v_degree(   x,   vids = NULL,   mode = c(\"all\", \"out\", \"in\"),   loops = FALSE,   rescaled = FALSE )  v_eccentricity(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE)  v_betweenness(x, vids = NULL, directed = TRUE, rescaled = FALSE)  v_stress(x, vids = NULL, directed = TRUE, rescaled = FALSE)  v_eigenvector(x, directed = TRUE, rescaled = FALSE)  v_closeness(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE)  v_harmonic(x, vids = NULL, mode = c(\"all\", \"out\", \"in\"), rescaled = FALSE)  v_pagerank(x, vids = NULL, damping = 0.85, directed = TRUE, rescaled = FALSE)  v_geokpath(   x,   vids = NULL,   mode = c(\"all\", \"out\", \"in\"),   k = 3,   rescaled = FALSE )  v_shapley(x, add.vertex.names = FALSE, vids = NULL, rescaled = FALSE)"},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vertex level indices — vli","text":"x graph object vids vertices measure calculated. default, vertices included. mode Character constant, gives whether shortest paths given vertices calculated directed graphs. shortest paths vertex, considered. , default, corresponding undirected graph used, edge directions ignored. argument ignored undirected graphs. loops Logical; whether loop edges also counted. rarely makes sense. Default FALSE. rescaled TRUE, scores rescaled sum 1. directed Logical, whether graph considered directed (directed begin ) damping damping factor (‘d’ original paper). k k parameter. default 3. add.vertex.names logical, output contain vertex names. requires vertex attribute name present graph. ignored attributed missing.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vertex level indices — vli","text":"Calculate several vertex level indices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Vertex level indices — vli","text":"v_degree(): Degree vertex. Weights discarded. Degree vertex defined number edges adjacent . v_eccentricity(): Eccentricity vertex. Weights discarded. heavy lifting done using eccentricity. eccentricity vertex shortest path distance farthest node graph. calculated measuring shortest distance () vertex, () vertices graph, taking maximum. implementation ignores vertex pairs different components. Isolate vertices eccentricity zero. v_betweenness(): Betweenness vertex. Weights discarded. corresponding dedicated functions inside igraph sna additional functions (including diverging ways taking weight account). settings v_betweenness want cases works similarly igraph network graph objects. betweenness vertex \\(v\\) considers number shortest paths pairs vertices (except paths \\(v\\). vertex pair, calculate proportion shortest paths vertices \\(\\) \\(j\\) pass \\(v\\). sum proportions equal \\(v\\)'s betweenness. Mathematically, betweenness vertex \\(v\\) given $$C_B(v) = \\sum_{,j : \\neq j, \\neq v, j \\neq v} \\frac{g_{ivj}}{g_{ij}}$$  \\(g_{ijk}\\) number geodesics \\(\\) \\(k\\) \\(j\\). simple words, betweenness vertex \\(v\\) answer : dyad include \\(v\\), add proportions shortest paths run \\(v\\). Conceptually, high-betweenness vertices lie large proportion shortest paths vertices; can thus thought “bridges” “boundary spanners” argued informationally-favorable position disproportionately fast access information rumors, assumption likely flow shortest paths graph (flow randomly). important consider whether assumed flow network occurs along directions edges (directed == TRUE) whether edge direction matter (directed == FALSE)–latter always case graph undirected . v_stress(): Stress centrality vertex. Weights discarded. stress centrality vertex \\(v\\) number shortest paths pairs vertices (except paths \\(v\\) pass \\(v\\). Mathematically, stress centrality vertex \\(v\\) given $$C_S(v) = \\sum_{,j : \\neq j, \\neq v, j \\neq v} g_{ivj}$$  \\(g_{ivk}\\) number geodesics \\(\\) \\(k\\)  \\(v\\). Conceptually, high-stress vertices lie large number shortest paths vertices; can thus thought “bridges” “boundary spanners” may experience high cognitive stress (case information networks) physical stress (case physical flow networks). important consider whether assumed flow network occurs along directions edges (directed == TRUE) whether edge direction matter (directed == FALSE)–latter always case graph undirected . v_eigenvector(): Eigenvector centrality vertex. Weights discarded. Eigenvector centrality scores correspond values first eigenvector graph adjacency matrix; scores may, turn, interpreted arising reciprocal process centrality actor proportional sum centralities actors s connected. general, vertices high eigenvector centralities connected many vertices , turn, connected many others (). Eigenvector centrality generalized Bonacich power centrality measure; see power_centrality bonpow details generalization. v_closeness(): Closeness vertex. Weights discarded. closeness centrality vertex \\(v\\) calculated inverse sum distances vertices graph. words, vertex \\(v\\), determine lengths shortest paths v vertices (caae \"\"), add . measures \"farness\" \\(v\\). closeness \\(v\\) inverse sum. higher number, shorter number steps reach vertices. Closeness centrality meaningful connected graphs. disconnected graphs, consider using harmonic centrality v_harmonic. function's work performed closeness. alternative implementation closeness. latter yields values g-1 times larger (g number vertices) takes alternative decisions special cases (e.g., unconnected vertices). v_harmonic(): Harmonic centrality vertex. Weights discarded. harmonic centrality vertex mean inverse distance vertices. inverse distance unreachable vertex considered zero. measure closely related closeness. closeness centrality meaningful connected graphs, harmonic centrality can calculated also disconnected graphs provides useful alternative cases. v_pagerank(): Google Pagerank centrality vertex. Weights discarded. explanation PageRank algorithm, see following webpage: Anatomy Large-Scale Hypertextual Web Search Engine, following reference: Sergey Brin Larry Page: Anatomy Large-Scale Hypertextual Web Search Engine. Proceedings 7th World-Wide Web Conference, Brisbane, Australia, April 1998. PageRank given vertex depends PageRank vertices, even want calculate PageRank vertices, must calculated first. Requesting PageRank vertices therefore result performance increase. vertices together, page rank always adds 1, rescaled effect. rescaled argument potentially useful vids specified consider values selected set vertices (whose pagerank usually add 1). v_geokpath(): Geodesic k-path centrality. Weights discarded. Geodesic K-path centrality vertex \\(v\\) counts number vertices can reached vertex \\(v\\) geodesic path length less \"k\". weights potentially required, use alternative implementation v_geokpath_w. vids specified, measure calculated induced subgraph consisting vertices (corresponding) edges. v_shapley(): Shapley Centrality function computes centrality vertices graph based Shapley value, following approach Michalak et al. (2013) paper.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vertex level indices — vli","text":"Michalak, T.P., Aadithya, K.V., Szczepanski, P.L., Ravindran, B. Jennings, N.R., 2013. Efficient computation Shapley value game-theoretic network centrality. Journal Artificial Intelligence Research, 46, pp.607-650. code Shapley centrality adapted CINNA::group_centrality gives result (version slightly robust).","code":""},{"path":[]},{"path":"https://snanalyst.github.io/SNAfun/reference/vli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vertex level indices — vli","text":"","code":"g <- igraph::make_star(10, mode = \"undirected\") v_eccentricity(g) #>  [1] 1 2 2 2 2 2 2 2 2 2 v_eccentricity(g, vids = c(1,3,5)) #> [1] 1 2 2 g_n <- snafun::to_network(g) v_eccentricity(g_n) #>  1  2  3  4  5  6  7  8  9 10  #>  1  2  2  2  2  2  2  2  2  2   i_bus <- florentine$flobusiness v_eccentricity(i_bus, vids = c(1, 5, 9)) #> Acciaiuoli Castellani     Medici  #>          0          3          4  v_eccentricity(i_bus, vids = c(\"Medici\", \"Peruzzi\")) #>  Medici Peruzzi  #>       4       3  n_bus <- to_network(i_bus) v_eccentricity(n_bus, vids = c(1, 5, 9)) #> Acciaiuoli Castellani     Medici  #>          0          3          4  v_eccentricity(n_bus, vids = c(\"Medici\", \"Peruzzi\")) #>  Medici Peruzzi  #>       4       3  #  # v_degree g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") g2_i <- snafun::add_edge_attributes(g_i, attr_name = \"weight\", value = 1:12) v_degree(g_i) #>  [1] 3 4 4 2 3 1 0 4 1 2 v_degree(g_i, rescaled = TRUE) #>  [1] 0.12500000 0.16666667 0.16666667 0.08333333 0.12500000 0.04166667 #>  [7] 0.00000000 0.16666667 0.04166667 0.08333333 v_degree(g_i, mode = \"in\") #>  [1] 2 2 2 1 1 1 0 3 0 0 v_degree(g_i, mode = \"in\", rescaled = TRUE) #>  [1] 0.16666667 0.16666667 0.16666667 0.08333333 0.08333333 0.08333333 #>  [7] 0.00000000 0.25000000 0.00000000 0.00000000 v_degree(g_i, mode = \"out\") #>  [1] 1 2 2 1 2 0 0 1 1 2 v_degree(g_i, mode = \"out\", rescaled = TRUE) #>  [1] 0.08333333 0.16666667 0.16666667 0.08333333 0.16666667 0.00000000 #>  [7] 0.00000000 0.08333333 0.08333333 0.16666667 v_degree(g2_i)   # weight is ignored #>  [1] 3 4 4 2 3 1 0 4 1 2  g_n <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                     directed = TRUE, graph = \"network\") g2_n <- snafun::add_edge_attributes(g_n, attr_name = \"weight\", value = 1:12) v_degree(g_n) #>  [1] 5 4 1 2 2 1 3 2 2 2 v_degree(g_n, rescaled = TRUE) #>  [1] 0.20833333 0.16666667 0.04166667 0.08333333 0.08333333 0.04166667 #>  [7] 0.12500000 0.08333333 0.08333333 0.08333333 v_degree(g_n, mode = \"in\") #>  [1] 2 2 1 1 2 0 1 1 1 1 v_degree(g_n, mode = \"in\", rescaled = TRUE) #>  [1] 0.16666667 0.16666667 0.08333333 0.08333333 0.16666667 0.00000000 #>  [7] 0.08333333 0.08333333 0.08333333 0.08333333 v_degree(g_n, mode = \"out\") #>  [1] 3 2 0 1 0 1 2 1 1 1 v_degree(g_n, mode = \"out\", rescaled = TRUE) #>  [1] 0.25000000 0.16666667 0.00000000 0.08333333 0.00000000 0.08333333 #>  [7] 0.16666667 0.08333333 0.08333333 0.08333333 v_degree(g2_n)   # weight is ignored #>  [1] 5 4 1 2 2 1 3 2 2 2 #  # v_betweenness g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") g2_i <- snafun::add_edge_attributes(g_i, attr_name = \"weight\", value = 1:12) v_betweenness(g_i) #>  [1] 0 0 0 0 0 0 2 0 1 5 v_betweenness(g_i, rescaled = TRUE) #>  [1] 0.000 0.000 0.000 0.000 0.000 0.000 0.250 0.000 0.125 0.625 v_betweenness(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] NaN NaN NaN NaN v_betweenness(g2_i)   # attribute \"weight\" is not used #>  [1] 0 0 0 0 0 0 2 0 1 5  g_n <- snafun::to_network(g_i) v_betweenness(g_n) #>  [1] 0 0 0 0 0 0 2 0 1 5 v_betweenness(g_n, rescaled = TRUE) #>  [1] 0.000 0.000 0.000 0.000 0.000 0.000 0.250 0.000 0.125 0.625 v_betweenness(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] NaN NaN NaN NaN  # star network g <- igraph::make_star(10, \"in\") plot(g)  v_betweenness(g) # there are no shortest paths with length >= 3 #>  [1] 0 0 0 0 0 0 0 0 0 0 v_betweenness(g, directed = FALSE) # all 36 shortest paths that do not include \"1\" go through \"1\" #>  [1] 36  0  0  0  0  0  0  0  0  0 #  # v_stress g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") v_stress(g_i) #>  [1]  0 11  0  0  3 22  6 12  9 20 v_stress(g_i, rescaled = TRUE) #>  [1] 0.00000000 0.13253012 0.00000000 0.00000000 0.03614458 0.26506024 #>  [7] 0.07228916 0.14457831 0.10843373 0.24096386 v_stress(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.0000000 0.7857143 0.0000000 0.2142857  g_n <- snafun::to_network(g_i) v_stress(g_n) #>  [1]  0 11  0  0  3 22  6 12  9 20 v_stress(g_n, rescaled = TRUE) #>  [1] 0.00000000 0.13253012 0.00000000 0.00000000 0.03614458 0.26506024 #>  [7] 0.07228916 0.14457831 0.10843373 0.24096386 v_stress(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.0000000 0.7857143 0.0000000 0.2142857  # star network g <- igraph::make_star(10, \"in\") plot(g)  v_stress(g) # there are no shortest paths with length >= 3 #>  [1] 0 0 0 0 0 0 0 0 0 0 v_stress(g, directed = FALSE) # all 36 shortest paths that do not include \"1\" go through \"1\" #>  [1] 36  0  0  0  0  0  0  0  0  0 #  # v_eigenvector g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") v_eigenvector(g_i) #>  [1] 0.000000e+00 0.000000e+00 1.387779e-16 0.000000e+00 7.071068e-01 #>  [6] 1.387779e-16 1.387779e-16 0.000000e+00 7.071068e-01 1.387779e-16 v_eigenvector(g_i, rescaled = TRUE) #>  [1] 5.102800e-16 2.747662e-16 0.000000e+00 2.355139e-16 5.000000e-01 #>  [6] 0.000000e+00 0.000000e+00 5.887847e-16 5.000000e-01 0.000000e+00 v_eigenvector(g_i, directed = FALSE) #>  [1] 1.517237e-01 4.752443e-01 8.461109e-17 1.894230e-01 5.291537e-01 #>  [6] 1.963244e-01 2.121977e-01 2.144010e-01 4.005463e-01 3.811322e-01  g_n <- snafun::to_network(g_i) v_eigenvector(g_n) #>            1            2            3            4            5            6  #> 0.000000e+00 0.000000e+00 1.387779e-16 5.551115e-17 7.071068e-01 1.387779e-16  #>            7            8            9           10  #> 1.387779e-16 0.000000e+00 7.071068e-01 1.387779e-16  v_eigenvector(g_n, rescaled = TRUE) #>            1            2            3            4            5            6  #> 7.850462e-17 3.140185e-16 2.158877e-16 3.140185e-16 5.000000e-01 2.158877e-16  #>            7            8            9           10  #> 2.158877e-16 3.532708e-16 5.000000e-01 2.158877e-16  v_eigenvector(g_n, directed = FALSE) #>            1            2            3            4            5            6  #> 1.517237e-01 4.752443e-01 6.319943e-17 1.894230e-01 5.291537e-01 1.963244e-01  #>            7            8            9           10  #> 2.121977e-01 2.144010e-01 4.005463e-01 3.811322e-01   # star network g <- igraph::make_star(10, \"in\") if (FALSE) { # \\dontrun{ v_eigenvector(g) # all 0 + a warning is issued } # } v_eigenvector(g, directed = FALSE)  #>  [1] 0.7071068 0.2357023 0.2357023 0.2357023 0.2357023 0.2357023 0.2357023 #>  [8] 0.2357023 0.2357023 0.2357023 #  # v_closeness g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") g2_i <- snafun::add_edge_attributes(g_i, attr_name = \"weight\", value = 1:12) v_closeness(g_i) #>  [1] 0.05263158 0.06250000 0.06250000 0.03333333 0.04545455 0.04545455 #>  [7] 0.05263158 0.05263158 0.03703704 0.06250000 1/rowSums(igraph::distances(g_i))  # same thing #>  [1] 0.05263158 0.06250000 0.06250000 0.03333333 0.04545455 0.04545455 #>  [7] 0.05263158 0.05263158 0.03703704 0.06250000 v_closeness(g_i, rescaled = TRUE) #>  [1] 0.10387657 0.12335343 0.12335343 0.06578850 0.08971159 0.08971159 #>  [7] 0.10387657 0.10387657 0.07309833 0.12335343 v_closeness(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.2359249 0.2801609 0.2801609 0.2037534 v_closeness(g2_i)   # attribute \"weight\" is not used #>  [1] 0.05263158 0.06250000 0.06250000 0.03333333 0.04545455 0.04545455 #>  [7] 0.05263158 0.05263158 0.03703704 0.06250000  g_n <- snafun::to_network(g_i) v_closeness(g_n) #>          1          2          3          4          5          6          7  #> 0.05263158 0.06250000 0.06250000 0.03333333 0.04545455 0.04545455 0.05263158  #>          8          9         10  #> 0.05263158 0.03703704 0.06250000  v_closeness(g_n, rescaled = TRUE) #>          1          2          3          4          5          6          7  #> 0.10387657 0.12335343 0.12335343 0.06578850 0.08971159 0.08971159 0.10387657  #>          8          9         10  #> 0.10387657 0.07309833 0.12335343  v_closeness(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #>         1         2         3         5  #> 0.2359249 0.2801609 0.2801609 0.2037534   # star network g <- igraph::make_star(10, \"in\") v_closeness(g)  # \"1\" has the highest closeness, the rest has the same value #>  [1] 0.11111111 0.05882353 0.05882353 0.05882353 0.05882353 0.05882353 #>  [7] 0.05882353 0.05882353 0.05882353 0.05882353 v_closeness(g, mode= \"in\")  # only \"1\" #>  [1] 0.1111111       NaN       NaN       NaN       NaN       NaN       NaN #>  [8]       NaN       NaN       NaN v_closeness(g, mode= \"out\") # all except \"1\" #>  [1] NaN   1   1   1   1   1   1   1   1   1 #  # v_harmonic g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") v_harmonic(g_i) #>  [1] 4.833333 3.250000 4.333333 0.000000 4.833333 5.500000 5.333333 3.416667 #>  [9] 0.000000 5.333333 v_closeness(g_i)   # harmonic works for disconnected graphs, closeness does not #>  [1] 0.08333333 0.05555556 0.07692308        NaN 0.08333333 0.10000000 #>  [7] 0.09090909 0.05882353        NaN 0.09090909 cor(v_harmonic(g_i), v_closeness(g_i), use = \"complete.obs\") # usually very high #> [1] 0.9914377 v_harmonic(g_i, rescaled = TRUE) #>  [1] 0.13122172 0.08823529 0.11764706 0.00000000 0.13122172 0.14932127 #>  [7] 0.14479638 0.09276018 0.00000000 0.14479638 v_harmonic(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.2801932 0.1884058 0.2512077 0.2801932  g_n <- snafun::to_network(g_i) v_harmonic(g_n) #>        1        2        3        4        5        6        7        8  #> 4.833333 3.250000 4.333333 0.000000 4.833333 5.500000 5.333333 3.416667  #>        9       10  #> 0.000000 5.333333  v_harmonic(g_n, rescaled = TRUE) #>          1          2          3          4          5          6          7  #> 0.13122172 0.08823529 0.11764706 0.00000000 0.13122172 0.14932127 0.14479638  #>          8          9         10  #> 0.09276018 0.00000000 0.14479638  v_harmonic(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #>         1         2         3         5  #> 0.2801932 0.1884058 0.2512077 0.2801932   # star network g <- igraph::make_star(10, \"in\") v_harmonic(g)  # \"1\" has the highest harmonic, the rest has the same value #>  [1] 9 5 5 5 5 5 5 5 5 5 v_harmonic(g, mode= \"in\")  # only \"1\" #>  [1] 9 0 0 0 0 0 0 0 0 0 v_harmonic(g, mode= \"out\") # all except \"1\" #>  [1] 0 1 1 1 1 1 1 1 1 1 #  # v_pagerank g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") v_pagerank(g_i) #>  [1] 0.03425821 0.06337768 0.14523048 0.07540684 0.03425821 0.11690210 #>  [7] 0.26111122 0.15979021 0.03425821 0.07540684 v_pagerank(g_i, rescaled = TRUE) #>  [1] 0.03425821 0.06337768 0.14523048 0.07540684 0.03425821 0.11690210 #>  [7] 0.26111122 0.15979021 0.03425821 0.07540684 v_pagerank(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.1236202 0.2286975 0.5240621 0.1236202 v_pagerank(g_i, damping = 0) #>  [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 v_pagerank(g_i, damping = .99)  # using 1 exactly may not be entirely stable #>  [1] 0.02127203 0.04233134 0.16586096 0.07600615 0.02127203 0.10748982 #>  [7] 0.29209885 0.17639062 0.02127203 0.07600615    g_n <- snafun::to_network(g_i) v_pagerank(g_n) #>          1          2          3          4          5          6          7  #> 0.03425821 0.06337768 0.14523048 0.07540684 0.03425821 0.11690210 0.26111122  #>          8          9         10  #> 0.15979021 0.03425821 0.07540684  v_pagerank(g_n, rescaled = TRUE) #>          1          2          3          4          5          6          7  #> 0.03425821 0.06337768 0.14523048 0.07540684 0.03425821 0.11690210 0.26111122  #>          8          9         10  #> 0.15979021 0.03425821 0.07540684  v_pagerank(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #>         1         2         3         5  #> 0.1236202 0.2286975 0.5240621 0.1236202   # star network g <- igraph::make_star(10, \"in\") v_pagerank(g)  # \"1\" has the highest pagerank, the rest has the same value #>  [1] 0.49008499 0.05665722 0.05665722 0.05665722 0.05665722 0.05665722 #>  [7] 0.05665722 0.05665722 0.05665722 0.05665722 #  # v_geokpath g_i <- snafun::create_random_graph(10, strategy = \"gnm\", m = 12,                                    directed = TRUE, graph = \"igraph\") g2_i <- snafun::add_edge_attributes(g_i, attr_name = \"weight\", value = 1:12) v_geokpath(g_i) #>  [1] 6 7 9 7 5 7 8 9 5 9 v_geokpath(g_i, rescaled = TRUE) #>  [1] 0.08333333 0.09722222 0.12500000 0.09722222 0.06944444 0.09722222 #>  [7] 0.11111111 0.12500000 0.06944444 0.12500000 v_geokpath(g_i, vids = c(1, 2, 3, 5), rescaled = TRUE) #> [1] 0.5 0.5 0.0 0.0 v_geokpath(g_i, k = 2) #>  [1] 2 6 6 5 3 5 5 8 3 7 v_geokpath(g_i, k = 1) #>  [1] 1 2 2 2 1 2 3 3 1 5 v_degree(g_i) # same #>  [1] 1 2 3 2 1 2 3 3 1 6  g_n <- snafun::to_network(g_i) v_geokpath(g_n) #>  1  2  3  4  5  6  7  8  9 10  #>  6  7  9  7  5  7  8  9  5  9  v_geokpath(g_n, rescaled = TRUE) #>          1          2          3          4          5          6          7  #> 0.08333333 0.09722222 0.12500000 0.09722222 0.06944444 0.09722222 0.11111111  #>          8          9         10  #> 0.12500000 0.06944444 0.12500000  v_geokpath(g_n, vids = c(1, 2, 3, 5), rescaled = TRUE) #>   1   2   3   5  #> 0.5 0.5 0.0 0.0  # # Shapley centrality # Figure 1 network from Michalak et al. g1 <- igraph::graph(c(4,1,5,1,1,6,1,7,1,8,8,11,11,12,11,13,6,2,7,2,8,2, 2,9,2,10,9,3,10,3), directed = FALSE) igraph::V(g1)$name <- LETTERS[1:13] v_shapley(g1) #>  [1] 2.0833333 1.7500000 1.0000000 0.6666667 0.6666667 0.6666667 0.6666667 #>  [8] 0.8333333 0.8333333 0.8333333 1.5000000 0.7500000 0.7500000 v_shapley(g1, add.vertex.names = TRUE) #>         A         B         C         D         E         F         G         H  #> 2.0833333 1.7500000 1.0000000 0.6666667 0.6666667 0.6666667 0.6666667 0.8333333  #>         I         J         K         L         M  #> 0.8333333 0.8333333 1.5000000 0.7500000 0.7500000"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the Bottleneck centrality score — v_bottleneck","title":"Find the Bottleneck centrality score — v_bottleneck","text":"often vertex bottleneck vertices graph?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the Bottleneck centrality score — v_bottleneck","text":"","code":"v_bottleneck(   graph,   mode = c(\"all\", \"out\", \"in\"),   vids = igraph::V(graph),   n = 4 )"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the Bottleneck centrality score — v_bottleneck","text":"graph input graph igraph object, network object, , adjacency matrix mode Character constant, gives whether shortest paths given vertices calculated directed graphs. shortest paths vertex, considered. , default, corresponding undirected graph used. argument ignored undirected graphs. vids Numeric vertex sequence, vertices considered. Default vertices. Otherwise, operation performed subgraph containing vertices vids. n scalar, defaults 4.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the Bottleneck centrality score — v_bottleneck","text":"data.frame vertex names (exist) bottleneck centrality scores. Otherwise, numeric vector contaning centrality scores selected vertices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the Bottleneck centrality score — v_bottleneck","text":"Consider geodesics \\(\\) vertices. node \\(v\\) part least 1/n-th geodesics, \\(v\\) said bottleneck \\(\\). default, n == 4, \\(v\\) bottleneck \\(\\) \\(v\\) part least one quarter geodesics \\(\\). bottleneck centrality \\(v\\) number vertices \\(v\\) bottleneck . score runs 0 (ie. vertex bottleneck vertex) \\(g - 1\\), g number vertices graph. calculation use edge weights, even graph weighted (implementation easily altered include weight well). Especially densely connected subgroups exist, multiple shortest paths possible two vertices. vertex appear least one , path counts part calculation. implies _bottleneck_ take account whether alternative geodesics two vertices; words, matter whether geodesic \\(v\\) part redundant alternative geodesics exist pair vertices \\(v\\) part length geodesic(s) \\(v\\) . Hence, removal bottleneck node graph may affect efficiency graph cases. Note geodesics end \\(v\\) also count calculation. , multiple geodesics \\(\\) \\(v\\), likely \\(v\\) count bottleneck \\(\\), although may realistic. alteration measure discard geodesics \\(v\\) might advisable. Also note implementation measure centiserve package incorrect, use function . Also note geodesics end \\(v\\) also count calculation. , multiple geodesics \\(\\) \\(v\\), likely \\(v\\) count bottleneck \\(\\), although may realistic. alteration measure discard geodesics \\(v\\) might advisable.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find the Bottleneck centrality score — v_bottleneck","text":"Przulj, N., Dennis . Wigle, Igor Jurisica. \"Functional topology network protein interactions.\" Bioinformatics 20.3 (2004): 340-348.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_bottleneck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the Bottleneck centrality score — v_bottleneck","text":"","code":"g <- igraph::graph(c(1,2,2,3,3,4,4,2)) v_bottleneck(g) #>   name bottleneck #> 1    1          0 #> 2    2          3 #> 3    3          0 #> 4    4          0 v_bottleneck(g, vids = c(1, 2, 4)) #>   name bottleneck #> 1    1          2 #> 2    2          2 #> 4    3          2 v_bottleneck(g, mode = \"out\") #>   name bottleneck #> 1    1          0 #> 2    2          3 #> 3    3          3 #> 4    4          2 v_bottleneck(g, mode = \"in\") #>   name bottleneck #> 1    1          0 #> 2    2          2 #> 3    3          1 #> 4    4          1  g <- igraph::make_star(10, mode = \"undirected\") v_bottleneck(g)  #>    name bottleneck #> 1     1          9 #> 2     2          0 #> 3     3          0 #> 4     4          0 #> 5     5          0 #> 6     6          0 #> 7     7          0 #> 8     8          0 #> 9     9          0 #> 10   10          0 g <- igraph::make_ring(10) v_bottleneck(g) # all 0 #>    name bottleneck #> 1     1          6 #> 2     2          6 #> 3     3          6 #> 4     4          6 #> 5     5          6 #> 6     6          6 #> 7     7          6 #> 8     8          6 #> 9     9          6 #> 10   10          6 v_bottleneck(g, n = Inf) # all 9 #>    name bottleneck #> 1     1          9 #> 2     2          9 #> 3     3          9 #> 4     4          9 #> 5     5          9 #> 6     6          9 #> 7     7          9 #> 8     8          9 #> 9     9          9 #> 10   10          9"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances to and from a vertex — v_distance","title":"Distances to and from a vertex — v_distance","text":"Distances vertex","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distances to and from a vertex — v_distance","text":"","code":"v_distance(   x,   mode = c(\"all\", \"out\", \"in\"),   weights = NULL,   count_unnconnected = FALSE )"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distances to and from a vertex — v_distance","text":"x input graph mode character, follow edge direction: \"\", \"\", \"\". Irrelevant undirected graphs weights NULL, name edge attribute use edge weights count_unnconnected logical, unconnected vertices included path lengths?","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distances to and from a vertex — v_distance","text":"data frame","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distances to and from a vertex — v_distance","text":"vertex, function returns average distance vertices, standard deviation distances, maximum distance, median distance, smmed distances. distances determined either following direction edges ( \"\" \"\")–case directed network, irrespective edge direction. Distances can weighted edge attribute. graph connected, obvious include distances /unconnected vertices. count_unnconnected TRUE, distances count infinite statistics hence infinite . count_unnconnected TRUE, paths unconnected vertices included. Isolates zero NA scores, obviously.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distances to and from a vertex — v_distance","text":"","code":"data(\"florentine\", package = \"snafun\") g <- florentine$flobusiness v_distance(g, mode = \"all\", count_unnconnected = FALSE) #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28 v_distance(g, mode = \"all\", count_unnconnected = TRUE) #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli       Inf    Inf   NaN Inf Inf #> Albizzi          Inf    Inf   NaN Inf Inf #> Barbadori        Inf    2.0   NaN Inf Inf #> Bischeri         Inf    3.5   NaN Inf Inf #> Castellani       Inf    2.5   NaN Inf Inf #> Ginori           Inf    2.5   NaN Inf Inf #> Guadagni         Inf    4.5   NaN Inf Inf #> Lamberteschi     Inf    3.5   NaN Inf Inf #> Medici           Inf    2.5   NaN Inf Inf #> Pazzi            Inf    3.5   NaN Inf Inf #> Peruzzi          Inf    2.5   NaN Inf Inf #> Pucci            Inf    Inf   NaN Inf Inf #> Ridolfi          Inf    Inf   NaN Inf Inf #> Salviati         Inf    3.5   NaN Inf Inf #> Strozzi          Inf    Inf   NaN Inf Inf #> Tornabuoni       Inf    3.5   NaN Inf Inf v_distance(g, mode = \"in\", count_unnconnected = FALSE) #> Warning: The graph is not fully weakly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28 v_distance(g, mode = \"out\", count_unnconnected = FALSE) #> Warning: The graph is not fully weakly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28 v_distance(snafun::to_network(g), mode = \"all\", count_unnconnected = FALSE) #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28 v_distance(snafun::to_network(g), mode = \"all\", count_unnconnected = TRUE) #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli       Inf    Inf   NaN Inf Inf #> Albizzi          Inf    Inf   NaN Inf Inf #> Barbadori        Inf    2.0   NaN Inf Inf #> Bischeri         Inf    3.5   NaN Inf Inf #> Castellani       Inf    2.5   NaN Inf Inf #> Ginori           Inf    2.5   NaN Inf Inf #> Guadagni         Inf    4.5   NaN Inf Inf #> Lamberteschi     Inf    3.5   NaN Inf Inf #> Medici           Inf    2.5   NaN Inf Inf #> Pazzi            Inf    3.5   NaN Inf Inf #> Peruzzi          Inf    2.5   NaN Inf Inf #> Pucci            Inf    Inf   NaN Inf Inf #> Ridolfi          Inf    Inf   NaN Inf Inf #> Salviati         Inf    3.5   NaN Inf Inf #> Strozzi          Inf    Inf   NaN Inf Inf #> Tornabuoni       Inf    3.5   NaN Inf Inf v_distance(snafun::to_network(g), mode = \"in\", count_unnconnected = FALSE) #> Warning: The graph is not fully weakly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28 v_distance(snafun::to_network(g), mode = \"out\", count_unnconnected = FALSE) #> Warning: The graph is not fully weakly connected, interpret result with prudence. #>              average median stdev max sum #> Acciaiuoli      0.00      0    NA   0   0 #> Albizzi         0.00      0    NA   0   0 #> Barbadori       1.06      2  0.82   3  17 #> Bischeri        1.56      2  1.42   4  25 #> Castellani      1.25      2  0.98   3  20 #> Ginori          1.38      2  1.10   4  22 #> Guadagni        2.00      3  1.81   5  32 #> Lamberteschi    1.50      2  1.47   4  24 #> Medici          1.19      1  1.19   4  19 #> Pazzi           1.75      2  1.44   5  28 #> Peruzzi         1.19      2  1.01   3  19 #> Pucci           0.00      0    NA   0   0 #> Ridolfi         0.00      0    NA   0   0 #> Salviati        1.75      2  1.44   5  28 #> Strozzi         0.00      0    NA   0   0 #> Tornabuoni      1.75      2  1.44   5  28  data(emon, package = \"network\") g_n <- emon$LakePomona v_distance(g_n, mode = \"all\") #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 0.95    1.0  0.22   1  19 #> Osage.County.Civil.Defense.Office                1.30    1.0  0.57   2  26 #> Osage.Country.Coroners.Office                    1.35    1.0  0.59   2  27 #> Osage.County.Attorneys.Office                    1.45    1.5  0.60   2  29 #> Kansas.State.Highway.Patrol                      0.95    1.0  0.22   1  19 #> Kansas.State.Parks.and.Resources.Authority       1.20    1.0  0.52   2  24 #> Kansas.State.Game.and.Fish.Commission            1.15    1.0  0.49   2  23 #> Kansas.State.Department.of.Transportation        1.70    2.0  0.57   2  34 #> US.Army.Corps.of.Engineers                       1.30    1.0  0.57   2  26 #> US.Army.Reserve                                  1.60    2.0  0.60   2  32 #> Crable.Ambulance                                 1.45    1.5  0.60   2  29 #> Franklin.County.Ambulance                        1.50    2.0  0.61   2  30 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.65    2.0  0.59   2  33 #> Shawnee.County.CD.Underwater.Rescue.Team         1.20    1.0  0.52   2  24 #> Burlingame.Police.Department                     1.10    1.0  0.45   2  22 #> Lyndon.Police.Department                         1.50    2.0  0.61   2  30 #> American.Red.Cross                               1.25    1.0  0.55   2  25 #> Topeka.Fire.Department.Rescue.No.1               1.65    2.0  0.59   2  33 #> Carbondale.Fire.Department                       1.55    2.0  0.60   2  31 #> Topeka.Radiator.and.Body.Works                   1.60    2.0  0.60   2  32 v_distance(g_n, mode = \"in\") #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 0.95    1.0  0.22   1  19 #> Osage.County.Civil.Defense.Office                1.60    2.0  0.60   2  32 #> Osage.Country.Coroners.Office                    1.35    1.0  0.59   2  27 #> Osage.County.Attorneys.Office                    1.65    2.0  0.59   2  33 #> Kansas.State.Highway.Patrol                      0.95    1.0  0.22   1  19 #> Kansas.State.Parks.and.Resources.Authority       1.25    1.0  0.55   2  25 #> Kansas.State.Game.and.Fish.Commission            1.25    1.0  0.55   2  25 #> Kansas.State.Department.of.Transportation        0.00    0.0    NA   0   0 #> US.Army.Corps.of.Engineers                       1.35    1.0  0.59   2  27 #> US.Army.Reserve                                  1.80    2.0  0.70   3  36 #> Crable.Ambulance                                 1.55    2.0  0.60   2  31 #> Franklin.County.Ambulance                        1.65    2.0  0.59   2  33 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.70    2.0  0.57   2  34 #> Shawnee.County.CD.Underwater.Rescue.Team         1.55    2.0  0.60   2  31 #> Burlingame.Police.Department                     1.80    2.0  0.52   2  36 #> Lyndon.Police.Department                         1.60    2.0  0.60   2  32 #> American.Red.Cross                               1.40    1.0  0.60   2  28 #> Topeka.Fire.Department.Rescue.No.1               2.30    2.5  0.86   3  46 #> Carbondale.Fire.Department                       0.00    0.0    NA   0   0 #> Topeka.Radiator.and.Body.Works                   1.70    2.0  0.57   2  34 v_distance(g_n, mode = \"out\") #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 1.15    1.0  0.57   2  23 #> Osage.County.Civil.Defense.Office                1.25    1.0  0.61   2  25 #> Osage.Country.Coroners.Office                    1.40    2.0  0.70   3  28 #> Osage.County.Attorneys.Office                    1.30    1.5  0.62   2  26 #> Kansas.State.Highway.Patrol                      1.10    1.0  0.55   2  22 #> Kansas.State.Parks.and.Resources.Authority       1.25    1.0  0.61   2  25 #> Kansas.State.Game.and.Fish.Commission            1.35    1.5  0.71   3  27 #> Kansas.State.Department.of.Transportation        1.65    2.0  0.65   3  33 #> US.Army.Corps.of.Engineers                       1.40    2.0  0.70   3  28 #> US.Army.Reserve                                  1.65    2.0  0.62   3  33 #> Crable.Ambulance                                 1.40    2.0  0.70   3  28 #> Franklin.County.Ambulance                        1.55    2.0  0.67   3  31 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.70    2.0  0.68   3  34 #> Shawnee.County.CD.Underwater.Rescue.Team         1.15    1.0  0.57   2  23 #> Burlingame.Police.Department                     0.90    1.0  0.34   2  18 #> Lyndon.Police.Department                         1.45    2.0  0.70   3  29 #> American.Red.Cross                               1.25    1.0  0.61   2  25 #> Topeka.Fire.Department.Rescue.No.1               1.55    2.0  0.67   3  31 #> Carbondale.Fire.Department                       1.50    2.0  0.69   3  30 #> Topeka.Radiator.and.Body.Works                   1.45    2.0  0.61   2  29 g_i <- snafun::to_igraph(g_n) v_distance(g_i, mode = \"all\") #> Warning: The graph is not fully strongly connected, interpret result with prudence. #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 0.95    1.0  0.22   1  19 #> Osage.County.Civil.Defense.Office                1.30    1.0  0.57   2  26 #> Osage.Country.Coroners.Office                    1.35    1.0  0.59   2  27 #> Osage.County.Attorneys.Office                    1.45    1.5  0.60   2  29 #> Kansas.State.Highway.Patrol                      0.95    1.0  0.22   1  19 #> Kansas.State.Parks.and.Resources.Authority       1.20    1.0  0.52   2  24 #> Kansas.State.Game.and.Fish.Commission            1.15    1.0  0.49   2  23 #> Kansas.State.Department.of.Transportation        1.70    2.0  0.57   2  34 #> US.Army.Corps.of.Engineers                       1.30    1.0  0.57   2  26 #> US.Army.Reserve                                  1.60    2.0  0.60   2  32 #> Crable.Ambulance                                 1.45    1.5  0.60   2  29 #> Franklin.County.Ambulance                        1.50    2.0  0.61   2  30 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.65    2.0  0.59   2  33 #> Shawnee.County.CD.Underwater.Rescue.Team         1.20    1.0  0.52   2  24 #> Burlingame.Police.Department                     1.10    1.0  0.45   2  22 #> Lyndon.Police.Department                         1.50    2.0  0.61   2  30 #> American.Red.Cross                               1.25    1.0  0.55   2  25 #> Topeka.Fire.Department.Rescue.No.1               1.65    2.0  0.59   2  33 #> Carbondale.Fire.Department                       1.55    2.0  0.60   2  31 #> Topeka.Radiator.and.Body.Works                   1.60    2.0  0.60   2  32 v_distance(g_i, mode = \"in\") #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 0.95    1.0  0.22   1  19 #> Osage.County.Civil.Defense.Office                1.60    2.0  0.60   2  32 #> Osage.Country.Coroners.Office                    1.35    1.0  0.59   2  27 #> Osage.County.Attorneys.Office                    1.65    2.0  0.59   2  33 #> Kansas.State.Highway.Patrol                      0.95    1.0  0.22   1  19 #> Kansas.State.Parks.and.Resources.Authority       1.25    1.0  0.55   2  25 #> Kansas.State.Game.and.Fish.Commission            1.25    1.0  0.55   2  25 #> Kansas.State.Department.of.Transportation        0.00    0.0    NA   0   0 #> US.Army.Corps.of.Engineers                       1.35    1.0  0.59   2  27 #> US.Army.Reserve                                  1.80    2.0  0.70   3  36 #> Crable.Ambulance                                 1.55    2.0  0.60   2  31 #> Franklin.County.Ambulance                        1.65    2.0  0.59   2  33 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.70    2.0  0.57   2  34 #> Shawnee.County.CD.Underwater.Rescue.Team         1.55    2.0  0.60   2  31 #> Burlingame.Police.Department                     1.80    2.0  0.52   2  36 #> Lyndon.Police.Department                         1.60    2.0  0.60   2  32 #> American.Red.Cross                               1.40    1.0  0.60   2  28 #> Topeka.Fire.Department.Rescue.No.1               2.30    2.5  0.86   3  46 #> Carbondale.Fire.Department                       0.00    0.0    NA   0   0 #> Topeka.Radiator.and.Body.Works                   1.70    2.0  0.57   2  34 v_distance(g_i, mode = \"out\") #>                                               average median stdev max sum #> Osage.County.Sheriffs.Department                 1.15    1.0  0.57   2  23 #> Osage.County.Civil.Defense.Office                1.25    1.0  0.61   2  25 #> Osage.Country.Coroners.Office                    1.40    2.0  0.70   3  28 #> Osage.County.Attorneys.Office                    1.30    1.5  0.62   2  26 #> Kansas.State.Highway.Patrol                      1.10    1.0  0.55   2  22 #> Kansas.State.Parks.and.Resources.Authority       1.25    1.0  0.61   2  25 #> Kansas.State.Game.and.Fish.Commission            1.35    1.5  0.71   3  27 #> Kansas.State.Department.of.Transportation        1.65    2.0  0.65   3  33 #> US.Army.Corps.of.Engineers                       1.40    2.0  0.70   3  28 #> US.Army.Reserve                                  1.65    2.0  0.62   3  33 #> Crable.Ambulance                                 1.40    2.0  0.70   3  28 #> Franklin.County.Ambulance                        1.55    2.0  0.67   3  31 #> Lees.Summit.Underwater.Rescue.Team..Missouri.    1.70    2.0  0.68   3  34 #> Shawnee.County.CD.Underwater.Rescue.Team         1.15    1.0  0.57   2  23 #> Burlingame.Police.Department                     0.90    1.0  0.34   2  18 #> Lyndon.Police.Department                         1.45    2.0  0.70   3  29 #> American.Red.Cross                               1.25    1.0  0.61   2  25 #> Topeka.Fire.Department.Rescue.No.1               1.55    2.0  0.67   3  31 #> Carbondale.Fire.Department                       1.50    2.0  0.69   3  30 #> Topeka.Radiator.and.Body.Works                   1.45    2.0  0.61   2  29"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":null,"dir":"Reference","previous_headings":"","what":"Geodesic k-path centrality — v_geokpath_w","title":"Geodesic k-path centrality — v_geokpath_w","text":"Geodesic K-path centrality counts number vertices can reached geodesic path length less \"k\".","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geodesic k-path centrality — v_geokpath_w","text":"","code":"v_geokpath_w(   graph,   vids = NULL,   mode = c(\"all\", \"out\", \"in\"),   weights = NULL,   k = 3 )"},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geodesic k-path centrality — v_geokpath_w","text":"graph input graph igraph object vids Numeric vertex sequence, vertices considered. Default vertices. Otherwise, operation performed subgraph containing vertices vids. mode Character constant, gives whether shortest paths given vertices calculated directed graphs. shortest paths vertex, considered. , default, corresponding undirected graph used, ie. directed paths searched. argument ignored undirected graphs. weights Possibly numeric vector giving edge weights. NULL, default, graph weight edge attribute, attribute used. NA weights used (even graph weight attribute). k k parameter. default 3.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geodesic k-path centrality — v_geokpath_w","text":"numeric vector contaning centrality scores selected vertices.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Geodesic k-path centrality — v_geokpath_w","text":"function counts number vertices specific vertex can reach within k steps. default, number weighted (graph weight edge attribute). can overridden setting weights argument NA (weight used) vector weights (typically numeric edge attribute). detail Geodesic K-Path Centrality","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Geodesic k-path centrality — v_geokpath_w","text":"Borgatti, Stephen P., Martin G. Everett. \"graph-theoretic perspective centrality.\" Social networks 28.4 (2006): 466-484.","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Geodesic k-path centrality — v_geokpath_w","text":"Mahdi Jalili m_jalili@farabi.tums.ac.ir (adapted package)","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/v_geokpath_w.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geodesic k-path centrality — v_geokpath_w","text":"","code":"g <- igraph::barabasi.game(100) #> Warning: `barabasi.game()` was deprecated in igraph 2.0.0. #> ℹ Please use `sample_pa()` instead. v_geokpath_w(g) #>   [1] 69 62 67 41 62 32 21 42 11 52 43 11 52 52 42 43 11 21 43 52 42 52 24 14  9 #>  [26] 15 15 52 53 52 45 11 13 13 52 52 32 16 32 32  5 14 15 32 25 15 10 13 52 52 #>  [51] 52 14 42 13 32 52 32 13 11 11 52 32 52 15  5 11 32 32 25 15 13  5 24  3  8 #>  [76] 25  9  8 52 10 32 10 52  9 52 24 24  9  3  7  3 15  9 24  3 11 42  4 52 15"},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":null,"dir":"Reference","previous_headings":"","what":"Catch output and warnings — withWarnings","title":"Catch output and warnings — withWarnings","text":"Catch output warnings evaluating expression","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catch output and warnings — withWarnings","text":"","code":"withWarnings(expr)"},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catch output and warnings — withWarnings","text":"expr valied R expression","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catch output and warnings — withWarnings","text":"list, see contents","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Catch output and warnings — withWarnings","text":"expressions generate warning, besides output. cases, profitable print warning console, still capture warning. can use suppressWarnings, suppresses warning altogether checked programatically whether warning triggered (warning). little function evaluates expression stores result list two entries: value object returned evaluating expression warnings list lists contains warnings; warning separate list within overall list. warnings NULL warnings generated. warning printed console, errors messages . function intended internal use openly exposed user (exported potential use elsewhere).","code":""},{"path":"https://snanalyst.github.io/SNAfun/reference/withWarnings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Catch output and warnings — withWarnings","text":"","code":"uit <- withWarnings(sum(c(1:3))) uit$value   # 6 #> [1] 6 class(uit$value)  # integer #> [1] \"integer\" class(uit$warnings)  # NULL #> [1] \"NULL\" is.null(uit$warnings)   # TRUE #> [1] TRUE  testit <- function(x) {     warning(\"testit_warning\")     sum(x) } uit <- withWarnings(testit(1:3)) uit$value   # 6 #> [1] 6 is.list(uit$warnings)  # TRUE #> [1] TRUE uit$warnings[[1]]   # <simpleWarning in testit(1:3): testit_warning> #> <simpleWarning in testit(1:3): testit_warning> inherits(uit$warnings[[1]], \"simpleWarning\")  # TRUE #> [1] TRUE # check for this specific warning grepl(\"testit_warning\", uit$warnings[[1]])  # TRUE #> [1] TRUE"}]
